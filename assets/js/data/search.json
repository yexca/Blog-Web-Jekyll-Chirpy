[
  
  {
    "title": "hvdb 注册检测",
    "url": "/archives/133",
    "categories": "日常",
    "tags": "Docker",
    "date": "2023-12-02 21:23:00 +0800",
    





    
    "snippet": "从 ???? 我记不清了 开始喜欢上 ASMR 后就接触到了音声，不过高昂的价格显然会驱使我去广袤的互联网上搜索，于是便知道了这个网站，可此网站只有登录后才可以看到更多内容，而每年也几乎是不定时开放注册，这使我很好奇这个网站于是我便想着让服务器运行程序检测是否可以注册，然后通知Github: yexca/hvdb目标检测是否可以注册，如果可以便通过 Telegram 通知检测是否可以注册在灵...",
    "content": "从 ???? 我记不清了 开始喜欢上 ASMR 后就接触到了音声，不过高昂的价格显然会驱使我去广袤的互联网上搜索，于是便知道了这个网站，可此网站只有登录后才可以看到更多内容，而每年也几乎是不定时开放注册，这使我很好奇这个网站于是我便想着让服务器运行程序检测是否可以注册，然后通知Github: yexca/hvdb目标检测是否可以注册，如果可以便通过 Telegram 通知检测是否可以注册在灵梦广场的一个帖子回复中可以获知当开放注册时 login 的底下会出现 register那便可以用一种最简朴的方法，爬取这个网页，检查是否有此单词Bot 配置使用 Telegram 的 bot 通知需要先注册一个 bot对话 https://t.me/BotFather 输入 /newbot 指令按照步骤创建一个 bot和刚创建的 bot 对话，发送 hello然后访问 (将 TOKEN 替换为自己的 token)https://api.telegram.org/botTOKEN/getUpdates会得到一个 json 文件，找到 id，此 id 为 chat_id参考：使用Telegram Bot来实现推送通知Python通过 Python 是最简单的 (我也懒得看其他语言了)爬取使用 Requests 库，通知的话使用 pyTelegramBotAPI多余的不解析了，直接放代码 (此文件名不要命名为 http.py 或 requests.py)import telebotimport requestsimport time# 替换自己的 tokenbot = telebot.TeleBot(\"TOKEN\", parse_mode=\"MARKDOWN\") # You can set parse_mode by default. HTML or MARKDOWNdef inform():    web = requests.get(\"https://hvdb.me/\")    str = web.text    a = str.find(\"register\")    if a != -1:        # 替换自己的 chat_id        bot.send_message(\"chat_id\", \"[hvdb](http://hvdb.me/) register start\")        t = 0while True:    inform()    # 每小时执行一次    time.sleep(3600)    # 计时是否执行了 24 小时    t += 1    # 每天提醒一次程序在执行    if t == 24:        t -= 24        local_time = time.ctime(time.time())        inform_str = \"{} 已执行\".format(local_time)        # 替换自己的 chat_id        bot.send_message(\"chat_id\", inform_str)参考资料关于报错“AttributeError:partially initialized module‘requests‘has no attribute‘get‘的解决方法requests - 廖雪峰的官方网站Python  time sleep()方法 - 菜鸟教程Python 日期和时间 - 菜鸟教程Docker 封装文件结构D:\\DOCKER\\HVDB    Dockerfile    inform.pyDockerfile 文件FROM python:3.11-alpineRUN pip install requests \\    &amp;&amp; pip install pyTelegramBotAPICOPY ./inform.py /app/inform.pyCMD [ \"python\", \"/app/inform.py\" ]同目录下运行命令打包镜像docker build -t hvdb:v1.0 .转移到服务器Windows 下docker save -o hvdb:v1.0 hvdb.tar等待打包完成，复制到服务器scp .\\hvdb.tar username@hostname:/path复制完成后，服务器运行docker load -i hvdb.tar参考：docker load报错：Error processing tar file(exit status 1): archive/tar: invalid tar header"
  },
  
  {
    "title": "备忘录模式",
    "url": "/archives/132",
    "categories": "软件工程",
    "tags": "对象行为型模式, 设计模式",
    "date": "2023-11-27 14:08:00 +0800",
    





    
    "snippet": "Memento Pattern 对象行为型模式意图在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态结构其中：  Memento (备忘录) 存储原发器对象的内部状态，原发器根据需要决定备忘录存储原发器的哪些内部状态；防止原发器以外的其他对象访问备忘录  Originator (原发器) 创建一个备忘录，用于记录当前时刻它的内部状...",
    "content": "Memento Pattern 对象行为型模式意图在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态结构其中：  Memento (备忘录) 存储原发器对象的内部状态，原发器根据需要决定备忘录存储原发器的哪些内部状态；防止原发器以外的其他对象访问备忘录  Originator (原发器) 创建一个备忘录，用于记录当前时刻它的内部状态；使用备忘录恢复内部状态  Caretaker (管理者) 负责保存好备忘录；不能对备忘录的内容进行操作或检查适用性Memento 模式适用于：  必须保存一个对象在某一个时刻的 (部分) 状态，这样以后需要时它才能恢复到先前的状态  如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性例子import java.util.ArrayList;import java.util.List;public class MementoPattern {    public static void main(String[] args) {        Caretaker caretaker = new Caretaker();        Originator originator = new Originator();        originator.setState(\"first\");        Memento memento1 = originator.createMemento();        caretaker.addMemento(memento1);        originator.setState(\"second\");        Memento memento2 = originator.createMemento();        caretaker.addMemento(memento2);        originator.setState(\"third\");        Memento memento3 = originator.createMemento();        caretaker.addMemento(memento3);        caretaker.showMemento();        Memento backup = caretaker.getMemento(2);        originator.setMemento(backup);        System.out.println(\"=========\");        System.out.println(originator.getState());    }}class Originator{ // 原发器    private String state;    public void setState(String state){        this.state = state;    }    public String getState(){        return state;    }    public Memento createMemento(){        return new Memento(state);    }    public void setMemento(Memento memento){        state = memento.getState();    }}class Memento{ // 备忘录    private String state;    public Memento(String state){        this.state = state;    }    public String getState(){        return state;    }}class Caretaker{ // 管理者    private List&lt;Memento&gt; mementoList = new ArrayList&lt;&gt;();    public void addMemento(Memento memento){        mementoList.add(memento);    }    public Memento getMemento(int index){        return mementoList.get(index - 1);    }    public void showMemento(){        int i = 1;        for(Memento m : mementoList){            System.out.println(\"No.\" + i + \": \" + m.getState());            i++;        }    }}"
  },
  
  {
    "title": "2023 新服务器部署记录",
    "url": "/archives/131",
    "categories": "折腾记录",
    "tags": "Docker",
    "date": "2023-11-03 15:34:00 +0800",
    





    
    "snippet": "自从博客转移到 Github 上后本打算就这样不再购买新服务器的，不过可能是这几个月很平静使得我迫切想折腾一阵，也可能是 我可以不用，但不能没有 的心理使我冲动消费了一次目前的网站 (yexca.net 网域)  个人介绍？：http://yexca.net (目前还是半成品)  这个 Blog：http://blog.yexca.net  怀旧 Blog：http://wp.yexca.n...",
    "content": "自从博客转移到 Github 上后本打算就这样不再购买新服务器的，不过可能是这几个月很平静使得我迫切想折腾一阵，也可能是 我可以不用，但不能没有 的心理使我冲动消费了一次目前的网站 (yexca.net 网域)  个人介绍？：http://yexca.net (目前还是半成品)  这个 Blog：http://blog.yexca.net  怀旧 Blog：http://wp.yexca.net  VRChat Blog：http://vrc.yexca.net  VRChat Docs：http://vrchat.yexca.net  Navidrome：http://music.yexca.net (自用)  ACG：http://acg.yexca.net (要不是看 DNS 记录我都忘记了，暂时没想好做什么)  xlog(Web3)：http://xlog.yexca.netDocker自从接触了 Docker 以后，我几乎什么项目都会想着用 Docker 部署，毕竟是真好用啊系统为 Debian10，root 账号登录，首先更新apt update安装软件apt install curl gpg更新 gpgcurl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg添加 docker 源echo \\   \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\   buster stable\" | tee /etc/apt/sources.list.d/docker.list &gt; /dev/null安装 dockerapt updateapt install docker-ce docker-ce-cli containerd.io docker-compose启动 dockersystemctl enable dockersystemctl start docker测试是否成功docker run --rm hello-world  此部分参考：服务器用 Docker 部署记录公钥登录参考：SSH 公钥登录Nginx这次和之前一样也是用 nginx-ui 项目，docker 部署，配置文件version: '3.1' services:   nginx-ui:    restart: always    image: uozi/nginx-ui:latest    container_name: nginx_UI    volumes:      - /home/nginx_ui/nginx:/etc/nginx      - /home/nginx_ui/nginx-ui:/etc/nginx-ui      - /home/nginx_ui/www:/www    ports:      - 80:80      - 443:443如果是 DNS 处启用 HTTPS 的话就不用配置证书了，不然一直访问异常个人介绍事实上在我将上一个服务器的网站全部变成 docker 部署之前就有想法，当时我特意将 Blog 域名从 yexca.xyz 改为 blog.yexca.xyz 就是为了空出域名，没想到都到了下一个服务器我才开始做  域名 yexca.xyz 已不属于我我翻开之前准备的工程，创建时间是 2022.03.07，最后修改 2022.06.29，我这拖延症越来越严重了言归正传，事实上产生这个想法是看到了一些博主的个人介绍，例如 https://idealclover.top/、https://the.moe/ 当然还有很多，只是时间有点太长了，实在找不到 (而且有的还更新了，变得更酷了)有些会开源，只要填上自己信息就可以自动生成介绍网页 (时间太长找不到项目了)不过最终我还是选择模仿 http://lolicon.app 的网页，至于为啥我也忘了 (好像是我去年决定的)参考文章用 CSS 实现自定义滚动条样式如何给网站设置favicon.ico图标Navidrome冲动消费的一个主要原因还有想搞一个还行的音乐网站自用，之前有一个基于 Onedrive 的，但在大陆访问体验不好，又恰逢 115 出活动，所以有了这篇文章  体验后：什么玩意，还没 Onedrive 快，冲动是魔鬼，切不可冲动消费  唉，本来还想着要是效果好再部署一个 kikoeru-express 来着首先需要支持挂载 115 网盘的 Rclone项目地址：https://github.com/gaoyb7/rclone-release该项目使用与原 rclone 一致，只是加入了 115 支持获取 CookieChrome 抓取 Cookie登录 115 后进入控制台的 Network，刷新网页，找到 cookie.js?_=[number]在 Request Headers 可找到 CookieChrome 插件抓取 Cookie使用插件可以很方便的查看 Cookie安装地址：Get cookies.txt LOCALLYApp 的 Cookie网页版 Cookie 时效较短，建议抓取 App 请求获取 Cookie，iOS 系统可使用 Stream 或者 Quantumult X 抓包，安卓系统使用抓包精灵，电脑端选择很多，例如 Fiddler  这个 Cookie 随便抓一下就出来了，不写了配置 Rclone可以通过命令配置或编辑配置文件使用命令配置运行命令rclone.exe config根据需求选择即可，Windows 下完成后配置文件生成在：C:\\Users\\%USERNAME%\\AppData\\Roaming\\rclone编辑配置文件如上目录创建文件 rclone.conf 内容如下[name]type = 115uid = your_uidcid = your_cidseid = your_seidWindows 挂载测试Windows 挂载需先安装 winfsp (安装完成后重启一下).\\rclone.exe mount -v --read-only --vfs-read-chunk-size=4M --buffer-size=32M --network-mode 115: X:按 Ctrl+C 结束挂载Linux docker 挂载拉取镜像docker pull gaoyb7/rclone:latest挂载docker run --rm \\    --volume /home/rclone/config:/config/rclone \\    --volume /home/rclone/data:/data:shared \\    --volume /etc/passwd:/etc/passwd:ro --volume /etc/group:/etc/group:ro \\    --device /dev/fuse --cap-add SYS_ADMIN --security-opt apparmor:unconfined \\    gaoyb7/rclone:latest \\    mount 115:/music /data/music --allow-other --allow-non-empty --vfs-cache-mode writes &amp;# 上述命令仅最后一行为 Rclone 的命令，根据实际情况修改，格式如下rclone mount DriveName:Folder LocalFolder# DriveName\t\tRclone 挂载的名称# Folder\t\t云盘的路径# LocalFolder\t挂载到本地的文件Navidrome 配置version: \"3.0\"services:  navidrome:    image: deluan/navidrome:latest    ports:      - \"8005:4533\"    restart: unless-stopped    environment:      # Optional: put your config options customization here. Examples:      ND_SCANSCHEDULE: 1h      ND_LOGLEVEL: info        ND_SESSIONTIMEOUT: 24h      ND_BASEURL: \"\"      ND_LASTFM_ENABLED: \"true\"      ND_LASTFM_APIKEY: your_LASTFM_APIKEY      ND_LASTFM_SECRET: your_LASTFM_SECRET      ND_LASTFM_LANGUAGE: zh      ND_SPOTIFY_ID: your_SPOTIFY_ID      ND_SPOTIFY_SECRET: your_SPOTIFY_SECRET      ND_ENABLESHARING: \"true\"      ND_UILOGINBACKGROUNDURL: \"https://www.loliapi.com/acg\"      #随机图片接口      ND_UIWELCOMEMESSAGE: \"主界面会看到的话\"    volumes:      - \"/home/navidrome/data:/data\"      - \"/home/rclone/data/music:/music/115:ro\"      - \"/home/navidrome/music:/music/server:ro\"Blog两个 Blog，均参考之前文章部署，部署出来应该也不会更新了Wordpressyexca’Blog 之前用的图片 cdn 不能访问了，我尝试使用一些替换插件无果后懒得折腾了 (背景图片能看就行)TypechoVRChat 教程 我长时间不用忘了后台的密码，还好之前做了双重保险保留了备份文件，于是搭建一个新的，再导入数据。图片和上面那个一样，有时间换个 cdn 就好了 (目前只换了封面的)WarmaTap把初音未来的声音替换为 Warma 声音的很好玩的网页  偏电子音Github: lwd-temp/warmatap部署：http://yexca.net/warma_tap  偏人声Github: MonianHello/WarmaTap部署：http://yexca.net/warmatap  MikuTapGithub: HFIProgramming/mikutap部署：http://yexca.net/mikutap  MikuTap 是以 patatap 为灵感制作"
  },
  
  {
    "title": "网易云音乐 2020-2022 年度报告",
    "url": "/archives/130",
    "categories": "日常",
    "tags": "音乐",
    "date": "2023-10-29 23:45:00 +0800",
    





    
    "snippet": "网站手机访问即可查看 (只试过 IOS)2020:https://st.music.163.com/c/year20202021:https://st.music.163.com/c/year20212022:https://st.music.163.com/c/year2022过程Google 搜索 网易云年度报告，发现 https://st.music.163.com/c/reportr...",
    "content": "网站手机访问即可查看 (只试过 IOS)2020:https://st.music.163.com/c/year20202021:https://st.music.163.com/c/year20212022:https://st.music.163.com/c/year2022过程Google 搜索 网易云年度报告，发现 https://st.music.163.com/c/reportreview2020 (手机访问情况下会出现 2020 年度报告入口)，顺着网站试着修改年份，发现 2020-2022 可以查看"
  },
  
  {
    "title": "Linux 学习 Index",
    "url": "/archives/129",
    "categories": "Linux",
    "tags": "读书笔记",
    "date": "2023-10-21 14:18:00 +0800",
    





    
    "snippet": "此文章写于 2022.12，由于多种原因未发布该系列文章为我阅读《Linux 系统管理、服务器设置、安全、云数据中心》所书写相关笔记第一部分：入门这部分没有记录文章  第 01 章 开始使用 LinuxLinux 的历史。总结：Linux NB  第 02 章 创建完美的 Linux 桌面然后有了 Fedora 桌面折腾第二部分：成为一名 Linux 高级用户  第 03 章 使用 shel...",
    "content": "此文章写于 2022.12，由于多种原因未发布该系列文章为我阅读《Linux 系统管理、服务器设置、安全、云数据中心》所书写相关笔记第一部分：入门这部分没有记录文章  第 01 章 开始使用 LinuxLinux 的历史。总结：Linux NB  第 02 章 创建完美的 Linux 桌面然后有了 Fedora 桌面折腾第二部分：成为一名 Linux 高级用户  第 03 章 使用 shellshell 的一些用法与变量  第 04 章 在文件系统中移动文件相关 shell 命令、元字符、文件权限  第 05 章 使用文本文件vi 编辑器、查找文件 (locate 、find 、grep)  第 06 章 管理运行中的进程列出进程，杀死进程，限制进程  第 07 章 编写简单的 shell 脚本一些 shell 脚本的语法第三部分 称为一名 Linux 系统管理员  第 08 章 学习系统管理/etc 下配置文件  第 09 章 安装 Linux(なし)没有文章。图形化或命令行个人安装。企业中批量安装  第 10 章 获取和管理软件RPM 和 DEB 包，yum 、rpm 、dnf 、apt 命令  第 11 章 获取用户账户管理用户账户与组账户  第 12 章 管理磁盘和文件系统创建文件系统，LVM 逻辑卷，挂载文件系统  之后还有服务器管理员、Linux 安全技术、将 Linux 拓展到云。因各种原因，不进行笔记书写"
  },
  
  {
    "title": "中介者模式",
    "url": "/archives/128",
    "categories": "软件工程",
    "tags": "对象行为型模式, 设计模式",
    "date": "2023-10-15 17:14:00 +0800",
    





    
    "snippet": "Mediator Pattern 对象行为型模式意图用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间地交互结构其中：  Mediator (中介者) 定义一个接口用于各同事 (Colleague) 对象通信  ConcreteMediator (具体中介中介) 通过协调各同事对象实现协作行为；了解并维护它的各个同事  Co...",
    "content": "Mediator Pattern 对象行为型模式意图用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间地交互结构其中：  Mediator (中介者) 定义一个接口用于各同事 (Colleague) 对象通信  ConcreteMediator (具体中介中介) 通过协调各同事对象实现协作行为；了解并维护它的各个同事  Colleague class (同事类) 知道它的中介者对象；每一个同事类对象在需要与其他同事通信的时候与它的中介者通信适用性Mediator 模式适用于：  一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解  一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象  想定制一个分布在多个类中的行为，而又不想生成太多的子类例子 1在线支付是电子商务的一个重要环节，不同的电子商务平台提供了不同的支付接口。现在需要整合不同电子商务平台的支付接口，使得客户在不同平台上购物时，不需要关心具体的支付接口。拟采用中介者 (Mediator) 设计模式来实现该需求，类图如下所示interface WebServiceMediator {    public void buy(double money, WebService service);    public void SetAmazon(WebService amazon);    public void SetEbay(WebService ebay);}abstract class WebService {    protected WebServiceMediator mediator;    public abstract void SetMediator(WebServiceMediator mediator);    public abstract void buyService(double money);    public abstract void search(double money);}class ConcreteServiceMediator implements WebServiceMediator {    private WebService amazon;    private WebService ebay;        public ConcreteServiceMediator() {        amazon = null;        ebay = null;    }        public void SetAmazon(WebService amazon) {        this.amazon = amazon;    }        public void SetEbay(WebService ebay) {        this.ebay = ebay;    }        public void buy(double money, WebService service) {        if (service == amazon)            amazon.search(money);        else            ebay.search(money);    }}class Amazon extends WebService {    public void SetMediator(WebServiceMediator mediator) {        this.mediator = mediator;    }        public void buyService(double money) {        mediator.buy(money, this);    }        public void search(double money) {        System.out.println(\"Amazon receive：\" + money);    }}class Ebay extends WebService {    public void SetMediator(WebServiceMediator mediator) {        this.mediator = mediator;    }        public void buyService(double money) {        mediator.buy(money, this);    }        public void search(double money) {        System.out.println(\"Ebay receive：\" + money);    }}例子 2两个同事之间通信public class MediatorPattern {    public static void main(String[] args) {        ConcreteMediator m = new ConcreteMediator();        Colleague1 c1 = new Colleague1(m);        Colleague2 c2 = new Colleague2(m);        m.setC1(c1);        m.setC2(c2);        c1.sendMessage(\"hello\");        c2.sendMessage(\"hi\");    }}abstract class Colleague{    protected Mediator mediator;}class Colleague1 extends Colleague{    public Colleague1(Mediator mediator){        this.mediator = mediator;    }    public void sendMessage(String message){        mediator.sendMessage(message, this);    }    public void Notify(String message){        System.out.println(\"Colleague1 received: \" + message);    }}class Colleague2 extends Colleague{    public Colleague2(Mediator mediator){        this.mediator = mediator;    }    public void sendMessage(String message){        mediator.sendMessage(message, this);    }    public void Notify(String message){        System.out.println(\"Colleague2 received: \" + message);    }}abstract class Mediator{    public abstract void sendMessage(String message, Colleague c);}class ConcreteMediator extends Mediator{    // 因为此例对象很少，所以直接定义    private Colleague1 c1;    private Colleague2 c2;    // 如果同事很多    // List&lt;Colleague&gt; list = new ArrayList&lt;&gt;();    // public void Add(Colleague c){    //     list.add(c);    // }    public void setC1(Colleague1 c1){        this.c1 = c1;    }    public void setC2(Colleague2 c2){        this.c2 = c2;    }    @Override    public void sendMessage(String message, Colleague c){        if(c == c1){            // 让同事2收到消息            c2.Notify(message);        }else{            // 让同事1收到消息            c1.Notify(message);        }    }}"
  },
  
  {
    "title": "迭代器模式",
    "url": "/archives/127",
    "categories": "软件工程",
    "tags": "对象行为型模式, 设计模式",
    "date": "2023-10-12 09:09:00 +0800",
    





    
    "snippet": "Iterator Pattern 对象行为型模式意图提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示结构其中：  Iterator (迭代器) 定义访问和遍历元素的接口  ConcreteIterator (具体迭代器) 实现迭代器接口；对该聚合遍历时跟踪当前位置  Aggregate (聚合) 定义创建相应迭代器对象的接口  ConcreteAggregate (...",
    "content": "Iterator Pattern 对象行为型模式意图提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示结构其中：  Iterator (迭代器) 定义访问和遍历元素的接口  ConcreteIterator (具体迭代器) 实现迭代器接口；对该聚合遍历时跟踪当前位置  Aggregate (聚合) 定义创建相应迭代器对象的接口  ConcreteAggregate (具体聚合) 实现创建相应迭代器的接口，该操作返回 ConcreteIterator 的一个适当的实例适用性Iterator 模式适用于：  访问一个聚合对象的内容而无需暴露它的内部表示  支持对聚合对象的多种遍历  为遍历不同的聚合结构提供一个统一的接口利用 Java 已实现迭代器import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class IteratorPattern {    public static void main(String[] args) {        List&lt;Book&gt; bookList = new ArrayList&lt;&gt;();        String[] books = {\"Linear Algebra\", \"Algorithm\"};        double[] prices = {25.8, 29.8};        for(int i = 0; i &lt; 2; i++){            bookList.add(new Book(books[i], prices[i]));        }        // 访问元素 1        for(int i = 0; i &lt; bookList.size(); i++){            Book book = bookList.get(i);            System.out.println(\"name: \" + book.getName() + \" price: \" + book.getPrice());        }        // 访问元素 2        System.out.println(\"=====222=====\");        for(Book book : bookList){            System.out.println(\"name: \" + book.getName() + \" price: \" + book.getPrice());        }        // 访问元素 3 迭代器        System.out.println(\"=====333=====\");        Iterator iterator = bookList.iterator();        while (iterator.hasNext()){            Book book = (Book) iterator.next();            System.out.println(\"name: \" + book.getName() + \" price: \" + book.getPrice());        }    }}class Book{    private String name;    private double price;    public Book(String name, double price){        this.name = name;        this.price = price;    }    public double getPrice() {        return price;    }    public String getName() {        return name;    }}例子import javax.sound.midi.Soundbank;import java.util.ArrayList;import java.util.List;public class IteratorPattern {    public static void main(String[] args) {        BookAggregate bookAggregate = new BookAggregate();        String[] books = {\"Linear Algebra\", \"Algorithm\"};        double[] prices = {25.8, 29.8};        for(int i = 0; i &lt; 2; i++){            bookAggregate.Add(new Book(books[i], prices[i]));        }        Iterator iterator = bookAggregate.CreateIterator();        while(iterator.hasNext()){            Book book = (Book)iterator.next();            System.out.println(\"name: \" + book.getName() + \" price: \" + book.getPrice());        }    }}interface Iterator{    public boolean hasNext();    public Object next();}class BookIterator implements Iterator{    private int index;    private BookAggregate bookAggregate;    public BookIterator(BookAggregate bookAggregate){        this.index = 0;        this.bookAggregate = bookAggregate;    }    @Override    public boolean hasNext(){        if (index &lt; bookAggregate.getSize()) return true;        return false;    }    @Override    public Object next(){        Object obj = bookAggregate.get(index);        index++;        return obj;    }}interface Aggregate{    public Iterator CreateIterator();}class BookAggregate implements Aggregate{    private List&lt;Book&gt; list = new ArrayList&lt;&gt;();    public void Add(Book book){        list.add(book);    }    public Book get(int index){        return list.get(index);    }    public int getSize(){        return list.size();    }    @Override    public Iterator CreateIterator(){        return new BookIterator(this);    }}class Book{    private String name;    private double price;    public Book(String name, double price){        this.name = name;        this.price = price;    }    public double getPrice() {        return price;    }    public String getName() {        return name;    }}"
  },
  
  {
    "title": "解释器模式",
    "url": "/archives/126",
    "categories": "软件工程",
    "tags": "类行为型模式, 设计模式",
    "date": "2023-10-09 17:31:00 +0800",
    





    
    "snippet": "Interpreter Pattern 类行为型模式意图给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子结构其中：  AbstractExpression 声明一个程序的解释操作，这个接口为抽象语法树中所有的结点所共享  TerminalExpression 实现与文法中的终结符相关联的解释操作；一个句子中的每个终结符需要该类的一个实例  Non...",
    "content": "Interpreter Pattern 类行为型模式意图给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子结构其中：  AbstractExpression 声明一个程序的解释操作，这个接口为抽象语法树中所有的结点所共享  TerminalExpression 实现与文法中的终结符相关联的解释操作；一个句子中的每个终结符需要该类的一个实例  NonterminalExpression 对文法中的每一条规则都需要一个 NonterminalExpression 类；为每个符号都维护一个 AbstractExpression 类型的实例变量；为文法中的非终结符实现解释 (Interpret) 操作  Context 包含解释器之外的一些全局信息  Client 构建 (或被给定) 表示该文法定义的语言中一个特定的句子的抽象语法树，该抽象语法树由 NonterminalExpression 和 TerminalExpression 的实例装配而成；调用解释操作适用性Interpreter 模式适用于当有一个语言需要解释执行，并且可将该语言中的句子表示为一个抽象语法树时，以下情况效果最好：  该文法简单  效率不是一个关键问题例子检查字符串：某区的某人员 (someone of ? region)import java.util.*;public class InterpreterPattern {    public static void main(String[] args) {        Context context = new Context();        context.check(\"developer of A region\");    }}class Context{    private String[] regions = {\"A region\", \"B region\", \"C region\"};    private String[] persons = {\"developer\", \"tester\"};    private NonterminalExpression nte;    public Context(){         TerminalExpression region = new TerminalExpression(regions);         TerminalExpression person = new TerminalExpression(persons);         nte = new NonterminalExpression(region, person);    }    public void check(String info){        boolean bool = nte.Interpret(info);        if(bool){            System.out.println(\"right\");        }else {            System.out.println(\"wrong\");        }    }}interface Expression{    public boolean Interpret(String info);}class NonterminalExpression implements Expression{    TerminalExpression region;    TerminalExpression person;    public NonterminalExpression(TerminalExpression region, TerminalExpression person){        this.person = person;        this.region = region;    }    @Override    public boolean Interpret(String info){        String[] str = info.split(\" of \");        // \"developer of A region\" --&gt; str = {\"developer\", \"A region\"}        return region.Interpret(str[1]) &amp;&amp; person.Interpret(str[0]);    }}class TerminalExpression implements Expression{    private Set&lt;String&gt; set = new HashSet&lt;&gt;();    public TerminalExpression(String[] data){        for(String str : data){            set.add(str);        }    }    @Override    public boolean Interpret(String info){        return set.contains(info);    }}"
  },
  
  {
    "title": "命令模式",
    "url": "/archives/125",
    "categories": "软件工程",
    "tags": "对象行为型模式, 设计模式",
    "date": "2023-09-10 15:26:00 +0800",
    





    
    "snippet": "Command Pattern 对象行为型模式意图将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作结构其中：  Command 声明执行操作的接口  ConcreteCommand 将一个接收者对象绑定于一个动作；调用接收者相应的操作，以实现 Execute  Client 创建一个具体命令对象并设定它的接收者  Invoke...",
    "content": "Command Pattern 对象行为型模式意图将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作结构其中：  Command 声明执行操作的接口  ConcreteCommand 将一个接收者对象绑定于一个动作；调用接收者相应的操作，以实现 Execute  Client 创建一个具体命令对象并设定它的接收者  Invoker 要求该命令执行这个请求  Receiver 知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者适用性Command 模式适用于：  抽象出待执行的动作以参数化某对象  在不同的时刻指定、排列和执行请求  支持取消操作  支持修改日志  用构建在原语操作上的高层操作构造一个系统例子public class CommandPattern {    public static void main(String[] args) {        // 接收者 对象 电视机        Tv tv = new Tv();        // 命令对象        Command oncommand = new OnCommand(tv);        Command offcommand = new OffCommand(tv);        // 请求者        Invoker invoker = new Invoker();        // 开机        invoker.setCommand(oncommand);        invoker.Execute();        // 关机        invoker.setCommand(offcommand);        invoker.Execute();    }}class Invoker{ // 请求者    private Command command; // 命令    public void setCommand(Command command){ // 设置请求者 的 请求的命令        this.command = command;    }    public void Execute(){ // 执行命令        command.Execute();    }}interface Command{ // 命令接口    public void Execute(); // 执行命令}class OnCommand implements Command{ // 开机命令    private Tv tv;    public OnCommand(Tv tv){        this.tv = tv;    }    @Override    public void Execute(){        tv.OnAction();    }}class OffCommand implements Command{ // 关机命令    private Tv tv;    public OffCommand(Tv tv){        this.tv = tv;    }    @Override    public void Execute(){        tv.OffAction();    }}class Tv{ // 接收者 电视机    public void OnAction(){        System.out.println(\"Tv On\");    }    public void OffAction(){        System.out.println(\"Tv Off\");    }}"
  },
  
  {
    "title": "责任链模式",
    "url": "/archives/124",
    "categories": "软件工程",
    "tags": "对象行为型模式, 设计模式",
    "date": "2023-09-09 07:02:00 +0800",
    





    
    "snippet": "Chain of Responsibility Pattern 对象行为型模式意图使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止结构其中：  Handler 定义一个处理请求的接口；(可选) 实现后继链  ConcreteHandler 处理它所负责的请求；可访问它的后继者；如果可处理该请求，就处...",
    "content": "Chain of Responsibility Pattern 对象行为型模式意图使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止结构其中：  Handler 定义一个处理请求的接口；(可选) 实现后继链  ConcreteHandler 处理它所负责的请求；可访问它的后继者；如果可处理该请求，就处理它，否则将请求转发给后继者  Client 向链上的具体处理者 (ConcreteHandler) 对象提交请求适用性Chain of Responsibility 模式适用于：  有多个对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定  想在不明确指定接收者的情况下向多个对象中的一个提交一个请求  可处理一个请求的对象集合应被动态指定例子学生请假，先辅导员，辅导员处理不了转院长，院长处理不了转校长public class ChainOfResponsibilityPattern {    public static void main(String[] args) {        // 实例化对象        Handler counsellor = new Counsellor();        Handler president = new President();        Handler schoolmaster = new Schoolmaster();        // 设置对象下一级        counsellor.next = president;        president.next = schoolmaster;        schoolmaster.next = null;        // 向辅导员请求7天假期        counsellor.HandlerRequest(7);    }}abstract class Handler{    protected Handler next;    public void setNext(Handler next){        this.next = next;    }    // 学生请假请求    public abstract void HandlerRequest(int request);}class Counsellor extends Handler{    // 辅导员 小于等于7天审批    @Override    public void HandlerRequest(int request){        if (request &lt;= 7) {            System.out.println(\"Counsellor Agree!\");        }        else {            if(next != null){                next.HandlerRequest(request);            }            else {                System.out.println(\"Counsellor Refuse!\");            }        }    }}class President extends Handler{    // 院长 小于等于15天审批    @Override    public void HandlerRequest(int request){        if (request &lt;= 15) {            System.out.println(\"President Agree!\");        }        else {            if(next != null){                next.HandlerRequest(request);            }            else {                System.out.println(\"President Refuse!\");            }        }    }}class Schoolmaster extends Handler{    // 校长 小于等于30天审批    @Override    public void HandlerRequest(int request){        if (request &lt;= 30) {            System.out.println(\"Schoolmaster Agree!\");        }        else {            if(next != null){                next.HandlerRequest(request);            }            else {                System.out.println(\"Schoolmaster Refuse!\");            }        }    }}"
  },
  
  {
    "title": "代理模式",
    "url": "/archives/123",
    "categories": "软件工程",
    "tags": "对象结构型模式, 设计模式",
    "date": "2023-09-08 12:15:00 +0800",
    





    
    "snippet": "Proxy Pattern 对象结构型模式意图为其他对象提供一种代理以控制对这个对象的访问结构其中：  Proxy 保存一个引用使得代理可以访问实体；提供一个与 Subject 的接口相同的接口，使代理可以用来代替实体；控制对实体的存取，并可能负责创建和删除它  Subject 定义 RealSubject 和 Proxy 的共用接口，这样就在任何使用 RealSubject 的地方都可以使...",
    "content": "Proxy Pattern 对象结构型模式意图为其他对象提供一种代理以控制对这个对象的访问结构其中：  Proxy 保存一个引用使得代理可以访问实体；提供一个与 Subject 的接口相同的接口，使代理可以用来代替实体；控制对实体的存取，并可能负责创建和删除它  Subject 定义 RealSubject 和 Proxy 的共用接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy  RealSubject 定义 Proxy 所代表的实体适用性Proxy 模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候，常见的情况有：  远程代理 (Remote Proxy) 为一个对象在不同地址空间提供局部代表  虚代理 (Virtual Proxy) 根据需要对原始对象的访问，用于对象应该有不同的访问权限的时候  保护代理 (Protection Proxy) 控制对原始对象的访问，用于对象应该有不同的访问权限的时候  只能引用 (Smart Reference) 取代了简单的指针，它在访问对象时执行了一些附加操作。典型用途包括：对指向实际对象的引用计数，这样当该对象没有引用时，可以被自动释放；当第一次引用一个持久对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它例子中介代理买东西public class ProxyPattern {    public static void main(String[] args) {        RealSubject realSubject = new RealSubject();        Proxy proxy = new Proxy(realSubject);        proxy.buy();    }}interface Subject{    public void buy();}class Proxy implements Subject{    protected RealSubject realSubject;    public Proxy(RealSubject realSubject){        this.realSubject = realSubject;    }    @Override    public void buy() {        System.out.println(\"prepare\");        realSubject.buy();        System.out.println(\"complete\");    }}class RealSubject implements Subject{    @Override    public void buy() {        System.out.println(\"Money\");    }}"
  },
  
  {
    "title": "享元模式",
    "url": "/archives/122",
    "categories": "软件工程",
    "tags": "对象结构型模式, 设计模式",
    "date": "2023-09-07 13:54:00 +0800",
    





    
    "snippet": "Flyweight Pattern 对象结构型模式意图运用共享技术有效地支持大量细粒度的对象结构其中：      Flyweight 描述一个接口，通过这个接口 Flyweight 可以接受并作用于外部状态        ConcreteFlyweight 实现 Flyweight 接口，并为内部状态 (如果有) 增加存储空间。ConcreteFlyweight 对象必项是可共享的。它所存储...",
    "content": "Flyweight Pattern 对象结构型模式意图运用共享技术有效地支持大量细粒度的对象结构其中：      Flyweight 描述一个接口，通过这个接口 Flyweight 可以接受并作用于外部状态        ConcreteFlyweight 实现 Flyweight 接口，并为内部状态 (如果有) 增加存储空间。ConcreteFlyweight 对象必项是可共享的。它所存储的状态必须是内部的，即它必须独立于 ConcreteFlyweight 对象的场景        并非所有的 Flyweight 子类都需要被共享。Flyweight 接口使共享成为可能，但它并不强制共亨。在 Flyweight 对象结构的某些层次，UnsharedConcreteFlyweight 对象通常将 ConcreteFlyweight 对象作为子结点        FlyweightFactory 创建并管理 Flyweight 对象；确保合理地共享 Flyweight，当用户请求一个 Flyweight 时，FlyweightFactory 对象提供一个已创建的实例或者不存在时创建一个实例        Client 维持一个对 Flyweight 的引用；计算或存储一个或多个 Flyweight 的外部状态  适用性Flyweight 模式适用于：  一个应用程序使用了大量的对象  完全由于使用大量的对象，造成很大的存储开销  对象的大多数状态都可变为外部状态  如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象  应用程序不依赖于对象标识。由于 Flyweight 对象可以被共享，所以对于概念上明显有别的对象，标识测试将返回真值例子 1现要开发一个网络围棋程序，允许多个玩家联机下棋。由于只有一台服务器，为节省内存空间，采用享元模式实现该程序，类图如下import java.util.ArrayList;enum PieceColor {BLACK, WHITE} // 棋子颜色class PiecePods{ // 棋子位置    private int x;    private int y;    public PiecePods(int a, int b){        x = a;        y = b;    }    public int getX(){        return x;    }    public int getY() {        return y;    }}abstract class Piece{ // 棋子定义    protected PieceColor m_color; // 颜色    protected PiecePods m_pos; // 位置    public Piece(PieceColor color, PiecePods pos){        this.m_color = color;        this.m_pos = pos;    }    public abstract void draw();}class BlackPiece extends Piece{    public BlackPiece(PieceColor color, PiecePods pos){        super(color, pos);    }    @Override    public void draw(){        System.out.println(\"Draw a black piece\");    }}class WhitePiece extends Piece{    public WhitePiece(PieceColor color, PiecePods pos){        super(color, pos);    }    @Override    public void draw(){        System.out.println(\"Draw a white piece\");    }}class PieceBoard{ // 棋盘上已有的棋子    private static final ArrayList&lt;Piece&gt; m_arrayPiece = new ArrayList&lt;&gt;();    private String m_blackName; // 黑方名称    private String m_whiteName; // 白方名称    public PieceBoard(String black, String white){        m_blackName = black;        m_whiteName = white;    }    // 一步棋，在棋盘上放一颗棋子    public void setPiece(PieceColor color, PiecePods pos){        Piece piece = null;        if(color == PieceColor.BLACK){ // 放黑子            piece = new BlackPiece(color, pos);            System.out.println(m_blackName + pos.getX() + pos.getY());            piece.draw();        }else{ // 放白子            piece = new WhitePiece(color, pos);            System.out.println(m_whiteName + pos.getX() + pos.getY());            piece.draw();        }        m_arrayPiece.add(piece);    }}例子 2五子棋public class FlyWeightPattern {    public static void main(String[] args) {        PieceFactory factory = new PieceFactory();        Piece wp1 = factory.getPiece(0);        wp1.draw(2023, 0527);    }}class PieceFactory{    private Piece[] pieces = {new WhitePiece(), new BlackPiece()};    public Piece getPiece(int key){        if(key == 0) return pieces[0];        else return pieces[1];    }}abstract class Piece{    protected String color;    public abstract void draw(int x, int y);}class WhitePiece extends Piece{    public WhitePiece(){        this.color = \"white\";    }    @Override    public void draw(int x, int y){        System.out.println(\"draw a \" + this.color + \" piece x: \" + x + \" y: \" + y);    }}class BlackPiece extends Piece{    public BlackPiece(){        this.color = \"Black\";    }    @Override    public void draw(int x, int y){        System.out.println(\"draw a \" + this.color + \" piece x: \" + x + \" y: \" + y);    }}例子 3import java.util.HashMap;import java.util.Map;import java.util.Random;public class FlyWeightPattern {    public static void main(String[] args) {        ShapeFactory sf = new ShapeFactory();        Random r = new Random();        String[] colors = {\"red\", \"blue\", \"green\", \"white\", \"black\"};        for (int i = 0; i &lt; 10; i++) {            int x = r.nextInt(colors.length);            Shape s = sf.getShape(colors[x]);            s.draw(r.nextInt(2023), r.nextInt(527));        }    }}class ShapeFactory{    private Map&lt;String, Shape&gt; map = new HashMap&lt;&gt;();    public Shape getShape(String key){        if (!map.containsKey(key)) {            map.put(key, new Circle(key));            System.out.println(\"create new circle, color: \" + key);        }        return map.get(key);    }}abstract class Shape{    protected String color;    public abstract void draw(int x, int y);}class Circle extends Shape{    public Circle(String color){        this.color = color;    }    @Override    public void draw(int x, int y) {        System.out.println(\"draw a \" + this.color + \" circle x: \" + x + \" y: \" + y);    }}"
  },
  
  {
    "title": "外观模式",
    "url": "/archives/121",
    "categories": "软件工程",
    "tags": "对象结构型模式, 设计模式",
    "date": "2023-09-06 03:02:00 +0800",
    





    
    "snippet": "Facade Pattern 对象结构型模式意图为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用结构其中：  Facade 知道哪些子系统类负责处理请求；将客户的请求代理给适当的子系统对象  Subsystem classes 实现子系统的功能；处理有 Facade 对象指派的任务；没有 Facade 的任何相关信息，即没有指向...",
    "content": "Facade Pattern 对象结构型模式意图为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用结构其中：  Facade 知道哪些子系统类负责处理请求；将客户的请求代理给适当的子系统对象  Subsystem classes 实现子系统的功能；处理有 Facade 对象指派的任务；没有 Facade 的任何相关信息，即没有指向 Facade 的指针适用性Facade 模式适用于：  要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制，但也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的默认视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过 Facade 层  客户程序与抽象类的实现部分之间存在着很大的依赖性。引入 Facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性  当需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，则可以让它们仅通过 Facade 进行通信，从而简化了它们之间的依赖关系例子 1以医院为例，就医时患者需要与医院不同的职能部门交互，完成挂号、门诊、取药等操作。为简化就医流程，可以设置一个接待员的职位，代患者完成上述就医步骤，患者只需要与接待员交互即可Java 代码import java.util.*;interface Patient {    public String getName();}interface Disposer {    public void dispose(Patient patient);}class Registry implements Disposer { // 挂号    public void dispose(Patient patient) {        System.out.println(\"I am registering...\" + patient.getName());    }}class Doctor implements Disposer { // 医生门诊    public void dispose(Patient patient) {        System.out.println(\"I am diagnosing...\" + patient.getName());    }}class Pharmacy implements Disposer { // 取药    public void dispose(Patient patient) {        System.out.println(\"I am medicine... \" + patient.getName());    }}class Facade {    private Patient patient;    public Facade(Patient patient) {        this.patient = patient;    }    void dispose() {        Registry registry = new Registry();        Doctor doctor = new Doctor();        Pharmacy pharmacy = new Pharmacy();        registry.dispose(patient);        doctor.dispose(patient);        pharmacy.dispose(patient);    }}class ConcretePatient implements Patient {    private String name;    public ConcretePatient(String name) {        this.name = name;    }    public String getName() {        return name;    }}public class FacadeTest {    public static void main(String[] args) {        Patient patient = new ConcretePatient(\"zst\");        Facade f = new Facade(patient);                f.dispose();    }}C++ 代码#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Patient {public:    virtual string getName() = 0;};class Disposer {public:    virtual void dispose(Patient *patient) = 0;};class Registry : public Disposer { // 挂号public:    void dispose(Patient *patient) {        cout &lt;&lt; \"I am registering....\" &lt;&lt; patient-&gt;getName() &lt;&lt; endl;    }};class Doctor : public Disposer { // 医生门诊public:    void dispose(Patient *patient) {        cout &lt;&lt; \"I am diagnosing....\" &lt;&lt; patient-&gt;getName() &lt;&lt; endl;    }};class Pharmacy : public Disposer { // 取药public:    void dispose(Patient *patient) {        cout &lt;&lt; \"I am giving medicine....\" &lt;&lt; patient-&gt;getName() &lt;&lt; endl;    }};class Facade {private:    Patient *patient;public:    Facade(Patient *patient) { this-&gt;patient = patient; }    void dispose() {        Registry *registry = new Registry();        Doctor *doctor = new Doctor();        Pharmacy *pharmacy = new Pharmacy();        registry-&gt;dispose(patient);        doctor-&gt;dispose(patient);        pharmacy-&gt;dispose(patient);    }};class ConcretePatient : public Patient {private:    string name;public:    ConcretePatient(string name) { this-&gt;name = name; }    string getName() { return name; }};int main() {    Patient *patient = new ConcretePatient(\"zst\");    Facade *f = new Facade(patient);    f-&gt;dispose();    return 0;}例子 2public class FacadePattern {    public static void main(String[] args) {        Facade f = new Facade();        f.methodA();    }}class Facade{    SubSystemOne s1;    SubSystemTwo s2;    SubSystemThree s3;    public Facade(){        s1 = new SubSystemOne();        s2 = new SubSystemTwo();        s3 = new SubSystemThree();    }    public void methodA(){        s1.Operation();    }    public void methodB(){        s2.Operation();    }    public void methodC(){        s3.Operation();    }}class SubSystemOne{    public void Operation(){        System.out.println(\"SubSystemOne\");    }}class SubSystemTwo{    public void Operation(){        System.out.println(\"SubSystemTwo\");    }}class SubSystemThree{    public void Operation(){        System.out.println(\"SubSystemThree\");    }}"
  },
  
  {
    "title": "装饰器模式",
    "url": "/archives/120",
    "categories": "软件工程",
    "tags": "对象结构型模式, 设计模式",
    "date": "2023-09-05 21:45:00 +0800",
    





    
    "snippet": "Decorator Pattern 对象结构型模式意图动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator 模式比生成子类更加灵活结构其中：  Component 定义一个对象接口，可以给这些对象动态地添加职责  ConcreteComponent 定义一个对象，可以给这个对象添加一些职责  Decorator 维持一个指向 Component 对象的指针，并定义一个与 C...",
    "content": "Decorator Pattern 对象结构型模式意图动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator 模式比生成子类更加灵活结构其中：  Component 定义一个对象接口，可以给这些对象动态地添加职责  ConcreteComponent 定义一个对象，可以给这个对象添加一些职责  Decorator 维持一个指向 Component 对象的指针，并定义一个与 Component 接口一致的接口  ConcreteDecorator 向组件添加职责适用性Decorator 模式适用于：  在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责  处理那些可以撤销的职责  当不能采用生成子类的方式进行扩充时，一种情况是，可能有大量独立的拓展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏，或类定义不能用于生成子类例子 1某咖啡店当卖咖啡时，可以根据顾客的要求在其中加入各种配料，咖啡店会根据所加入的配料来计算费用。咖啡店所供应的咖啡及配料的种类和价格如下表所示现采用装饰器模式来实现计算费用的功能，得到如下类图import java.util.*;    abstract class Beverage { // 饮料    String description = \"Unknown Beverage\";    public String getDescription() { return description; }    public abstract int cost();}abstract class CondimentDecorator extends Beverage { // 配料    Beverage beverage;}class Espresso extends Beverage { // 蒸馏咖啡    private final int ESPRESSO_PRICE = 25;    public Espresso() { description = \"Espresso\"; }    public int cost() { return ESPRESSO_PRICE; }}class DarkRoast extends Beverage { // 深度烘焙咖啡    private final int DARKROAST_PRICE = 20;    public DarkRoast() { description = \"DarkRoast\"; }    public int cost() { rcturn DARKROAST PRICE; }}class Mocha extends CondimentDecorator { // 摩卡    private final int MOCHA_PRICE = 10;    public Mocha (Beverage beverage) { this.beverage = beverage; }    public String getDescription() {        return beverage.getDescription() + \", Mocha\";    }    public int cost() { return MOCHA_PRICE + beverage.cost(); }}class Whip extends CondimentDecorator { // 奶泡    private final int WHIP_PRICE = 8;    public Whip (Beverage beverage) { this.beverage = beverage; }    public String getDescription() {        return beverage.getDescription() + \", Whip\";    }    public int cost() { return WHIP_PRICE + beverage.cost(); }}public class Coffee {    public static void main(String args[]) {        Beverage beverage = new DarkRoast();        beverage = new Mocha(beverage);        beverage = new Whip(beverage);        System.out.println(beverage.getDescription() +\" ￥\"+ beverage.cost());    }}例子 2public class DecoratorPattern {    public static void main(String[] args) {        Person p = new Student(\"Mike\");        p.Operation();        System.out.println(\"\\n--------------------\");        p = new DecoratorA(p);        p.Operation();        System.out.println(\"\\n--------------------\");        p = new DecoratorB(p);        p.Operation();        // No.2        Person p2 = new DecoratorB(new Student(\"Jane\"));    }}abstract class Person{    protected String name;    public abstract void Operation();}class Student extends Person{    public Student(String name){        this.name = name;    }    @Override    public void Operation(){        System.out.print(name + \" Study\");    }}abstract class Decorator extends Person{    protected Person person;}class DecoratorA extends Decorator{    public DecoratorA(Person person){        this.person = person;    }    @Override    public void Operation() {        person.Operation();        System.out.print(\" Play\");    }}class DecoratorB extends Decorator{    public DecoratorB(Person person){        this.person = person;    }    @Override    public void Operation() {        person.Operation();        System.out.print(\" Exam\");    }}"
  },
  
  {
    "title": "组合模式",
    "url": "/archives/119",
    "categories": "软件工程",
    "tags": "对象结构型模式, 设计模式",
    "date": "2023-09-03 15:44:00 +0800",
    





    
    "snippet": "Composite Pattern 对象结构型模式意图将对象组合成树型结构以表示 “部分 - 整体” 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性结构其中：  Component 为组合中的对象声明接口；在适当情况下实现所有类共有接口的默认行为；声明一个接口用于访问和管理 Component 的子组件；(可选) 在递归结构中定义一个接口，用于访问一个父组件，并...",
    "content": "Composite Pattern 对象结构型模式意图将对象组合成树型结构以表示 “部分 - 整体” 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性结构其中：  Component 为组合中的对象声明接口；在适当情况下实现所有类共有接口的默认行为；声明一个接口用于访问和管理 Component 的子组件；(可选) 在递归结构中定义一个接口，用于访问一个父组件，并在合适的情况下实现它  Leaf 在组合中表示叶结点对象，叶结点没有子结点；在组合中定义图元对象的行为  Composite 定义所有子组件的那些组件的行为；存储子组件；在 Component 接口中实现与子组件有关的操作  Client 通过 Component 接口操纵组合组件的对象适用性Composite 模式适用于：  想表示对象的部分 - 整体层次结构  希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象例子 1某公司的组织结构图如下图所示现采用组合（Composition）设计模式来构造该公司的组织结构，得到如下图所示的类图其中Company为抽象类，定义了在组织结构图上添加（Add）和删除（Delete）分公司/办事处或者部门的方法接口。类ConcreteCompany表示具体的分公司或者办事处，分公司或办事处下可以设置不同的部门。类HRDepartment和FinanceDepartment分别表示人力资源部和财务部import java.util.*;abstract class Company {    protected String name;    public Company(String name) {   this.name   = name; }    public abstract void Add(Company c); // 增加子公司、办尊处或部门    public abstract void Delete(Company c); // 删除子公司、办事处或部门}class ConcreteCompany extends Company {    private List&lt;Company&gt; children = new ArrayList&lt;Company&gt;();    // 存储子公司、办事处或部门    public ConcreteCompany(String name) { super(name); }    public void Add(Company c) {children.add(c); }    public void Delete(Company c) {children.remove(c); }}class HRDepartment extends Company {    public HRDepartment(String name) { super(name); }// 其他代码省略}class FinanceDepartment extends Company {    public FinanceDepartment(String name) { super(name); }// 其他代码省略}public class Test {    public static void main(String[] args) {        ConcreteCompany root = new ConcreteCompany(\"北京总公司\");        root.Add(new HRDepartment(\"总公司人力资源部\"));        root.Add(new FinanceDepartment(\"总公司财务部\"));        ConcreteCompany comp = new ConcreteCompany(\"上海分公司\");        comp.Add(new HRDepartment(\"上海分公司人力资源部\"));        comp.Add(new FinanceDepartment(\"上海分公司财务部\"));        root.Add(comp);        ConcreteCompany comp1 = new ConcreteCompany(\"南京办事处\");        comp1.Add(new HRDepartment(\"南京办事处人力资源部\"));        comp1.Add(new FinanceDepartment(\"南京办事处财务部\"));        comp.Add(comp1); // 其他代码省略    }}例子 2层叠菜单是窗口风格的软件系统中经常采用的一种系统功能组织方式。层叠菜单中包含的可能是一个菜单项（直接对应某个功能），也可能是一个子菜单，现在采用组合（composite）设计模式实现层叠菜单，得到如下图所示的类图import java.util.*;abstract class MenuComponent {  // 构成层叠菜单的元素    protected String name;      // 菜单项或子菜单名称    public void printName() { System.out.println(name); }    public abstract boolean addMenuElement(MenuComponent element) ;    public abstract boolean removeMenuElement(MenuComponent element);    public abstract List&lt;MenuComponent&gt; getElement();}class MenuItem extends MenuComponent {    public MenuItem(String name) { this.name=name; }    public boolean addMenuElement(MenuComponent element) { return false; }    public boolean removeMenuElement(MenuComponent element) {        return false;    }    public List&lt;MenuComponent&gt; getElement(){ return null; }}class Menu extends MemuComponent {    private   List&lt;MenuComponent&gt; elementsList;    public Menu(String name) {        this.name = name;        this.elementList = new ArrayList&lt;MenuComponent&gt;;    }    public boolean addMenuElement(MenuComponent element) {        return elementList.add(element);    }    public boolean removeMenuElement(MenuComponent element) {        return elementList.remove(element);    }    public List&lt;MenuComponent&gt; getElement() { return elementList; }}class CompositeTest {    public static void main(String[] args) {        MenuComponent mainMenu = new Menu(\"Insert\");        MenuComponent subMenu = new Menu(\"Chart\");        MenuComponent element = new MenuItem(\"On This Sheet\");        mainMenu.addMenuElement(subMenu);        subMenu.addMenuElement(element);        printMenus(mainMenu);    }    private static void printMenus(MenuComponent ifile) {        ifile.printName();        List&lt;MenuComponent&gt; children = ifile.getElement();        if (children == null) return;        for(MenuComponent element; children) {            printMenus(element);        }    }}例子 3import java.util.*;public class CompositePattern {    public static void main(String[] args) {        AbstractFile root = new Folder(\"root\");        AbstractFile bin = new Folder(\"bin\");        AbstractFile tmp = new Folder(\"tmp\");        AbstractFile file = new File(\"file\");        root.Add(bin);        bin.Add(tmp);        root.Add(file);        // root.Remove(tmp);        print(root);    }    static void print(AbstractFile file){        List&lt;AbstractFile&gt; lf = file.GetChildren();        file.Operation();        // 更简洁的方法        // if(lf == null) return;        // for(AbstractFile i : lf) print(i);        if (lf != null) {            for (AbstractFile i : lf) {                if (i != null) {                    print(i);                }                else                    return;            }        }        else            return;    }}abstract class AbstractFile{    protected String name;    public void Operation(){        System.out.println(name);    }    public abstract boolean Add(AbstractFile af);    public abstract boolean Remove(AbstractFile af);    public abstract List&lt;AbstractFile&gt; GetChildren();}class Folder extends AbstractFile{    private List&lt;AbstractFile&gt; childrenList = new ArrayList&lt;&gt;();    public Folder(String name){        this.name = name;    }    @Override    public boolean Add(AbstractFile af){        return childrenList.add(af);    }    @Override    public boolean Remove(AbstractFile af){        return childrenList.remove(af);    }    @Override    public List&lt;AbstractFile&gt; GetChildren(){        return this.childrenList;    }}class File extends AbstractFile{    public File(String name){        this.name = name;    }    @Override    public boolean Add(AbstractFile af){        System.out.println(\"Forbidden\");        return false;    }    @Override    public boolean Remove(AbstractFile af){        System.out.println(\"Forbidden\");        return false;    }    @Override    public List&lt;AbstractFile&gt; GetChildren(){        return null;    }}"
  },
  
  {
    "title": "桥接模式",
    "url": "/archives/118",
    "categories": "软件工程",
    "tags": "对象结构型模式, 设计模式",
    "date": "2023-09-02 17:34:00 +0800",
    





    
    "snippet": "Bridge Pattern 对象结构型模式意图将抽象部分与其实现部分分离，使它们都可以独立地变化结构其中：  Abstraction 定义抽象类的接口，维护一个指向 Implementor 类型对象的指针  RefinedAbstraction 扩充由 Abstraction 定义的接口  Implementor 定义实现类的接口，该接口不一定要与 Abstraction 的接口完全一致；...",
    "content": "Bridge Pattern 对象结构型模式意图将抽象部分与其实现部分分离，使它们都可以独立地变化结构其中：  Abstraction 定义抽象类的接口，维护一个指向 Implementor 类型对象的指针  RefinedAbstraction 扩充由 Abstraction 定义的接口  Implementor 定义实现类的接口，该接口不一定要与 Abstraction 的接口完全一致；事实上这两个接口可以完全不同一般来说，Implementor 接口仅提供基本操作，而 Abstraction 定义了基于这些基本操作的较高层次的操作  ConcreteImplementor 实现 Implementor 接口并定义它的具体实现适用性Bridge 模式适用于：  不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换  类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这是 Bridge 模式使得开发者可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充  对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译  (C++) 想对客户完全隐藏抽象的实现部分  有许多类要生成的类层次结构  想在多个对象间共享实现 (可能使用引用计数) ，但同时要求客户并不知道这一点例子public class main {    public static void main(String[] args) {        Product ProductA1 = new ProductA();        Product ProductA2 = new ProductA();        Color red = new Red();        ProductA1.setName(\"P-A1\");        ProductA1.setColor(red);        ProductA1.Operation;        Color blue = new Blue();        ProductA1.setName(\"P-A2\");        ProductA1.setColor(blue);        ProductA1.Operation;    }}abstract class Product{    private String name;    protected Color color;    public void setName(String name){        this.name = name;    }    public String getName(){        return this.name;    }    public setColor(Color color){        this.color = color;    }    public abstract void Operation();} class ProductA extends Product{    @Override    public void Operation(){        color.OperationImp(this.getName());    }}class Color{    public void OperationImp(String name);}class Red extends Color{    @Override    public void OperationImp(String name){        System.out.println(name + \": red\")    }}class Blue extends Color{    @Override    public void OperationImp(String name){        System.out.println(name + \": blue\")    }}"
  },
  
  {
    "title": "适配器模式",
    "url": "/archives/117",
    "categories": "软件工程",
    "tags": "类结构型模式, 对象结构型模式, 设计模式",
    "date": "2023-09-01 15:03:00 +0800",
    





    
    "snippet": "Adapter Pattern 类结构型模式/对象结构型模式意图将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作结构  类适配器使用多重继承对一个接口与另一个接口进行匹配  对象适配器依赖于对象组合其中：  Target 定义 Client 使用的与特定领域相关的接口  Client 与符合 Target 接口的对象协同...",
    "content": "Adapter Pattern 类结构型模式/对象结构型模式意图将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作结构  类适配器使用多重继承对一个接口与另一个接口进行匹配  对象适配器依赖于对象组合其中：  Target 定义 Client 使用的与特定领域相关的接口  Client 与符合 Target 接口的对象协同  Adaptee 定义一个已经存在的接口，这个接口需要适配  Adapter 对 Adaptee 的接口与 Target 接口进行适配适用性Adapter 模式适用于：  想使用一个已经存在的类，而它的接口不符合要求  想创建一个可以服用的类，该类可以与其他不相关的类或不可预见的类 (即那些接口可能不一定兼容的类) 协同工作  (仅适用于对象 Adapter) 想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口例子 1某软件系统中，已设计并实现了用于显示地址信息的类 Address ，现要求提供基于 Dutch 语言的地址信息显示接口。为了实现该要求并考虑到以后可能还会出现新的语言接口，决定采用适配器模式实现该要求，类图如下public class Adapter {    public static void main(String[] args) {        Address address = new Address();        DutchAddress dutchAddress = new DutchAddressAdapter(address);        System.out.println(\"The DutchAddress\");        test(dutchAddress);    }        static void test(DutchAddress dutchAddress){        dutchAddress.plaats();        dutchAddress.postcode();        dutchAddress.straat();    }}class Address{    public void street(){/* code omission */}    public void zip(){/* code omission */}    public void city(){/* code omission */}}class DutchAddress{    public void straat(){/* code omission */}    public void postcode(){/* code omission */}    public void plaats(){/* code omission */}}class DutchAddressAdapter extends DutchAddress{    private Address address;    public DutchAddressAdapter(Address address){        this.address=address;    }    @Override    public void straat() {        address.street();    }    @Override    public void postcode() {        address.zip();    }    @Override    public void plaats() {        address.city();    }}例子 2// 因 Java 不支持多重继承，以下为对象适配器public class main{     public static void main(String[] args) {        Target target = new Adapter();        target.Request();    }}class Target{    public void Request(){        System.out.println(\"hello\");    }}class Adapter extends Target{    private Adaptee a = new Adaptee();    @Override    public void Request(){        a.SpecificRequest();    }}class Adaptee{    public void SpecificRequest(){        System.out.println(\"hi\");    }}"
  },
  
  {
    "title": "使用 CNAME 将域名重定向到带路径的 URL",
    "url": "/archives/116",
    "categories": "技术工具",
    "tags": "",
    "date": "2023-08-28 15:31:00 +0800",
    





    
    "snippet": "之前拥有服务器的时候虽然有过此想法，但毕竟只要服务器再开个站点就解决了并没有深入研究，如今服务器到期将 Blog 搬到 Github 上想要继续这样无疑是不可能的，于是便寻求解决方法失败的历程虽然失败了，但还是要记录下来，肯定是我不会用之前只是试着玩玩，仅从 DNS 的 CNAME 试了发现不行便放弃了，这次使用互联网搜索”域名定向到路径 url”，从第一条搜索结果 https://clou...",
    "content": "之前拥有服务器的时候虽然有过此想法，但毕竟只要服务器再开个站点就解决了并没有深入研究，如今服务器到期将 Blog 搬到 Github 上想要继续这样无疑是不可能的，于是便寻求解决方法失败的历程虽然失败了，但还是要记录下来，肯定是我不会用之前只是试着玩玩，仅从 DNS 的 CNAME 试了发现不行便放弃了，这次使用互联网搜索”域名定向到路径 url”，从第一条搜索结果 https://cloud.tencent.com/developer/ask/sof/89340 得知工具网站：http://redirect.center/例子从 https://acg.yexca.net 重定向到 https://blog.yexca.net/acg按网站描述，CNAME 内容应该为 blog.yexca.net.opts-slash.acg.opts-https.redirect.center. 可实际效果并未达到，并且报错尝试了挺多都是报错，不试了，另寻他法  注：网站最后一个介绍有自动生成新工具使用互联网搜索 “redirect center” 第三条搜索结果 https://redirect.name/这个工具比那个好用很多，而且有效例子从 https://acg.yexca.net 重定向到 https://blog.yexca.net/acg两条记录            类型      名称      内容                  CNAME      acg      alias.redirect.name              TXT      _redirect.acg      Redirects to https://blog.yexca.net/acg      代码形式acg            IN  CNAME  alias.redirect.name_redirect.acg  IN  TXT    \"https://blog.yexca.net/acg\"参考资料文章已列出"
  },
  
  {
    "title": "单例模式",
    "url": "/archives/115",
    "categories": "软件工程",
    "tags": "对象创建型模式, 设计模式",
    "date": "2023-07-05 13:58:00 +0800",
    





    
    "snippet": "Singleton Pattern 对象创建型模式意图保证一个类仅有一个实例，并提供一个访问它的全局访问点结构其中：  Singleton 指定一个 Instance 操作，允许客户访问它的唯一实例  Instance 是一个类操作；可能负责创建它自己的唯一实例适用性Singleton 模式适用于：  当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时  当这个唯一实例应该是通过子...",
    "content": "Singleton Pattern 对象创建型模式意图保证一个类仅有一个实例，并提供一个访问它的全局访问点结构其中：  Singleton 指定一个 Instance 操作，允许客户访问它的唯一实例  Instance 是一个类操作；可能负责创建它自己的唯一实例适用性Singleton 模式适用于：  当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时  当这个唯一实例应该是通过子类化可扩展的，并且客户无须更改代码就能使用一个扩展的实例时例子public class main{    // s1 和 s2 是同一个实例 (地址相同)    Singleton s1 = Singleton.getInstance();    Singleton s2 = Singleton.getInstance();}class Singleton{    private int num = 2023;    public void setNum(int num){        this.num = num;    }    public int getNum(){        return this.num;    }    private Singleton(){}    private static Singleton instance = new Singleton();    public static Singleton getInstance(){        return instance;    }}"
  },
  
  {
    "title": "アイドルマスター ミリオンライブ！的 IP 规则",
    "url": "/archives/114",
    "categories": "日常",
    "tags": "Game",
    "date": "2023-06-09 23:32:09 +0800",
    





    
    "snippet": "最近游玩 ミリシタ 时连接不上，遂寻找解决方法 （顺便试试 Spotify 的嵌入效果域名theaterdays.appspot.com最近雨宿りの曲が大好きので、よく聞いていた。Last.fm で過去30日間雨宿りの「猫かぶり」は人気トラック一番になった。で、トップアーティストじゃない？トップアーティスト、もちろん湊あくあ！　　草、ミリシタの文章で何を書いたか、どっちもミリシタと関係ないも...",
    "content": "最近游玩 ミリシタ 时连接不上，遂寻找解决方法 （顺便试试 Spotify 的嵌入效果域名theaterdays.appspot.com最近雨宿りの曲が大好きので、よく聞いていた。Last.fm で過去30日間雨宿りの「猫かぶり」は人気トラック一番になった。で、トップアーティストじゃない？トップアーティスト、もちろん湊あくあ！　　草、ミリシタの文章で何を書いたか、どっちもミリシタと関係ないもん！clash通过设置组更好选择首先设置 JP 组proxy-groups:- name: JP  type: select  proxies:  - your jp proxy name  - your jp proxy name然后添加规则rules:- DOMAIN-SUFFIX,theaterdays.appspot.com,JP"
  },
  
  {
    "title": "原型模式",
    "url": "/archives/113",
    "categories": "软件工程",
    "tags": "对象创建型模式, 设计模式",
    "date": "2023-06-02 19:31:44 +0800",
    





    
    "snippet": "Prototype Pattern 对象创建型模式意图用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象结构其中：  Prototype 声明一个复制自身的接口  ConcretePrototype 实现一个复制自身的操作  Client 让一个原型复制自身从而创建一个新的对象适用性Prototype 模式适用于：  当一个系统应该独立于它的产品创建、构成和表示时  当要实例化的...",
    "content": "Prototype Pattern 对象创建型模式意图用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象结构其中：  Prototype 声明一个复制自身的接口  ConcretePrototype 实现一个复制自身的操作  Client 让一个原型复制自身从而创建一个新的对象适用性Prototype 模式适用于：  当一个系统应该独立于它的产品创建、构成和表示时  当要实例化的类是在运行时刻指定时，例如，通过动态装载  为了避免创建一个与产品类层次平行的工厂类层次时  当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些例子 1public class main{    Product p1 = new Product(2023, 3.03);    System.out.println(p1.getId() + \" \" + p1.getPrice());    // Product p2 = new Product(2023, 3.03);    Product p2 = (Product) p1.Clone();    System.out.println(p2.getId() + \" \" + p2.getPrice());}interface Prototype{    public Object Clone();}class Product implements Prototype{    private int id;    private double price;    public Product(){}    public Product(int id, double price){        this.id = id;        this.price = price;    }    public int getId(){        return this.id;    }    public double getPrice(){        return this.price;    }    public void setId(int id){        this.id = id;    }    public void setPrice(double price){        this.price = price;    }    @Override    public Object Clone(){        Product object = new Product();        object.id = this.id;        object.price = this.price;        return object;    }}例子 2 (使用官方接口)public class main{    Product p1 = new Product(2023, 3.03);    System.out.println(p1.getId() + \" \" + p1.getPrice());    // Product p2 = new Product(2023, 3.03);    Product p2 = (Product) p1.clone();    System.out.println(p2.getId() + \" \" + p2.getPrice());}// 去除// interface Prototype{//     public Object Clone();// }// 实现接口class Product implements Cloneable{    private int id;    private double price;    public Product(){}    public Product(int id, double price){        this.id = id;        this.price = price;    }    public int getId(){        return this.id;    }    public double getPrice(){        return this.price;    }    public void setId(int id){        this.id = id;    }    public void setPrice(double price){        this.price = price;    }    \t// 重写方法    @Override    public Object clone(){        return super.clone();    }}"
  },
  
  {
    "title": "生成器模式",
    "url": "/archives/112",
    "categories": "软件工程",
    "tags": "对象创建型模式, 设计模式",
    "date": "2023-06-01 23:33:17 +0800",
    





    
    "snippet": "Builder Pattern 对象创建型模式意图将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示结构其中：  Builder 为创建一个 Product 对象的各个部件指定抽象接口  ConcreteBuilder 实现 Builder 的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供一个检索产品的接口  Director 构造一个使用 Build...",
    "content": "Builder Pattern 对象创建型模式意图将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示结构其中：  Builder 为创建一个 Product 对象的各个部件指定抽象接口  ConcreteBuilder 实现 Builder 的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供一个检索产品的接口  Director 构造一个使用 Builder 接口的对象  Product 表示被构建的复杂对象。ConcreteBuilder 创建该产品的内部表示并定义它的装配过程。包含定义组成组件的类，包括将这些组件装配成最终产品的接口适用性Builder 模式适用于：  当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式  当构建过程必须允许被构造的对象有不同的表示时例子 1某快餐厅主要制作并出售儿童套餐，一般包括主餐（各类比萨）、饮料和玩具，其餐品种类可能不同，但其制作过程相同。前台服务员（Waiter）调度厨师制作套餐。现采用生成器模式实现制作过程。类图如下Javaclass Pizza {    private String parts;    public void setParts(String parts) { this.parts = parts; }    public String toString() { return this.parts; }}abstract class PizzaBuilder {    protected Pizza pizza;    public Pizza getPizza() { return pizza; }    public void createNewPizza() { pizza = new Pizza(); }    public abstract void buildParts();}class HawaiianPizzaBuilder extends PizzaBuilder {    public void buildParts(){        pizza.setParts(\"cross + mild + ham&amp;pineapp1e\");    }}class SpicyPizzaBuilder extends PizzaBuilder {    public void buildParts() {        pizza.setParts(\"panbaked + hot + pepperoni&amp;salami\");    }}class Waiter {    private PizzaBuilder pizzaBuilder;    public void setPizzaBuilder(PizzaBuilder pizzaBuilder) {/*设置构建器*/        this.pizzaBuilder = pizzaBuilder;    }    public Pizza getPizza() { return pizzaBuilder.getPizza(); }    public void construct() { /* 构建 */        pizzaBuilder.createNewPizza();        pizzaBuilder.buildParts();    }}class FastFoodOrdering {    public static void main(String[] args) {        Waiter waiter = new Waiter();        PizzaBuilder hawaiian_pizzabuilder = new HawaiianPizzaBuilder();        waiter.setPizzaBuilder(hawaiian_pizzabuilder);        waiter.construct();        System.out.println(\"pizza：\" + waiter.getPizza());        // 输出：pizza：cross + mild + ham&amp;pineapp1e    }}C++#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Pizza{private:    string parts;public:    void setParts(string parts) { this-&gt;parts = parts; }    string getParts() { return parts; }};class PizzaBuilder{protected:    Pizza *pizza;public:    Pizza *getPizza() { return pizza; }    void createNewPizza() { pizza = new Pizza(); }    virtual void buildParts() = 0;};class HawaiianPizzaBuilder : public PizzaBuilder{public:    void buildParts() { pizza-&gt;setParts(\"cross + mild + ham&amp;pineapple\"); }};class SpicyPizzaBuilder : public PizzaBuilder{public:    void buildParts()    {        pizza-&gt;setParts(\"pan baked + hot + pepperoni&amp;salami\");    }};class Waiter{private:    PizzaBuilder *pizzaBuilder;public:    void setPizzaBuilder(PizzaBuilder *pizzaBuilder)    { /* 设置构建器 */        this-&gt;pizzaBuilder = pizzaBuilder;    }    Pizza *getPizza() { return pizzaBuilder-&gt;getPizza(); }    void construct()    {        pizzaBuilder-&gt;createNewPizza();        pizzaBuilder-&gt;buildParts();    }};int main(){    Waiter *waiter = new Waiter();    PizzaBuilder *hawaiian_pizzabuilder = new HawaiianPizzaBuilder();    waiter-&gt;setPizzaBuilder(hawaiian_pizzabuilder);    waiter-&gt;construct();    cout &lt;&lt; \"pizza: \" &lt;&lt; waiter-&gt;getPizza()-&gt;getParts() &lt;&lt; endl;}// 程序的输出结果为：// pizza：cross + mild + ham*pineapple例子 2import java.util.*;public class Main{    public static void main(String[] args) {        Director d = new Director();        Builder b1 = new Builder1();        d.Construct(b1);        Product p1 = new b1.getResult();        p1.show();    }}class Product{    List&lt;String&gt; parts = new ArrayList&lt;String&gt;();        public void Add(String part){        parts.add(part);    }        public void show(){        System.out.println(\"The information of product:\");        for(String s : parts)            System.out.print(s + \" \");        System.out.println();    }}abstract class Builder{    public abstract void BuildPart();    public abstract Product getResult();}class Builder1 extends Builder{    Product p = new Product();    @Override    public void BuildPart(){        p.Add(\"A1\");        p.Add(\"A2\");        p.Add(\"C\");    }    @Override    public Product getResult(){        return p;    }}class Builder2 extends Builder{    Product p = new Product();    @Override    public void BuildPart(){        p.Add(\"B1\");        p.Add(\"B2\");        p.Add(\"C\");    }    @Override    public Product getResult(){        return p;    }}class Director{    public void Construct(Builder builder){        builder.BuildPart();    }}"
  },
  
  {
    "title": "工厂模式",
    "url": "/archives/111",
    "categories": "软件工程",
    "tags": "对象创建型模式, 类创建型模式, 设计模式",
    "date": "2023-05-28 10:23:46 +0800",
    





    
    "snippet": "简单工厂模式简单工厂模式属于创建型模式，但不属于 23 种设计模式之一定义：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类在简单工厂模式中用于被创建实例的方法通常为静态 (static) 方法，因此简单工厂模式又被称为静态工厂方法 (Static Factory Method)需要什么产品就传入产品对应的参数，就可以获取所需要的产品对象，而无需知道其实...",
    "content": "简单工厂模式简单工厂模式属于创建型模式，但不属于 23 种设计模式之一定义：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类在简单工厂模式中用于被创建实例的方法通常为静态 (static) 方法，因此简单工厂模式又被称为静态工厂方法 (Static Factory Method)需要什么产品就传入产品对应的参数，就可以获取所需要的产品对象，而无需知道其实现过程例如：有一家饺子店，当客户需要某种饺子时，饺子店生成对应的饺子给客户。这里就可以把饺子店看成工厂 (Factory) ，饺子看成产品 (Product) ，饺子的名称看成参数，饺子店根据不同的参数返回不同的饺子比如：客户想要韭菜饺子，这里韭菜就是参数，饺子店会根据参数韭菜返回韭菜饺子 (饺子店有韭菜饺子的前提下)三类角色：  工厂 (核心)​\t负责实现创建所有产品的内部逻辑，工厂类可以被外界直接调用，创建所需对象  抽象产品​\t工厂类所创建的所有对象的父类，封装了产品对象的公共方法，所有的具体产品为其子类对象  具体产品​\t简单工厂模式的创建目标，所有被创建的对象都是某个具体类的实例例子public class SimpleFactory{    public static void main(String[] args){        Product productA = Factory.createProduct(\"A\");        productA.info();        // ...    }}abstract class Product{    public abstract void info();}class ProductA extends Product{    @Override    public void info(){        System.out.println(\"A\");    }}class ProductB extends Product{    @Override    public void info(){        System.out.println(\"B\");    }}class Factory{    public static Product creatProduct(String type){        Product p = null;        // 此处未考虑异常情况以及处理        switch(type){            case \"A\":                p = new ProductA();                break;            case \"B\":                p = new ProductB();                break;            default:                System.out.println(\"Please try again\");                break;        }                return p;    }}当增加产品时，将更改工厂，违反了 开发 - 封闭原则工厂方法模式Factory Method Pattern 类创建型模式意图定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类结构其中：  Product 定义工厂方法所创建的对象的接口  ConcreteProduct 实现 Product 接口  Creator 声明工厂方法，该方法返回一个 Product 类型的对象，Creator 也可以定义一个工厂方法的默认实现，它返回一个默认的 ConcreteProduct 对象，可以调用工厂方法以创建一个 Product 对象  ConcreteCreator 重定义工厂方法以返回一个 ConcreteProduct 实例适用性Factory Method 模式适用于：  当一个类不知道它所必须创建的对象的类的时候  当一个类希望由它的子类来指定它所创建的对象的时候  当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候例子// 在上一个代码的基础上修改public class FactoryMethod{    public static void main(String[] args){        Factory factoryA = new FactoryA();                //Product productA = Factory.createProduct(\"A\");        Product productA = factoryA.createProduct();        productA.info();        // ...    }}// 抽象类改接口// abstract class Productinterface class Product{    // public abstract void info();    public void info();}// 继承改实现// class ProductA extends Product{class ProductA implements Product{    @Override    public void info(){        System.out.println(\"A\");    }}// 继承改实现// class ProductB extends Product{class ProductB implements Product{    @Override    public void info(){        System.out.println(\"B\");    }}// 实类改接口// class Factoryinterface Factory{    public Product creatProduct();}// 增加接口实现class FactoryA implements Factory{    @Override    public Product createProduct(){        return new ProductA();    }}class FactoryB implements Factory{    @Override    public Product createProduct(){        return new ProductB();    }}抽象工厂模式Abstract Factory Pattern 对象创建型模式意图提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类结构其中：  AbstractFactory 声明一个创建抽象产品对象的操作接口  ConcreteFactory 实现创建具体产品对象的操作  AbstractProduct 为一类产品对象声明一个接口  ConcreteProduct 定义一个将被相应的具体工厂创建的产品对象，实现 AbstractProduct 接口  Client 仅使用由 AbstractFactory 和 AbstractProduct 类声明的接口适用性Abstract Factory 模式适用于：  一个系统要独立于它的产品的创建、组合和表示时  一个系统要由多个产品系列中的一个来配置时  当要强调一系列相关的产品对象的设计以便进行联合使用时  当提供一个产品类库，只想显示它们的接口而不是实现时例子public class AbstractFactory{    public static void main(String[] args){        Factory factory1 = new Factory1();                ProductA productA = factory1.createProductA();        productA.info();        // ...    }}interface class ProductA{    public void info();}class ProductA1 implements ProductA{    @Override    public void info(){        System.out.println(\"A1\");    }}class ProductA2 implements ProductA{    @Override    public void info(){        System.out.println(\"A2\");    }}interface class ProductB{    public void info();}class ProductB1 implements ProductB{    @Override    public void info(){        System.out.println(\"B1\");    }}class ProductB2 implements ProductB{    @Override    public void info(){        System.out.println(\"B2\");    }}interface Factory{    public ProductA creatProductA();    public ProductB creatProductB();}class Factory1 implements Factory{    @Override    public ProductA createProductA(){        return new ProductA1();    }        @Override    public ProductB createProductB(){        return new ProductB1();    }}class Factory2 implements Factory{    @Override    public ProductA createProductA(){        return new ProductA2();    }        @Override    public ProductB createProductB(){        return new ProductB2();    }}"
  },
  
  {
    "title": "算法 钢条切割问题 (动态规划 分治)",
    "url": "/archives/110",
    "categories": "算法",
    "tags": "c/c++, 分治, 动态规划",
    "date": "2023-05-27 19:37:08 +0800",
    





    
    "snippet": "问题描述某公司购买长钢条，将其切割后进行出售。切割钢条的成本可以忽略不计，钢条的长度为英寸。已知价格表 $p$ ，其中 $p_{i}(i=1,2,\\cdots,m)$ 表示长度为 $i$ 英寸的钢条的价格。现要求解使销售收益最大的切割方案问题分析假设长钢条的长度为 $n$ 英寸，最佳切割方案的最左边切割段长度为 $i$ 英寸，则继续求解剩余长度为 $m-1$ 英寸钢条的最佳切割方案。考虑所以...",
    "content": "问题描述某公司购买长钢条，将其切割后进行出售。切割钢条的成本可以忽略不计，钢条的长度为英寸。已知价格表 $p$ ，其中 $p_{i}(i=1,2,\\cdots,m)$ 表示长度为 $i$ 英寸的钢条的价格。现要求解使销售收益最大的切割方案问题分析假设长钢条的长度为 $n$ 英寸，最佳切割方案的最左边切割段长度为 $i$ 英寸，则继续求解剩余长度为 $m-1$ 英寸钢条的最佳切割方案。考虑所以可能的 $i$ ，得到的最大收益 $r_{n}$ 对应的切割方案即为最佳切割方案。$r_{n}$ 的递归定义如下\\(r_{n}=max_{1\\le i \\le n}(p_{i}+r_{n-i})\\)C 代码对此问题有两种方案(1) 分治 (自顶向下)int Top_Down_Cut_Rod(int p[], int n){    int r=0;\t// 最大价值    int i;        if(n==0){        retrun 0;    }        for(i=1; i&lt;=n; i++){        int tmp = p[i]+Top_Down_Cut_Rod(p, n-i);        r = (r&gt;=tmp) ? r : tmp;    }        return r;}时间复杂度 $O(2^{n})$(2) 动态规划 (自底向上)int Bottom_Up_Cut_Rod(int p[], int n, int *s){    // *s:子问题最优切割方法    int r[n+1];\t// 子问题最优价值    r[0]=0;        for(int j=1; j&lt;=n; j++){        int tmp=0;        for(int i=1; i&lt;=j; i++){            if(p[i]+r[j-1] &gt; tmp){                tmp = p[i]+r[j-i];                s[j]=i;            }        }        r[i]=tmp;    }        return r[n];}时间复杂度 $O(n^{2})$其他在搜索过程中发现已有的文章：【基础算法】动态规划详解——钢条切割"
  },
  
  {
    "title": "算法 假币问题 (分治)",
    "url": "/archives/109",
    "categories": "算法",
    "tags": "c/c++, 分治",
    "date": "2023-05-18 20:17:35 +0800",
    





    
    "snippet": "问题描述有 $n$ 枚硬币，其中有一枚是假币，已知假币的重量较轻。现只有一个天平，要求用尽量少的比较次数找出这枚假币问题分析将 $n$ 枚硬币分成相等的两部分：  当 $n$ 为偶数时，将前后两部分，即 $1\\cdots\\frac{n}{2}$ 和 $\\frac{n}{2}+1\\cdots n$ 放在天平的两端，较轻的一端里有假币，继续在较轻的这部分硬币中用同样的方法找出假币  当 $n$ ...",
    "content": "问题描述有 $n$ 枚硬币，其中有一枚是假币，已知假币的重量较轻。现只有一个天平，要求用尽量少的比较次数找出这枚假币问题分析将 $n$ 枚硬币分成相等的两部分：  当 $n$ 为偶数时，将前后两部分，即 $1\\cdots\\frac{n}{2}$ 和 $\\frac{n}{2}+1\\cdots n$ 放在天平的两端，较轻的一端里有假币，继续在较轻的这部分硬币中用同样的方法找出假币  当 $n$ 为奇数时，将前后两部分，即 $1\\cdots\\frac{n-1}{2}$ 和 $\\frac{n+1}{2}+1\\cdots n$ 放在天平的两端，较轻的一端里有假币，继续在较轻的这部分硬币中用同样的方法找出假币；若两端重量相等，则中间的硬币，即第 $\\frac{n+1}{2}$ 枚硬币是假币C 代码#include &lt;stdio.h&gt;// coins:重量数组   first,last:数组第一个与最后一个下标int getCounterfeitCoin(int *coins, int first, int last);int main(void){    int coins[10] = {2,2,1,2,2,2,2,2,2,2};    int tmp = getCounterfeitCoin(coins, 0, 9);    printf(\"第 %d 个是假币\\n\",tmp+1);    return 0;}int getCounterfeitCoin(int *coins, int first, int last){    int firstSum=0; int lastSum=0;    int i;    // 只剩两枚硬币    if(first == last -1){        if(coins[first] &lt; coins[last])            return first;        return last;    }    // 偶数枚硬币    if ((last-first+1)%2 == 0){        for(i=first; i&lt;first+(last-first)/2+1; i++){            firstSum += coins[i];        }        for(i=first+(last-first)/2+1; i&lt;last+1; i++){            lastSum += coins[i];        }        if(firstSum &lt; lastSum){            return getCounterfeitCoin(coins, first, first+(last-first)/2);        }else{            return getCounterfeitCoin(coins, first+(last-first)/2+1, last);        }    }else{  // 奇数枚硬币        for(i=first; i&lt;first+(last-first)/2; i++){            firstSum += coins[i];        }        for(i=first+(last-first)/2+1; i&lt;last+1; i++){            lastSum += coins[i];        }        if(firstSum &lt; lastSum){            return getCounterfeitCoin(coins, first, first+(last-first)/2-1);        }else if(firstSum &gt; lastSum){            return getCounterfeitCoin(coins, first+(last-first)/2+1, last);        }else{            return first+(last-first)/2;        }    }}"
  },
  
  {
    "title": "设计模式 引",
    "url": "/archives/108",
    "categories": "软件工程",
    "tags": "设计模式, 面向对象",
    "date": "2023-05-17 22:50:20 +0800",
    





    
    "snippet": "“每一个设计模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。设计模式的核心在于提供了相关问题的解决方案，使得人们可以简单方便地复用成功的设计和体系结构设计模式一般有以下 4 个基本要素  模式名称 (Pattern Name) 。一个助记名，它用一两个词来描述模式的问题、解决方案和效果  问题 (Problem) ...",
    "content": "“每一个设计模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。设计模式的核心在于提供了相关问题的解决方案，使得人们可以简单方便地复用成功的设计和体系结构设计模式一般有以下 4 个基本要素  模式名称 (Pattern Name) 。一个助记名，它用一两个词来描述模式的问题、解决方案和效果  问题 (Problem) 。问题描述了应该在何时使用模式  解决方案 (Solution) 。解决方案描述了设计的组成成分、它们之间的相互关系及各自的职责和协作方式  效果 (Consequences) 。效果描述了模式应用的效果及使用模式应权衡的问题设计模式确定了所包含的类和实例，它们的角色、协作方式以及职责分配。每一个设计模式都集中于一个特定的面向对象设计问题或设计要点，描述了什么时候使用它，在另一些设计约束条件下是否还能使用，以及使用的效果和如何取舍。按照设计模式的目的可以分成三大类创建型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎样分配职责进行描述                   创建型      结构型      行为型                  类      工厂方法模式      适配器模式 (类)      解释器模式模板方法模式              对象      抽象工厂模式生成器模式原型模式单例模式      适配器模式 (对象)桥接模式组合模式装饰器模式外观模式享元模式代理模式      责任链模式命令模式迭代器模式中介者模式备忘录模式观察者模式状态模式策略模式访问者模式      创建型设计模式创建型模式抽象了实例化过程，它们帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象随着系统演化得越来越依嫩于对象复合而不是类继承，创建型模式变得更为重要，当这种情况发生时，重心从对一组固定行为的硬编码 (Hard-coding) 转移为定义一个较小的基本行为集，这些行为可以被组合成任意数目的更复杂的行为，这样创建有特定行为的对象要求的不仅仅是实例化一个类在这些模式中有两个不断出现的主旋律  它们都将关于该系统使用哪些具体的类的信息封装起来  它们隐藏了这些类的实例是如何被创建和放在一起的。整个系统关于这些对象所知道的是由抽象类所定义的接口因此，创建型模式为什么被创建，谁创建它，它是怎样被创建的，以及何时创建这些方面给予了很大的灵活性。它们允许用结构和功能差别很大的 “产品” 对象配置一个系统。配置可以是静态的 (即在编译时指定) ，也可以是动态的 (在运行时)结构型设计模式结构型设计模式涉及如何组合类和对象以获得更大的结构。结构型类模式采用继承机制来组合接口或实现。一个简单的例子是采用多重继承方法将两个以上的类组合成一个类，结果这个类包含了所有父类的性质。这一模式尤其有助于多个独立开发的类库协同工作。其中一个例子是类形式的 Adapter 模式。一般来说，适配器使得一个接口与其他接口兼容，从而給出了多个不同接口的统一抽象。为此，类适配器对一个 adaptee 类进行私有继承。这样，适配器就可以用 adaptee 的接口表示它的接口结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能的一些方法。因为可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的行为型设计模式行为模式涉及算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述它们之间的通信模式。这些模式刻面了在运行时难以跟踪的、复杂的控制流。它们将用户的注意力从控制流转移到对象间的联系方式上来行为类模式使用继承机制在类间分派行为。其中 Template Method 较为简单和常用。模板方法是一个算法的抽象定义，它逐步地定义该算法，每一步调用一个抽象操作或一个原语操作，子类定义抽象操作以具体实现该算法。另一种行为类模式是 Interpreter，它将一个文法表示为一个类层次，并实现一个解释器作为这些类的实例上的一个操作行为对象模式使用对象复合而不是继承。一些行为对象模式描达了一组对等的对象怎样相互协作以完成其中任一个对象都无法单独完成的任务。这里一个重要的问题是对等的对象如何互相了解对方。对等对象可以保持显式的对对方的引用，但那会增加它们的耦合度。在极端情况下，每一个对象都要了解所有其他的对象。Mediator 在对等对象间引入一个 mediator 对象以避免这种情况的出现。mediator 提供了松耦合所需的间接性推荐阅读https://refactoringguru.cn/design-patterns"
  },
  
  {
    "title": "Honkai: Star Rail 国际服分流规则",
    "url": "/archives/107",
    "categories": "日常",
    "tags": "Game, miHoYo",
    "date": "2023-05-16 23:13:21 +0800",
    





    
    "snippet": "针对中国大陆无法进入游戏分流规则Key在进入游戏时需要 udp 连接，而多数协议不支持 udp，即遇到 udp 会自动拒绝，所以将 udp 连接的 IP 设置为直连即可，下面是我抓取到的两个 IP8.209.196.179# 第二个貌似直连不会连接，只用设置第一个就行47.245.63.117当然，为了安全起见 (指 tcp 连接与 udp 连接不一致可能造成的安全隐患) ，建议将相关域名都...",
    "content": "针对中国大陆无法进入游戏分流规则Key在进入游戏时需要 udp 连接，而多数协议不支持 udp，即遇到 udp 会自动拒绝，所以将 udp 连接的 IP 设置为直连即可，下面是我抓取到的两个 IP8.209.196.179# 第二个貌似直连不会连接，只用设置第一个就行47.245.63.117当然，为了安全起见 (指 tcp 连接与 udp 连接不一致可能造成的安全隐患) ，建议将相关域名都设置直连，即以下这些*.starrails.com*.hoyoverse.com8.209.196.179/8OpenClash在 全局设置-规则设置 ，启用 自定义规则 ，第一个框的 rules: 下输入#rules:- DOMAIN-SUFFIX, starrails.com, DIRECT- DOMAIN-SUFFIX, hoyoverse.com, DIRECT- IP-CIDR, 8.209.196.179/8, DIRECTQuantumult X编辑配置文件，跳转至 [filter_local] ，输入以下内容#SRhost-suffix, starrails.com, directhost-suffix, hoyoverse.com, directip-cidr, 8.209.196.179/8, direct"
  },
  
  {
    "title": "算法 电路布线问题 (动态规划)",
    "url": "/archives/106",
    "categories": "算法",
    "tags": "c/c++, 动态规划",
    "date": "2023-05-16 17:53:31 +0800",
    





    
    "snippet": "问题描述在一块电路板的上下两端分别有 n 个接线柱。根据电路设计，用 $(i, \\pi(i))$ 表示将上端接线柱 i 与下端接线柱 $\\pi(i)$ 相连，称其为该电路板上的第 i 条连线下图所示的 $\\pi(i)$ 排列为 ${8, 7, 4, 2, 5, 1, 9, 3, 10, 6}$ 对于任何 $1 \\le i &lt; j \\le n $ ，第 i 条连线和第 j 条连线相交的充...",
    "content": "问题描述在一块电路板的上下两端分别有 n 个接线柱。根据电路设计，用 $(i, \\pi(i))$ 表示将上端接线柱 i 与下端接线柱 $\\pi(i)$ 相连，称其为该电路板上的第 i 条连线下图所示的 $\\pi(i)$ 排列为 ${8, 7, 4, 2, 5, 1, 9, 3, 10, 6}$ 对于任何 $1 \\le i &lt; j \\le n $ ，第 i 条连线和第 j 条连线相交的充要条件是 $\\pi(i)&gt;\\pi(j)$在制作电路板时，要求将这 n 条连线分布到若干绝缘层上，在同一层上的连线不相交，现在要确定将哪些连线安排在一层上，使得该层上有尽可能多的连线，即确定连线集 $Nets={ (i,\\pi(i)),1\\le i\\le n }$ 的最大不相交子集问题分析记 $N(i,j)={ t|(t,\\pi(t))\\in Nets, t\\le i, \\pi(t) \\le j }$ 。$N(i,j)$ 的最大不相交子集为 $MNS(i,j)$ ，$size(i,j)=|MNS(i,j)|$经分析，该问题具有最优子结构性质。对规模为 n 的电路布线问题，可以构造如下递归式\\(\\begin{align*}&amp;(1) \\ 当 \\ i=1\\ 时，size(1,j)= \\begin{cases}0, &amp; \\text{j&lt;$\\pi$(1)} \\\\1, &amp; \\text{其他情况}\\end{cases}\\\\&amp;(2) \\ 当 \\ i&gt;1\\ 时，size(i,j)= \\begin{cases}size(i-1,j), &amp; \\text{j&lt;$\\pi$(i)} \\\\max{size(i-1,j),size(i-1,\\pi(i)-1)+1}, &amp; \\text{其他情况}\\end{cases}\\end{align*}\\)C 代码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 10    // 问题规模// 求最大不相交连接数void maxNum(int pi[], int **size);// 构造最大不相交连接集合，net[i]表示最大不相交子集中第i条连线的上端接线柱的序号int constructSet(int pi[], int **size, int *net);int main(void){    // 下标从1开始    int pi[N+1] = {0, 8, 7, 4, 2, 5, 1, 9, 3, 10, 6};    int net[N];    int **size;    size = (int**)malloc(sizeof(int*)*(N+1));    for(int i=0;i&lt;N+1;i++)        size[i]=(int*)malloc(sizeof(int)*(N+1));    maxNum(pi, size);    int m = constructSet(pi, size, net);       printf(\"最大不相交连接数为：%d\\n\",m);    printf(\"包含的连线为：\\n\");    for(int i=0; i&lt;m; i++){        printf(\"(%d,%d)\\n\", net[i], pi[net[i]]);    }}void maxNum(int pi[], int **size){    // size[i][j]: 上下端分别有i个和j个接线柱的电路板的第一层最大不相交连接数    int i,j;    // when j&lt;pi(1)    for(j=0; j&lt;pi[1]; j++)        size[1][j];    // when j&gt;=pi(1)    for(j=pi[1]; j&lt;=N; j++)        size[1][j];    for(i=2; i&lt;N; i++){        // when j&lt;pi(i)        for(j=0; j&lt;pi[i]; j++)            size[i][j] = size[i-1][j];           // when j&gt;=c[i]        for(j=pi[i]; j&lt;=N; j++)            size[i][j]=size[i-1][j]&gt;=size[i-1][pi[i]-1]+1 ? size[i-1][j] : size[i-1][pi[i]-1]+1;    }    // 最大连接数    size[N][N] = size[N-1][N]&gt;=size[N-1][pi[N]-1]+1 ? size[N-1][N] : size[N-1][pi[N]-1]+1;}// 构造最大不相交连接集合，net[i]表示最大不相交子集中第i条连线的上端接线柱的序号int constructSet(int pi[], int **size, int *net){    int i;    int j=N;    int m=0;    // 记录最大连接集合中的接线柱    for(i=N; i&gt;1; i--){ // 递减        // (i,pi[i])是最大不相交子集的一条连线        if(size[i][j] != size[i-1][j]){            net[m++]=i; // 将i记录到数组net中，连接线数自增1            j=pi[i]-1;  // 更新扩展连线柱区间        }    }    // when i=1    if(j&gt;=pi[1])        net[m++] = 1;    return m;}其他在搜索过程中发现已有的文章：算法设计与分析——电路布线（动态规划）参考文章LaTeX公式手册Typora中使用LaTeX：多行公式左对齐用malloc动态申请一个二维数组的三种方法"
  },
  
  {
    "title": "搭建个人音乐网站",
    "url": "/archives/105",
    "categories": "折腾记录",
    "tags": "Docker",
    "date": "2023-05-02 02:27:39 +0800",
    





    
    "snippet": "使用 Rclone 挂载 Onedrive 歌曲文件，Navidrome 搭建网站，采用 docker 部署Rclone首先需要在 Windows 系统上运行获取配置，然后再在服务器上安装并挂载文件获取 Token在 Windows 电脑上下载 Rclone，下载地址：https://rclone.org/downloads/下载完成后解压，解压完成后通过 cmd 进入该文件夹，然后运行rc...",
    "content": "使用 Rclone 挂载 Onedrive 歌曲文件，Navidrome 搭建网站，采用 docker 部署Rclone首先需要在 Windows 系统上运行获取配置，然后再在服务器上安装并挂载文件获取 Token在 Windows 电脑上下载 Rclone，下载地址：https://rclone.org/downloads/下载完成后解压，解压完成后通过 cmd 进入该文件夹，然后运行rclone.exe authorize \"onedrive\"在弹出的浏览器中登录并授权，授权完成后会打印 Token (大括号之间的，包括大括号)获取配置文件运行命令rclone.exe config根据需求选择即可，完成后配置文件生成在：C:\\Users\\%USERNAME%\\AppData\\Roaming\\rclone复制配置文件首先需要在服务器创建两个文件夹# 该文件夹放配置文件/home/docker/rclone/config# 该文件夹放数据，即 Onedrive 映射到的文件夹/home/docker/rclone/data然后将配置文件放到对应的文件夹挂载目录运行命令以拉取镜像docker pull rclone/rclone:latest挂载目录docker run --rm \\    --volume /root/rclone/config:/config/rclone \\    --volume /root/rclone/data:/data:shared \\    --volume /etc/passwd:/etc/passwd:ro --volume /etc/group:/etc/group:ro \\    --device /dev/fuse --cap-add SYS_ADMIN --security-opt apparmor:unconfined \\    rclone/rclone \\    mount music:/ /data/music --allow-other --allow-non-empty --vfs-cache-mode writes &amp;# 上述命令仅最后一行为 Rclone 的命令，根据实际情况修改，格式如下rclone mount DriveName:Folder LocalFolder# DriveName\t\tRclone 挂载的名称# Folder\t\t云盘的路径# LocalFolder\t挂载到本地的文件上述命令最后的 &amp; 表示后台运行，命令执行后会打印进程的 PID，如需关闭使用命令kill PID了解更多？访问：Linux 学习 第六章 管理运行中的进程根据示例，此处演示将 Onedrive 中 music (不区分大小写) 目录挂载至 /home/docker/rclone/data/music参考资料：  https://rclone.org/onedrive/  https://rclone.cn/install.html  Linux上使用Rclone挂载OneDrive或GoogleDrive并设置开机自启部署 Navidrome采用 docker-compose，首先创建文件夹，例如/home/docker/navidrome创建文件 docker-compose.yml 并填入内容vim docker-compose.yml# 输入内容version: \"3\"services:  navidrome:    image: deluan/navidrome:latest    ports:      - \"8001:4533\"    restart: unless-stopped    environment:      # Optional: put your config options customization here. Examples:      ND_SCANSCHEDULE: 1h      ND_LOGLEVEL: info        ND_SESSIONTIMEOUT: 24h      ND_BASEURL: \"\"    volumes:      - \"/home/docker/navidrome/data:/data\"      - \"/home/docker/rclone/data/music:/music:ro\"查看更多变量：Navidrome Configuration Options - Navidrome然后运行命令docker-compose up -d访问 IP:8001 即可参考资料：  https://www.navidrome.org/docs/installation/docker/  Navidrome搭建一个属于自己的音乐播放器歌曲信息如果想要进行歌曲分类需要把歌曲的信息嵌入歌曲里，包括歌词可以使用工具 MusicTag 进行修改作者网站：音乐标签pc版当然还有其他的工具，或者这个 Web 版 xhongc/music-tag-web使用客户端这个网页端在 PC 上使用还行，但是手机上使用一言难尽，不过好在有一些客户端可以使用详情访问：https://www.navidrome.org/docs/overview/#apps"
  },
  
  {
    "title": "UML 中的图",
    "url": "/archives/104",
    "categories": "软件工程",
    "tags": "UML, 面向对象",
    "date": "2023-04-13 20:02:00 +0800",
    





    
    "snippet": "图 (Diagram) 是一组元素的图形表示，大多数情况下把图画成顶点 (代表事物) 和弧 (代表关系) 的连通图。为了对系统进行可视化，可以从不同的角度画图，这样图是对系统的投影UML 2.0 提供了 13 种图，分别是类图、对象图、用例图、序列图、通信图、状态图、活动图、构件图、组合结构图、部署图、包图、交互概览图和计时图。序列图、通信图、交互概览图和计时图均被称为交互图(一) 类图类图...",
    "content": "图 (Diagram) 是一组元素的图形表示，大多数情况下把图画成顶点 (代表事物) 和弧 (代表关系) 的连通图。为了对系统进行可视化，可以从不同的角度画图，这样图是对系统的投影UML 2.0 提供了 13 种图，分别是类图、对象图、用例图、序列图、通信图、状态图、活动图、构件图、组合结构图、部署图、包图、交互概览图和计时图。序列图、通信图、交互概览图和计时图均被称为交互图(一) 类图类图 (Class Diagram) 展现了一组对象、接口、协作和它们之间的关系。在面向对象系统的建模中所建立的最常见的图就是类图。类图给出系统的静态设计视图。包含主动类的类图给出了系统的静态进程视图类图中通常包括下述内容：  类  接口  协作  依赖、泛化和关联关系例如：            Student                  +id: int-name: String#age: int              ~borrow(): bool      +: public-: private#: protected~: package类图中也可以包含注解和约束。类图还可以含有包或子系统，二者都用于把模型元素聚集成更大的组块类图用于对系统的静态设计视图建模。这种视图主要支持系统的功能需求，即系统要提供给最终用户的服务。当对系统的静态设计视图建模时，通常以下述 3 种方式之一使用类图  对系统的词汇建模  对简单的协作建模  对逻辑数据库模式建模(二) 对象图对象图 (Object Diagram) 展现了某一时刻一组对象以及它们之间的关系，描述了在类图中所建立的事物的实例的静态快照。对象图一般包括对象和链            对象名：类名                  属性      和类图一样，对象图给出系统的静态设计视图或静态进程视图(三) 用例图用例图 (Use Case Diagram) 展现了一组用例、参与者 (Actor) 以及它们之间的关系用例图通常包含以下内容：  用例  参与者  用例之间的拓展关系 &lt;&lt;extend&gt;&gt; 和包含关系 &lt;&lt;include&gt;&gt; ，参与者和用例之间的关联关系，用例与用例以及参与者与参与者之间的泛化关系  包含关系一个用例包含另一个用例基本用例 –&lt;&lt;include&gt;&gt;–&gt; 被包含用例  扩展关系一个用例执行的时候，可能会发生一些特殊的情况或可选的情况，这种情况就是这个用例的扩展用例扩展用例 –&lt;&lt;extend&gt;&gt;–&gt; 基本用例用例图用于对系统的静态用例视图进行建模。这个视图主要支持系统的行为，即该系统在它的周边环境的语境中所提供的外部可见服务当对系统的静态用例视图建模时，可以用下列两种方式来使用用例图  对系统的语境建模  对系统的需求建模(四) 交互图交互图用于对系统的动态方面进行建模。一张交互图表现的是一个交互，由一组对象和它们之间的关系组成，包含它们之间可能传递的信息。交互图表现为序列图、通信图、交互概览图和计时图，每种针对不同的目的，能适用于不同的情况。序列图是强调消息时间顺序的交互图；通信图是强调接受和发生消息的对象的结构组织的交互图；交互概览图强调控制流的交互图交互图一般包含对象、链和消息序列图序列图 (Sequence Diagram) 是场景 (Scenario) 的图形化表示，描述了以时间顺序组织的对象之间的交互活动。形成序列图时，首先把参加交互的对象放在图的上方，沿水平方向排列。通常把发起交互的对象放在左边，下级对象以此放在右边。然后，把这些对象发生和接收的消息沿着垂直方向按时间顺序从上到下放置。这样，就提供了控制流随时间推移的清晰的可视化轨迹序列图有两个不同于通信图的特征  序列图有对象生命线。对象生命线是一条垂直的虚线，表示一个对象在一段时间内存在  序列图有控制焦点。控制焦点是一个瘦高的矩形，表示一个对象执行一个动作所经历的时间段，既可以是直接执行，也可以是通过下级过程执行。矩形的顶部表示动作的开始，底部表示动作的结束通信图通信图 (Communication Diagram) 强调收发信息的对象的结构组织，在早期的版本中也被称作协作图。通信图强调参加交互的对象的组织。产生一张通信图，首先要将参加交互的对象作为图的顶点，然后把连接这些对象的链表示为图的弧，最后用对象发送和接收的消息来修饰这些链。这就提供了在协作对象的结构组织的语境中观察控制流的一个清晰的可视化轨迹通信图有两个不同于序列图的特性  通信图有路径。为了指出一个对象如何与另一个对象链接，可以在链的末端附上一个路径构造型  通信图有顺序号。为表示一个消息的时间顺序，可以给消息加一个数字前缀，在控制流中，每个新消息的顺序号单调增加。为了使用嵌套，可使用带小数点的号码序列图和通信图是同构的，它们之间可以相互转换(五) 状态图状态图 (State Diagram) 展现了一个状态机，它由状态、转换、事件和活动组成。状态图关注系统的动态视图，对于接口、类和协作的行为建模尤为重要，强调对象行为的事件顺序状态图通常包括简单状态和组合状态、转换 (事件和动作)状态状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。系统对事件的响应，既可以是做一个 (或一系列) 动作，也可以是仅仅改变系统本身的状态，还可以是既改变状态，又做动作在状态图中定义的状态主要有：初态 (即初始状态) 、终态 (即最终状态) 和中间状态。初态用一个黑圆点表示，终态用黑圆点外加一个圆表示，状态图中的状态用一个圆角四边形表示状态之间为状态转换，用一条带箭头的线表示。带箭头的线上的事件发生时，状态转换开始。一张状态图中只能有一个初态，而终态可以没有，也可以有多个三种标准事件：  entry: 入口动作，进入状态，立即执行  exit: 出口动作，退出状态，立即执行  do: 内部活动，占有有限时间，并可以中断的工作以上图例：  entry/turnON: 当转入该状态时，做开灯动作  do/blinkFivetimes: 当处于该状态时，灯闪烁 5 次  exit/turnOFF: 当转出该状态时，做关灯动作事件与转换事件是在某个特定时刻发生的事情，它是对引起系统做动作或 (和) 从一个状态转换到另一个状态的外界事件的抽象。例如，观众使用电视遥控器，用户移动鼠标、单机鼠标等都是事件。简而言之，事件就是引起系统引起系统做动作或 (和) 转换状态的控制信息状态变迁通常是由事件触发的，在这种情况下，应在表示状态转换的箭头上标出触发转换的事件表达式如果在箭头线上未标明事件，则表示在源状态的内部活动执行完之后自动触发转换，事件表达式的语法如下事件说明[监护条件]动作表达式其中，事件说明的语法为：事件名(参数表)监护条件 (或者守护条件) 是一个布尔表达式。如果同时使用事件说明和监护条件，则当且仅当事件发生且布尔表达式为真时，状态转换才发生。如果只有监护条件没有事件说明时，则只要守卫条件为真，状态转换就发生转换包括两个状态 (原状态，目标状态)事件，监护条件，动作事件触发转换 (迁移)活动 (动作) 可以在状态内执行，也可以在状态转换 (迁移) 时执行完整图可以用状态图对系统的动态方面建模。这些动态方面可以包括出现在系统体系结构的任何视图中的任何一种对象的按事件排序的行为，这些对象包括类 (各主动类) 、接口、构件和结点当对系统、类或用例的动态方面建模时，通常是对反应型对象建模(六) 活动图活动图 (Activity Diagram) 是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程。活动图专注于系统的动态视图，它对于系统的功能建模特别重要，并强调对象间的控制流程活动图一般包括活动状态和动作状态、转换和对象活动图可以表示分支、合并、分岔和汇合当对一个系统的动态方面建模时，通常有两种使用活动图的方式  对工作流建模  对操作建模(七) 构件图构件图 (Component Diagram) 展现了一组构件之间的组织和依赖。构件图专注于系统的静态实现视图。它与类图相关，通常把构件映射为一个或多个类、接口或协作(八) 部署图部署图 (Deployment Diagram) 是用来对面向对象系统的物理方面建模的方法，展现了运行时处理结点以及其中构件 (制品) 的配置。部署图对系统的静态部署视图进行建模，它与构件图相关。通常，一个结点是一个在运行时存在并代表一项计算资源的物理元素，至少拥有一些内容，常常具有处理能力，包含一个或多个构件。其中 &lt;&lt;artifact&gt;&gt; 表示制品总结      静态建模：类图、对象图、用例图        动态建模：序列图 (顺序图，时序图) 、通信图 (协作图) 、状态图、活动图        物理建模：构件图 (组件图) 、部署图  交互图：序列图 (顺序图，时序图) 、通信图 (协作图)"
  },
  
  {
    "title": "UML",
    "url": "/archives/103",
    "categories": "软件工程",
    "tags": "UML, 面向对象",
    "date": "2023-04-11 08:01:00 +0800",
    





    
    "snippet": "面向对象分析强调的是对一个系统中对象的特征和行为的定义。目前，国际上已经出现了多种面向对象的方法。业界普遍接受的为 UML (Unified Modeling Language, 统一建模语言)统一建模语言是面向对象软件的标准化建模语言。由于其简单、统一，又能够表达软件设计中的动态和静态信息，目前已经成为可视化建模语言事实上的工业标准UML 由 3 个要素构成：UML 的基本构造块、支配这些...",
    "content": "面向对象分析强调的是对一个系统中对象的特征和行为的定义。目前，国际上已经出现了多种面向对象的方法。业界普遍接受的为 UML (Unified Modeling Language, 统一建模语言)统一建模语言是面向对象软件的标准化建模语言。由于其简单、统一，又能够表达软件设计中的动态和静态信息，目前已经成为可视化建模语言事实上的工业标准UML 由 3 个要素构成：UML 的基本构造块、支配这些构造块如何放置在一起的规则和运用与整个语言的一些公共机制UML 的词汇表包含 3 种构造块：事物、关系和图。事物是对模型中最具有代表性的成分的抽象；关系把事物结合在一起；图凝聚了相关的事物事物UML 中有 4 种事物：结构事物、行为事物、分组事物和注释事物(1) 结构事物 (Structural Thing)结构事物是 UML 模型中的名词。它们通常是模型的静态部分，描述概念或物理元素结构事物包括：      类 (Class)        接口 (Interface)        协作 (Collaboration)        用例 (Use Case)        主动类 (Active Class)        构件 (Component)        制品 (Artifact)        结点 (Node)  (2) 行为事物 (Behavior thing)行为事物是 UML 模型的动态部分。它们是模型中的动词，描述了跨越时间和空间的行为行为事物包括：  交互 (Interaction)  状态机 (State Machine)  活动 (Activity)(3) 分组事物 (Grouping Thing)分组事物是 UML 模型的组织部分，是一些由模型分解成的 “盒子” 。在所有的分组事物中，最主要的分组事物是包 (Package) 。包是把元素组织成组的机制，这种机制具有多种用途。结构事物、行为事物甚至其他分组事物都可以放进包内。包与构件 (仅在运行时存在) 不同，它纯粹是概念上的 (即它仅在开发时存在)(4) 注释事物 (Annotational Thing)注释事物是 UML 模型的解释部分。这些注释事物用来描述、说明和标注模型的任何元素。注解 (Note) 是一种主要的注释事物。注解是一个依附于一个元素或者一组元素之上，对它进行约束或解释的简单符号关系UML 中有 4 种关系：依赖、关联、泛化和实现依赖 (Dependency)依赖是两个事物间的语义关系，其中一个事物 (独立事物) 发生变化会影响另一个事物 (依赖事物) 的语义。在图形上，把一个依赖画成一条可能有方向的虚线关联 (Association)关联是一种结构关系，它描述了一组链，链是对象之间的连接。聚集 (Aggregation) 是一种特殊类型的关联，它描述了整体和部分间的结构关系。在关联上可以标注重复度 (Multiplicity) 和角色 (Role)关联、聚合、组合关联：关联是一种结构关系，它描述了一组链，链是对象之间的连接。在关联上可以标注重复度 (多重度) 和角色例：雇主与员工聚合：部分和整体的生命周期不一致，整体消失了，部分仍然存在，部分可以脱离整体存在例：班级与学生，公司与员工组合：部分和整体的生命周期一致，整体消失了，部分也消失了，部分不可以脱离整体存在例：人与大脑依赖与单向关联依赖较偶然，临时。例如：人与食物，仅饿时依赖，饱了便不依赖单向关联，比较强烈，用单向线表示。例如：人与氧气，鱼与水泛化 (Generalization)泛化是一种特殊/一般关系，特殊元素 (子元素) 的对象可替代一般元素 (父元素) 的对象。用这种方法，子元素共享了父元素的结构和行为。图形上指向父元素实现 (Realization)实现是类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约。在两种情况下会使用实现关系：一种是在接口和实现它们的类或构件之间；另一种是在用例和实现它们的协作之间"
  },
  
  {
    "title": "服务器用 Docker 部署记录",
    "url": "/archives/102",
    "categories": "折腾记录",
    "tags": "Docker",
    "date": "2023-04-04 22:31:45 +0800",
    





    
    "snippet": "从想法产生到彻底实现，一共耗时三个月 (主要是太懒了)安装 Docker使用了 APT 进行安装  添加 HTTPS 传输的软件包以及 CA 证书# 先更新一下sudo apt-get update# 然后安装sudo apt-get install \\     apt-transport-https \\     ca-certificates \\     curl \\     gnupg ...",
    "content": "从想法产生到彻底实现，一共耗时三个月 (主要是太懒了)安装 Docker使用了 APT 进行安装  添加 HTTPS 传输的软件包以及 CA 证书# 先更新一下sudo apt-get update# 然后安装sudo apt-get install \\     apt-transport-https \\     ca-certificates \\     curl \\     gnupg \\     lsb-release  为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥# 国内源curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg# 官方源curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg  向 sources.list 中添加 Docker 软件源  首先需要确定 Debian 的版本号，然后替换下面命令的 $(lsb_release -cs)  版本号需要在 https://mirrors.aliyun.com/docker-ce/linux/debian/dists/ 中# 国内源echo \\  \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian \\  $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null# 官方源echo \\   \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\   $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null如 Debian10 的是 buster ，Debian11 的为 bullseye# 此为 Debian11 的echo \\  \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian \\  bullseye stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null  以上命令会添加稳定版本的 Docker APT 源，如果需要测试版本的 Docker 请将 stable 改为 test  然后安装# 更新缓存sudo apt-get update# 安装 dockersudo apt-get install docker-ce docker-ce-cli containerd.io# 安装 docker-composesudo apt-get install docker-compose或者可以试试一键安装脚本# 测试版curl -fsSL test.docker.com -o get-docker.sh# 以下为稳定版curl -fsSL get.docker.com -o get-docker.sh# 阿里云源sudo sh get-docker.sh --mirror Aliyun# 微软 AzureChina 源sudo sh get-docker.sh --mirror AzureChinaCloud启动 Dockersudo systemctl enable dockersudo systemctl start docker使用命令以下测试是否成功启动docker run --rm hello-world出现下述类似输出即安装启动成功Unable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-world2db29710123e: Pull completeDigest: sha256:c77be1d3a47d0caf71a82dd893ee61ce01f32fc758031a6ec4cf1389248bb833Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/Blog1: WordPress创建相应文件夹 (例如 /root/wordpress)，然后创建 docker-compose.yml 文件version: '3.3'services:   db:     image: mysql:5.7     volumes:       - db_data:/var/lib/mysql     restart: always     environment:       MYSQL_ROOT_PASSWORD: somewordpress       MYSQL_DATABASE: wordpress       MYSQL_USER: wordpress       MYSQL_PASSWORD: wordpress   wordpress:     depends_on:       - db     image: wordpress:latest     volumes:       - /root/wordpress/uploads.ini:/usr/local/etc/php/conf.d/uploads.ini     ports:       - 8000:80     restart: always     environment:       WORDPRESS_DB_HOST: db:3306       WORDPRESS_DB_USER: wordpress       WORDPRESS_DB_PASSWORD: wordpress       WORDPRESS_DB_NAME: wordpressvolumes:    db_data: {}创建 uploads.ini 文件file_uploads = Onmemory_limit = 256Mupload_max_filesize = 10Mpost_max_size = 10Mmax_execution_time = 600docker 容器运行相关# 后台运行docker-compose up -d# 停止docker-compose stop# 停止并删除docker-compose downBlog2: Typecho使用镜像：80x86/typecho创建文件夹与相应文件version: '3.0'services:    typecho:        image: 80x86/typecho:latest        container_name: Typecho_Blog        volumes:            - /root/typecho/data:/data        ports:            - 8001:80        restart: always        environment:            PHP_TZ: Asia/Shanghai            PHP_MAX_EXECUTION_TIME: 600网盘网站使用项目：https://github.com/px-org/PanIndex官方教程：https://docs.noki.icu/version: \"3.0\"services:  PanIndex:    restart: always    image: iicm/pan-index:latest    container_name: VRC_Pan    volumes:      - /root/pan/data:/app/data    ports:      - 8002:5238nginx 与 SSL 证书使用项目：https://github.com/0xJacky/nginx-uiversion: '3.1' services:   nginx-ui:    restart: always    image: uozi/nginx-ui:latest    container_name: nginx_UI    volumes:      - /root/nginx/nginx:/etc/nginx      - /root/nginx/nginx-ui:/etc/nginx-ui      - /root/nginx/www:/www    ports:      - 80:80      - 443:443在配置时代理宿主机的话，可以将宿主机 IP 视为 172.17.0.1具体可通过一些命令查询ip addr show docker0GUI 没什么好说的进入容器内部  获取容器 IDdocker container ls  进入docker exec -i [ID] bash然后使用 bash 命令即可 (没有 bash 提示符)以下仅记录耗时最长的就是调 nginx 和 ssl 配置了，最后一直不成功，便使用 GUISSL 证书使用了 neilpang/acme.sh ，使用了 DNS 验证，其他方式请参考 Run acme.sh in docker · acmesh-official/acme.sh Wiki (github.com)创建相应文件夹与文件version: '3.1' services:   acme.sh:    image: neilpang/acme.sh    container_name: acme.sh        command: daemon    volumes:      - /root/acme/acme.sh:/acme.sh      - /root/acme/conf:/.acme.sh    environment:      - CF_Key=\"这是CF的API\"      - CF_Email=\"这是CF的邮箱\"对于其他 DNS 服务商，请参考：https://github.com/acmesh-official/acme.sh/wiki/dnsapi注册账号：docker exec acme.sh --register-account -m mail@server.com获取证书 (此处为 CF)docker exec acme.sh --issue --dns dns_cf -d example.com -d www.example.com获取后的证书和存储目录会打印出来，将此目录映射到 nginx 容器可以设置 cron 定时任务以自动更新证书，参考：Linux Crontab 定时任务 - 菜鸟教程参考资料docker获取Let’s Encrypt永久免费SSL证书 - 腾讯云开发者社区-腾讯云 (tencent.com)ZeroSSL.com CA · acmesh-official/acme.sh Wiki (github.com)Nginx创建相应文件夹 (例如 /root/nginx)，然后创建 docker-compose.ymlversion: '3.1' services:   nginx:    restart: always     image: nginx    container_name: nginx    ports:      - 80:80    volumes:      - /root/docker/nginx/conf.d:/etc/nginx/conf.d      - /root/docker/nginx/www:/user/share/nfinx/html      - /root/docker/nginx/log:/var/log/nginx      - /root/acme/acme.sh:/ssl然后运行，启动后当前目录有 conf.d 文件夹，在该文件夹新建以 .conf 为后缀的文件，例如 default.confserver {    listen          80;    listen          [::]:80;    server_name     &lt;your_server_name&gt;;    rewrite ^(.*)$  https://$host$1 permanent;}map $http_upgrade $connection_upgrade {    default upgrade;    ''      close;}server {    listen  443       ssl http2;    listen  [::]:443  ssl http2;    server_name         &lt;your_server_name&gt;;\t# ssl 证书位置    ssl_certificate     /path/to/ssl_cert;    # ssl 密钥位置    ssl_certificate_key /path/to/ssl_cert_key;    location / {        proxy_set_header    Host                $host;        proxy_set_header    X-Real-IP           $remote_addr;        proxy_set_header    X-Forwarded-For     $proxy_add_x_forwarded_for;        proxy_set_header    X-Forwarded-Proto   $scheme;        proxy_http_version  1.1;        proxy_set_header    Upgrade             $http_upgrade;        proxy_set_header    Connection          $connection_upgrade;        proxy_pass          http://172.17.0.1:9000/;    }}参考资料docker安装nginx并配置ssl证书，代理宿主机服务_Blueeyedboy521的博客-CSDN博客_bitwarden docker sslNginx 安装 SSL 配置 HTTPS 超详细完整全过程-阿里云开发者社区 (aliyun.com)快速部署 Docker 同时发布多个网站或服务_天道酬勤~的博客-CSDN博客_docker部署 一台服务器多个系统Let’s Encrypt 使用教程，免费的SSL证书，让你的网站拥抱 HTTPS - Diamond-Blog (diamondfsd.com)Nginx反向代理的一次使用总结 - 简书 (jianshu.com)Nginx配置反向代理隐藏服务端口 - &amp;大飞 - 博客园 (cnblogs.com)参考文章Debian - Docker — 从入门到实践 (gitbook.io)Docker 安装 Wordpress 博客 - 腾讯云开发者社区-腾讯云 (tencent.com)Docker部署WordPress解决“上传的文件尺寸超过php.ini中定义的upload_max_filesize值”问题_neiro-DevPress官方社区 (csdn.net)let’s Encrypt 证书之安装故障 Could not bind to IPv4 or IPv6. - 料网 (liaosam.com)基于Let’s Encrypt生成免费证书-支持多域名泛域名证书 - DevOps在路上 - 博客园 (cnblogs.com)Docker Compose-菜鸟教程 (runoob.com)Nginx配置文件详解 - 程序员自由之路 - 博客园 (cnblogs.com)Docker使用acme.sh申请ssl证书 – 萌精灵 (moeelf.com)docker安装nginx并配置ssl证书，代理宿主机服务"
  },
  
  {
    "title": "软件工程-软件质量与软件工具",
    "url": "/archives/101",
    "categories": "软件工程",
    "tags": "",
    "date": "2023-04-03 19:59:00 +0800",
    





    
    "snippet": "软件工程系列文章六软件质量是指反映软件系统或软件产品满足规定或隐含需求的能力的特征和特性全体软件质量管理是指对软件开发过程进行独立的检查活动，由质量保证、质量规划和质量控制 3 个主要活动构成软件质量保证是指为了保证软件系统或软件产品充分满足用户要求的质量而进行的有计划、有组织的活动，其目的是生产高质量的软件软件质量特性讨论软件质量首先要了解软件的质量特性，目前已经有多种软件质量模型来描述软...",
    "content": "软件工程系列文章六软件质量是指反映软件系统或软件产品满足规定或隐含需求的能力的特征和特性全体软件质量管理是指对软件开发过程进行独立的检查活动，由质量保证、质量规划和质量控制 3 个主要活动构成软件质量保证是指为了保证软件系统或软件产品充分满足用户要求的质量而进行的有计划、有组织的活动，其目的是生产高质量的软件软件质量特性讨论软件质量首先要了解软件的质量特性，目前已经有多种软件质量模型来描述软件质量特性，例如 ISO/IEC 9126 软件质量模型和 Mc Call 软件质量模型ISO/IEC 9126 软件质量模型ISO/IEC 9126 软件质量模型由 3 个层次组成：第一层是质量特性，第二层是质量子特性，第三层是度量指标功能性 (Functionality)与一组功能及其指定的性质的存在有关的一组属性，功能是指满足规定或隐含需求的那些功能  适应性 (Suitability) 。与对规定任务能否提供一组功能以及这组功能是否适合有关的软件属性  准确性 (Accurateness) 。与能够得到正确或相符的结果或效果有关的软件属性  互用性 (Interoperability) 。与其他指定系统进行交互操作的能力相关的软件属性  依从性 (Compliance) 。使软件服从有关的标准、约定、法规及类似规定的软件属性  安全性 (Security) 。与避免对程序及数据的非授权故意或意外访问的能力有关的软件属性可靠性 (Reliability)与在规定的一段时间内和规定的条件下软件维持在其性能水平有关的能力  成熟性 (Maturity) 。与由软件故障引起失效的频度有关的软件属性  容错性 (Fault tolerance) 。与在软件错误或违反指定接口的情况下维持指定的性能水平的能力有关的软件属性  易恢复性 (Recoverability) 。与在故障发生后，重新建立其性能水平并恢复直接受影响数据的能力，以及为达到此目的所需的时间和努力有关的软件属性易使用性 (Usability)与为使用所需的努力和由一组规定或隐含的用户对这样使用所做的个别评价有关的一组属性  易理解性 (Understandability) 。与用户为理解逻辑概念及其应用所付出的劳动有关的软件属性  易学性 (Learnability) 。与用户为学习其应用 (例如操作控制、输入、输出) 所付出的努力相关的软件属性  易操作性 (Operability) 。与用户为进行操作和操作控制所付出的努力有关的软件属性效率 (Efficiency)在规定条件下，与软件的性能水平与所用资源量之间的关系有关的软件属性  时间特性 (Time behavior) 。与响应和处理时间以及软件执行其功能时的吞吐量有关的软件属性  资源特性 (Resource behavior) 。与软件执行其功能时，所使用的资源量以及使用资源的持续时间有关的软件属性可维护性 (Maintainability)与进行规定的修改所需要的努力有关的一组属性  易分析性 (Analyzability) 。与为诊断缺陷或失效原因，或为判定待修改的部分所需努力有关的软件属性  易改变性 (Changeability) 。与进行修改、排错或适应环境变换所需努力有关的软件属性  稳定性 (Stability) 。与修改造成未预料效果的风险有关的软件属性  易测试性 (Testability) 。为确认经修改软件所需努力有关的软件属性可移植性 (Portability)与软件可从某一环境转移到另一环境的能力有关的一组属性  适应性 (Adaptability) 。与软件转移到不同环境时的处理或手段有关的软件属性  易安装性 (Installability) 。与在指定环境下安装软件所需努力有关的软件属性  一致性 (Conformance) 。使软件服从与可移植性有关的标准或约定的软件属性  易替换性 (Replaceability) 。与一软件在该软件环境中用来替代指定的其他软件的可能和努力有关的软件属性Mc Call 软件质量模型Mc Call 软件质量模型从软件产品的运行、修正和转移 3 个方面确定了 11 个质量特性Mc Call 也给出了一个三层模型框架。第一层是质量特性，第二层是评价准则，第三层是度量指标软件评审通常，把 “质量” 理解为 “用户满意程度” 。为了使得用户满意，有以下两个必要条件  设计的规格说明书符合用户的要求，这称为设计质量  程序按照设计规格说明所规定的情况正确执行，这称为程序质量设计质量的评审内容设计质量评审的对象是在需求分析阶段产生的软件需求规格说明、数据需求规格说明，以及在软件概要设计阶段产生的软件概要设计说明书等。通常从以下几个方面进行评审  评价软件的规格说明是否合乎用户的要求，即总体设计思想和设计方针是否明确；需求规格说明是否得到了用户或单位上级机关的批准；需求规格说明与软件的概要设计规格说明是否一致等  评审可靠性，即是否能避免输入异常 (错误或超载等) 、硬件失效及软件失效所产生的失效，一旦发生应能及时采取代替手段或恢复手段  评审保密措施实现情况，即是否对系统使用资格进行检查  评审操作特性实施情况，即操作命令和操作信息的恰当性；输入数据与输入控制语句的恰当性；输出数据的恰当性；应答时间的恰当性等  评审性能实现情况，即是否达到所规定性能的目标值  评审软件是否具有可修改性、可扩充性、可互换性和可移植性  评审软件是否具有可测试性  评审软件是否具有复用性程序质量的评审内容程序质量评审通常是从开发者的角度进行评审，与开发技术直接相关。它是着眼于软件本身的结构、与运行环境的接口以及变更带来的影响而进行的评审活动软件的结构如下  功能结构。需要检查的项目：          数据结构      功能结构      数据结构和功能结构之间的对应关系        功能的通用性  模块的层次  模块结构。模块层次结构是模块的静态结构，现在要检查模块的动态结构。模块分为处理模块和数据模块两类，模块间的动态结构也与这些模块分类有关。对这样的模块结构进行检查的项目如下          控制流结构      数据流结构      模块结构与功能结构之间的对应关系        处理过程的结构与运行环境的接口运行环境包括硬件、其他软件和用户，主要的检查项目如下  与硬件的接口。包括与硬件的接口约定，即根据硬件的使用说明等所做出的规定；硬件故障时的处理和超载时的处理  与用户的接口。包括与用户的接口约定，即输入数据的结构；输出数据的结构；异常输入时的处理，超载输入时的处理；用户存取资格的检查等软件容错技术提高软件质量和可靠性的技术大致可分为两类，一类是避开错误，即在开发的过程中不让差错潜入软件的技术；另一类是容错技术，即对某些无法避开的差错，使其影响减至最小的技术容错软件的定义  规定功能的软件，在一定程度上对自身错误的作用 (软件错误) 具有屏蔽能力，则该软件为容错软件  规定功能的软件，在一定程度上能从错误状态自动恢复到正常状态，则该软件为容错软件  规定功能的软件，在因错误发生错误时仍然能在一定程度上完成预期的功能，则该软件为容错软件  规定功能的软件，在一定程度上具有容错能力，则该软件为容错软件容错的一般方法实现容错的主要手段是冗余。冗余是指对于实现系统规定功能是多余的那部分资源，包括硬件、软件、信息和时间。由于加入了这些资源，有可能使系统的可靠性得到较大的提高。通常，冗余技术分为 4 类  结构冗余。结构冗余是通常采用的冗余技术，按其工作方法可以分为静态、动态和混合冗余 3 种          静态冗余      动态冗余      混合冗余        信息冗余。为检测或纠正信息在运算或传输中的错误需外加一部分信息  时间冗余。指以重复执行指令或程序来消除瞬时错误带来的影响  冗余附加技术。指为实现上述冗余技术所需的资源和技术，包括程序、指令、数据、存放和调动它们的空间和通道等在屏蔽硬件错误的容错技术中，冗余附加技术包括：  关键程序和数据的冗余存储及调用  检测、表决、切换、重构、纠错和复算的实现在屏蔽软件错误的容错系统中，冗余附加技术的构成包括：  冗余备份程序的存储及调用  实现错误检测和错误恢复的程序  实现容错软件所需的固化程序软件工具用来辅助软件开发、运行、维护、管理和支持等过程中的活动的软件称为软件工具软件开发工具对应于软件开发过程的各种活动，软件开发工具通常有需求分析工具、设计工具、编码与排错工具、测试工具等软件维护工具辅助软件维护过程中活动的软件称为软件维护工具，它辅助维护人员对软件代码及其文档进行各种维护活动。软件维护工具主要有版本控制工具、文档分析工具、开发信息库工具、逆向工程工具和再工程工具"
  },
  
  {
    "title": "软件工程-软件项目管理",
    "url": "/archives/100",
    "categories": "软件工程",
    "tags": "",
    "date": "2023-04-02 06:58:00 +0800",
    





    
    "snippet": "软件工程系列文章五软件项目的成功率非常低的原因可能就是项目管理能力太弱。由于软件本身的特殊性及复杂性，将项目管理思想引入软件工程领域，就形成了软件项目管理软件项目管理涉及的范围有效的软件项目管理集中在 4 个 P 上，即人员 (Person) 、产品 (Product) 、过程 (Procedure) 和项目 (Project)软件项目估算软件项目估算涉及人、技术、环境等多种因素，因此，需要...",
    "content": "软件工程系列文章五软件项目的成功率非常低的原因可能就是项目管理能力太弱。由于软件本身的特殊性及复杂性，将项目管理思想引入软件工程领域，就形成了软件项目管理软件项目管理涉及的范围有效的软件项目管理集中在 4 个 P 上，即人员 (Person) 、产品 (Product) 、过程 (Procedure) 和项目 (Project)软件项目估算软件项目估算涉及人、技术、环境等多种因素，因此，需要一些方法和技术来支持项目的估算，常用的估算方法有下列 3 种  基于已经完成的类似项目进行估算  基于分解技术进行估算  基于经验估算模型的估算。典型的有 IBM 估算模型、CoCoMo 模型和 Putnam 模型上述方法可以组合使用，以提高估算的精度COCOMO 估算模型COCOMO 模型是一种精确的、易于使用的成本估算模型。COCOMO 模型按其详细程度分为基本 COCOMO 模型、中级 COCOMO 模型和详细 COCOMO 模型基本 COCOMO 模型基本 COCOMO 模型是一个静态单变量模型，用于对整个软件系统进行估算其公式如下：E=a(L)bD=cEd其中，E 表示工作量，单位是人月；D 表示开发时间，单位是月；L 是项目的源代码行估计值，不包括程序中的注释及文档，其单位是千行代码；a、b、c、d 是常数基本 COCOMO 模型可通过估算代码行的值 L，然后计算开发工作量和开发时间的估算值中级 COCOMO 模型中间 COCOMO 模型是一个静态多变量模型，它将软件系统模型分为系统和部件两个层次，系统由部件构成，它把软件开发所需的人力 (成本) 看作是程序大小和一系列 “成本驱动属性” 的函数中级 COCOMO 模型以基本 COCOMO 模型为基础，并考虑了 15 种影响软件工作量的因素，通过工作量调节因子 (EAF) 修正对工作量的估算，从而使估算更合理其公式如下：E=a(L)bEAF其中，L 是软件产品的目标代码行数，单位是千行代码数；a、b 是常数详细 COCOMO 模型它将软件系统模型分为系统、子系统和模块 3 个层次，除包括中级模型所考虑的因素外，还考虑了在需求分析、软件设计等进一步的成本驱动属性的影响COCOMOII 模型最初的 COCOMO 模型是得到产业界最广泛应用和讨论的软件成本估算模型之一，现在它已经演化成更全面的估算模型，称为 COCOMOII。和其前身一样，COCOMOII 也是一种层次结构的估算模型，被分为 3 个阶段性模型  应用组装模型。在软件工程的前期阶段使用，这时用户界面的原型开发、对软件和系统交互的考虑、性能的评估以及技术成熟度的评价是最重要的  早期设计阶段模型。在需求已经稳定并且基本的软件体系结构已经建立时使用  体系结构阶段模型。在软件的构造过程中使用和所有的软件估算模型一样，COCOMOII 模型也需要使用规模估算信息，在模型层次结构中有 3 中不同的规模估算选择：对象点、功能点和代码行。应用组装模型使用的是对象点；早期设计阶段模型使用的是功能点，功能点可以转换为代码行进度管理软件项目进度管理的目的是确保软件项目在规定的时间内按期完成进度管理的基本原则  划分  相互依赖性  时间分配  工作量确认  确定责任  明确输出结果  确定里程碑进度安排进度安排的常用图形描述方法有 Gantt 图 (甘特图) 和项目计划评审技术 (Program Evaluation &amp; Review Technique, PERT) 图Gantt 图Gantt 图是一种简单的水平条形图，它以日历为基准描述项目任务。水平轴表示日历时间线 (如时、天、周、月和年等) ，每个条形表示一个任务，任务名称垂直地列在左边的列中，图中水平条的起点和终点对应水平轴上的时间，分别表示该任务的开始时间和结束时间，水平条的长度表示完成该任务所持续的时间。当日历中同一时段存在多个水平条时，表示任务之间的并发Gantt 图能清晰地描述每个任务从何时开始，到何时结束，任务的进展情况以及各个任务之间的并行性。但是它不能清晰地反映出各任务之间的依赖关系，难以确定整个项目的关键所在，也不能反映计划中有潜力的部分PERT 图PERT 图是一个有向图，图中的箭头表示任务，它可以标上完成该任务所需的时间。图中的结点表示流入结点的任务的结束，并开始流出结点的任务，这里把结点称为事件。只有当流入该结点的所有任务都结束时，结点所表示的事件才出现，流出结点的任务才可以开始。事件本身不消耗时间和资源，它仅表示某个时间点一个事件有一个事件号和出现该事件的最早时刻和最迟时刻。最早时刻表示在此时刻之前从该事件出发的任务不可能开始；最迟时刻表示从该事件出发的任务必须在此时刻之前开始，否则整个工程就不能如期完成。每个任务还可以有一个松弛时间 (Slack Time) ，表示在不影响整个工期的前提下完成该任务有多少机动余地PERT 图不仅给出了每个任务的开始时间、结束时间和完成该任务所需的时间，还给出了任务之间的关系，即哪些任务完成后才能开始另外一些任务，以及如期完成整个工程的关键路径。图中的松弛时间 (最迟时刻 - 最早时刻) 则反应了完成某些任务时可以推迟其开始时间或延长其所需完成的时间。但是，PERT 图不能反映任务之间的并行关系软件配置管理软件配置管理其主要目标包括： 变更标识、变更控制、版本控制、确保变更正确的实现、变更报告软件配置管理其主要内容包括：版本管理、配置支持、变更支持、过程支持、团队支持、变化报告、审计支持或者：软件配置标识、变更管理、版本控制、系统建立、配置审核、配置状态报告配置数据库可以分为以下三类：  开发库。专供开发人员使用，其中的信息可能做频繁修改，对其控制相对宽松  受控库。在生存期某一阶段工作结束时发布的阶段产品，这些是与软件开发工作相关的计算机可读信息和人工可读信息。软件配置管理正是对受控库中的各个软件项进行管理，受控库也称为软件配置库  产品库。在开发的软件产品完成系统测试后，作为最终产品存入产品库，等待交付用户或现场安装风险管理一般认为软件风险包含两个特性：不确定性和损失。不确定性是指风险可能发生也可能不发生；损失是指如果风险发生，就会产生恶性后果。在进行风险分析时，重要的是量化每个风险的不确定程度和损失程度。为了实现这一点，必须考虑不同类型的风险项目风险威胁到项目计划。也就是说，如果项目风险发生，就有可能拖延项目的进度和增加项目成本。项目风险是指预算、进度、人员 (聘用职员及组织) 、资源、利益相关者、需求等方面的潜在问题以及它们对软件项目的影响。项目复杂度、规模及结构不确定性也属于项目风险因素技术风险威胁到要开发软件的质量及交付时间。如果技术风险发生，开发工作就可能变得很困难或根本不可能，技术风险是指设计、实现、接口、验证和维护等方面的潜在问题。此外，规格说明的歧义性、技术的不确定性、技术陈旧以及 “前沿” 技术也是技术风险因素。技术风险地发生是因为问题比我们所设想地更加难以解决商业风险威胁到要开发软件地生存能力，且常常会危害到项目或产品。5 个主要的商业风险如下：  市场风险。开发了一个没有人真正需要的优良产品  策略风险。开发的产品不再符合公司的整体商业策略  销售风险。开发了一个销售部门不知道如何去销售的产品  管理风险。由于重点的转移或人员的变动而失去了高级管理层的支持  预算风险。没有得到预算或人员的保证(一) 风险识别风险识别试图系统化地指出对项目计划 (估算、进度、资源分配等) 地威胁。识别出已知风险和可预测风险后，项目管理者首先要做的是在可能时回避这些风险，在必要时控制这些风险识别风险的一种方法是建立风险条目检查表。该检查表可用于风险识别，并且主要用来识别下列几种类型中的一些已知风险和可预测风险  产品规模。与要开发或要修改的软件的总体规模相关的风险  商业影响。与管理者或市场所施加的约束相关的风险  客户特性。与客户的素质以及开发者和客户定期沟通的能力相关的风险  过程定义。与软件过程定义的程度以及该过程被开发组织遵守的程度相关的风险  开发环境。与用来开发产品的工具的可得性及质量相关的风险  开发技术。与待开发软件的复杂性及系统所包含技术的 “新奇性” 相关的风险  人员才干及经验。与软件工程师的总体技术水平及项目经验相关的风险风险条目检查表可以采用不同的方式来组织。与上述每个主题相关的问题可以针对每一个软件项目来回答。根据这些问题的答案，项目管理者就可以估计风险产生的影响当然，也可以采用另一种风险条目检查表格式，即仅仅列出与每一种类型有关的特性，最终给出一组风险因素和驱动因子以及它们发生的概率。风险因素包括性能、成本、支持和进度。风险因素是以如下方式定义的：  性能风险。产品能够满足需求且符合其使用目的的不确定程度  成本风险。能够维持项目预算的不确定程度  支持风险。开发出的软件易于纠错、修改及升级的不确定程度  进度风险。能够维持项目进度且按时交付产品的不确定程度(二) 风险预测风险预测又称风险估计，它试图从两个方面评估一个风险：风险发生的可能性或概率；如果风险发生了所产生的后果(1) 风险预测活动通常，项目计划人员与管理人员、技术人员一起进行以下 4 步风险预测活动  建立一个尺度或标准，以反映风险发生的可能性  描述风险产生的后果  估算风险对项目和产品的影响  标注风险预测的整体精确度，以免产生误解一种简单的风险预测技术是建立风险表。风险表的第 1 列列出所有的风险 (由风险识别活动得到) ，第 2-4 列列出每个风险的种类、发生的概率以及所产生的影响。风险所产生的影响可用一个数字来表示：”1” 表示灾难性的；”2” 表示严重的；”3” 表示轻微的；”4” 表示可忽略的(2) 评估风险影响如果风险真的发生，有 3 个因素可能会影响风险所产生的后果，即风险的本质、范围和时间。风险的本质是指当风险发生时可能会带来的问题。例如，一个定义很差的与客户硬件的外部接口 (技术风险) 会妨碍早期的设计和测试，也有可能导致项目后期阶段的系统集成问题。风险的范围包括风险的严重性 (即风险有多严重) 及风险的整体分布情况 (即项目中有多少部分受到影响或有多少客户受到损害) 。风险的时间是指何时能够感受到风险的影响及风险的影响会持续多长时间。在大多数情况下，项目管理者希望 “坏消息” 越早出现越好，但在某些情况下则是越迟越好整体的风险显露度 (Risk Exposure, RE) 可由下面的关系确定：RE=P×C其中，P 是风险发生的概率，C 是风险发生时带来的项目成本(三) 风险评估在进行风险评估时，建立了如下形式的三元组：(Ri, li, xi)其中，ri 表示风险，li 表示风险发生的概率，xi 表示风险产生的影响一种对风险评估很有用的技术就是定义风险参考水准。对于大多数软件项目来说，成本、进度和性能就是 3 种典型的风险参照水准。也就是说，对于成本超支、进度延期、性能降低 (或它们的某种组合) ，有一个表明导致项目终止的水准在风险评估过程中，需要执行以下 4 个步骤  定义项目的风险参考水平值  建立每一组 (Ri, li, xi) 与每一个参考水平值之间的关系  预测一组临界点以定义项目终止区域，该区域由一条曲线或不确定区域所界定  预测什么样的风险组合会影响参考水平值(四) 风险控制风险控制的目的是辅助项目组建立处理风险的策略。一个有效的策略必须考虑以下 3 个问题(1) 风险避免应对风险的最好方法是主动地避免风险，即在风险发生前分析引起风险的原因，然后采取措施，以避免风险的发生例如项目风险 ri 表示 “频繁的人员流动”，根据历史经验可知，该风险发生的概率 li 大约为 70%，该风险产生的影响 xi 是第 2 级 (严重的) 。为了避免该风险，可以采取以下策略  与现有人员一起探讨人员流动原因 (如恶劣的工作条件、低报酬、竞争激烈的劳动力市场等)  在项目开始之前采取行动，设法缓解那些能够控制的起因  项目启动之后，假设会发生人员流动，当有人员离开时，找到能够保证工作连续性的方法  组织项目团队，使得每一个开发活动的信息都能被广泛传播和交流  制定工作产品标准，并建立相应机制以确保能够及时创建所有的模型和文档  同等对待所有工作的评审  给每一个关键的技术人员都指定一个后背人员(2) 风险监控项目管理者应监控某些因素，这些因素可以提供风险是否正在变高或变低的指示。在频繁的人员流动的例子中，应该监测团队成员对项目压力的普遍态度、团队的凝聚力、团队成员彼此之间的关系、与报酬和利益相关的潜在问题、在公司内及公司外工作的可能性(3) RMMM 计划风险管理策略可以包含在软件项目计划中，或者风险管理步骤也可以组织成一个独立的风险缓解、监控和管理计划 (RMMM 计划) 。RMMM 计划将所有风险分析工作文档化，并由项目管理者作为整个项目计划中的一部分来使用建立了 RMMM 计划，而且项目已经启动之后，风险缓解及检测步骤也就开始了。风险缓解是一种问题规避活动，而风险检测是一种项目跟踪活动，这种监测活动有 3 个主要目的；评估所预测的风险是否真的发生了；保证正确地实施了个风险的缓解步骤；收集能够用于今后风险缝隙的信息。在很多情况下，项目中发生的问题可以追溯到不止一个风险，所以风险监测的另一个任务就是试图找到 “起源” (在整个项目中是哪些风险引起了哪些问题)"
  },
  
  {
    "title": "软件工程-系统维护概述",
    "url": "/archives/99",
    "categories": "软件工程",
    "tags": "",
    "date": "2023-03-31 07:57:00 +0800",
    





    
    "snippet": "软件工程系列文章四软件维护是软件生命周期的最后一个阶段，处于系统投入生产性运行之后的时期中，因此不属于系统开发过程。软件维护是在软件已经交付使用之后为了改正错误或满足新的需求而修改软件的过程，即软件在交付使用后对软件所做的一切改动系统可维护性概念系统的可维护性可以定义为维护人员理解、改正、改动和改进这个软件的难易程度。提高可维护性是开发软件系统所有步骤的关键目的，系统是否能被很好地维护，可以...",
    "content": "软件工程系列文章四软件维护是软件生命周期的最后一个阶段，处于系统投入生产性运行之后的时期中，因此不属于系统开发过程。软件维护是在软件已经交付使用之后为了改正错误或满足新的需求而修改软件的过程，即软件在交付使用后对软件所做的一切改动系统可维护性概念系统的可维护性可以定义为维护人员理解、改正、改动和改进这个软件的难易程度。提高可维护性是开发软件系统所有步骤的关键目的，系统是否能被很好地维护，可以用系统的可维护性这一指标来衡量系统可维护指标  可理解性。指别人能理解系统的结构、界面、功能和内部过程的难易程度。模块化、详细设计文档、结构化设计和良好的高级程序设计语言等都有助于提高可理解性  可测试性。诊断和测试的容易程度取决于易理解的程度。好的文档资料有利于诊断和测试，同时，程序的结构、高性能的测试工具以及周密计划的测试工序也是至关重要的。为此，开发人员在系统设计和编程阶段就应尽力把程序设计成易诊断和测试的。此外，在进行系统维护时，应该充分利用在系统测试阶段保存下来的测试用例  可修改性。诊断和测试的容易程度与系统设计所制定的设计原则有直接关系。模块的耦合、内聚、作用范围与控制范围的关系等都对可修改性有影响维护与软件文档文档是软件可维护性的决定因素。由于长期使用的大型软件系统在使用过程中必然会经受多次修改，所以文档显得非常重要软件系统的文档可以分为用户文档和系统文档两类。用户文档主要描述系统功能和使用方法，并不关心这些功能是怎样实现的；系统文档描述系统设计、实现和测试等各方面的内容可维护性是所有软件都应具有的基本特点，必须在开发阶段保证软件具有可维护性的特点。在软件工程的每一个阶段都应考虑并提高软件的可维护性，在每个阶段结束前的技术审查和管理复查中应该着重对可维护性进行复审软件文档编写高质量文档可以提高软件开发的质量文档也是软件的一部分，没有文档的软件就不能称之为软件软件文档的编制在软件开发工作中占有突出的地位和相当大的工作量，高质量的文档对于软件产品的效益有着重要的意义系统维护的内容及类型系统维护主要包括硬件维护、软件维护和数据维护硬件维护硬件维护应由专职的硬件维护人员来负责软件维护软件维护主要是根据需求变化或硬件环境的变化对应用程序进行部分或全部修改。修改时充分利用源程序，修改后要填写程序修改登记表，并在程序变更通知书上写明新旧程序的不同之处软件维护的内容一般有以下几个方面  正确性维护。指改正在系统开发阶段已发现而系统测试阶段尚未发现的错误  适应性维护。指使应用软件适应信息技术变化和管理需求变化而进行的修改  完善性维护。是为扩充功能和改善性能而进行的修改，主要是指对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征  预防性维护。为了改进应用软件的可靠性和可维护性，为了适应未来的软硬件环境的变化，应主动增加预防性的新的功能，以使应用系统适应各类变化而不被淘汰数据维护数据维护工作主要是由数据库管理员来负责，主要负责数据库的安全性和完整性以及进行并发性控制软件的质量属性可靠性、可用性和可维护性是软件的质量属性，软件工程中，用 0-1 之间的数来度量可靠性是指一个系统对于给定的时间间隔内、在给定条件下无失效运作的概率。可以用 MTTF/(1+MTTF) 来度量，其中 MTTF 为平均无故障时间可用性是在给定的时间点上，一个系统能够按照规格说明正确运作的概率。可以用 MTBF/(1+MTBF) 来度量，其中 MTBF 为平均失效间隔时间可维护性是在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率。可以用 1/(1+MTTR) 来度量，其中 MTTR 为平均修复时间"
  },
  
  {
    "title": "软件工程-系统测试",
    "url": "/archives/98",
    "categories": "软件工程",
    "tags": "",
    "date": "2023-03-29 19:56:57 +0800",
    





    
    "snippet": "软件工程系列文章三系统测试的意义、目的及原则系统测试是为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试测试的目的就是希望能以最少的人力和时间发现潜在的各种错误和缺陷。用户应根据开发各阶段的需求、设计等文档或程序的内部结构精心设计测试用例，并利用这些实例来运行程序，以便发现错误的过程信息系统测试应包括软件测试、硬件测试和网络测试。硬件测试、网络测试可以根据具体的性能指标...",
    "content": "软件工程系列文章三系统测试的意义、目的及原则系统测试是为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试测试的目的就是希望能以最少的人力和时间发现潜在的各种错误和缺陷。用户应根据开发各阶段的需求、设计等文档或程序的内部结构精心设计测试用例，并利用这些实例来运行程序，以便发现错误的过程信息系统测试应包括软件测试、硬件测试和网络测试。硬件测试、网络测试可以根据具体的性能指标进行，此处所说的测试更多的是指软件测试系统测试是保证系统质量和可靠性的关键步骤，是对系统开发过程中的系统分析、系统设计和实施的最后复查。根据测试的概念和目的，在进行信息系统测试时应遵循以下基本原则  应尽早并不断地进行测试。测试不是在应用系统开发完之后才进行的。由于原始问题的复杂性、开发各阶段的多样性以及参加人员之间的协调等因素，使得在开发的各个阶段都有可能出现错误。因此，测试应贯穿在开发的各个阶段，应尽早纠正错误，消除隐患  测试工作应该避免由原开发软件的人或小组承担，一方面，开发人员往往不愿否认自己的工作，总认为自己开发的软件没有错误；另一方面，开发人员的错误很难由本人测试出来，很容易根据自己编程的思路来制定测试思路，具有局限性，测试工作应由专门人员来进行，这样会更客观、更有效  在设计测试方案时，不仅要确定输入数据，而且要根据系统功能确定预期输出结果。将实际输出结果与预期结果相比较就能发现测试对象是否正确  在设计测试用例时，不仅要设计有效、合理的输入条件，也要包含不合理、失效的输入条件。在测试的时候，人们往往习惯按照合理的、正确的情况进行测试，而忽略了对异常、不合理、意想不到的情况进行测试，而这可能就是隐患  在测试程序时，不仅要检验程序是否做了该做的事，还要检验程序是否做了不该做的事。多余的工作会带来副作用，影响程序的效率，有时会带来潜在的危害或错误  严格按照测试计划来进行，避免测试的随意性。测试计划应包括测试内容、进度安排、人员安排、测试环境、测试工具和测试资料等。严格地按照测试计划可以保证进度，使各方面都得以协调进行  妥善保存测试计划、测试用例，作为软件文档地组成部分，为维护提供方便  测试例子都是精心设计出来的，可以为重新测试或追加测试提供方便。当纠正错误、系统功能扩充后，都需要重新开始测试，而这些工作的重复性很高，可以利用以前的测试用例或在其基础上修改，然后进行测试系统测试阶段的测试目标来自于需求分析阶段传统软件的测试策略有效的软件测试实际上分为 4 步进行，即单元测试、集成测试、确认测试和系统测试(一) 单元测试单元测试也称为模块测试，在模块编写完成且无编译错误后就可以进行。单元测试侧重于模块中的内部处理逻辑和数据结构。如果选用机器测试，一般用白盒测试法。这类测试可以对多个模块同时进行(1) 单元测试的测试内容单元测试主要检查模块的以下 5 个特征  模块接口。模块的接口保证了测试模块的数据流可以正确地流入、流出。在测试中应检查以下要点：          测试模块的输入参数和形式参数在个数、属性、单位上是否一致      调用其他模块时，所给出的实际参数和被调用模块的形式参数在个数、属性、单位上是否一致      调用标准函数时，所用的参数在属性、数目和顺序上是否正确      全局变量在各模块中的定义和用法是否一致      输入是否仅改变了形式参数      开/关的语句是否正确      规定的 I/O 格式是否与输入/输出语句一致      在使用文件之前是否已经打开文件或使用文件之后是否已经关闭文件        局部数据结构。在单元测试中，局部数据结构出错是比较常见的错误，在测试时应重点考虑以下因素          变量的说明是否合适      是否使用了尚未赋值或尚未初始化的变量      变量的初始值或默认值是否正确      变量名是否有错 (例如拼写错)        重要的执行路径。在单元测试中，对路径的测试是最基本的任务。由于不能进行穷举测试，需要精心设计测试例子来发现是否有计算、比较或控制流等方面的错误          计算方面的错误。算术运算的优先次序不正确或理解错误；精度不够；运算对象的类型彼此不相容；算法错；表达式的符号表示不正确      比较和控制流的错误。本应相等的量由于精度造成不相等；不同类型进行比较；逻辑运算符不正确或优先次序错误；循环终止不正确 (如多循环一次或少循环一次) 、死循环；不恰当地修改循环变量；当遇到分支循环时出口错误等        出错处理。好的设计应该能预测到出错的条件并且有对出错处理的路径。虽然计算机可以显示出错信息的内容，但仍需要程序员对出错进行处理，保证其逻辑的正确性，以便于用户维护  边界条件。边界条件的测试是单元测试的最后工作，也是非常重要的工作。软件容易在边界出现错误(2) 单元测试过程由于模块不是独立运行的程序，各模块之间存在调用与被调用的关系。在对每个模块进行测试时，需要开发两种模块  驱动模块。相当于一个主程序，接受测试例子的数据，将这些数据送到测试模块，输出测试结果  桩模块 (也称为存根模块) 。桩模块用来代替测试模块中所调用的子模块，其内部可进行少量的数据处理，目的是为了检验入口，输出调用和返回的信息提高模块的内聚度可以简化单元测试。如果每个模块只完成一种功能，对于具体模块来讲，所需的测试方案数据会显著减少，而且更容易发现和预测模块中的错误(二)集成测试集成测试就是把模块按系统设计说明书的要求组合起来进行测试。即使所有的模块都通过了测试，在集成之后，仍然可能出现问题通常，集成测试有两种方法：一种是非增量集成，分别测试各个模块，再把这些模块组合起来整体测试；另一种是增量集成，即以小增量的方式逐步进行构造和测试下面是一些增量集成策略(1) 自顶向下集成测试自顶向下集成测试是一种构造软件体系结构的增量方法。模型的集成顺序为从主控模块 (主程序) 开始，沿着控制层次逐步向下，以深度优先或广度优先的方式将从属于 (或间接从属于) 主控模块的模块集成到结构中深度优先集成是首先集成位于程序结构中主控路径上的所有构件，也可以根据特定应用系统的特征进行选择  主控模块用作测试驱动模块，用这些从属于主控模块的所有模块代替桩模块  依赖所选择的集成方法 (即深度优先或广度优先) ，每次用实际模块替换一个从属桩模块  在集成每个模块后都进行测试  在完成每个测试集之后，用实际模块替换另一个桩模块  可以执行回归测试，以确保没有引入新的错误  回到第 2 步继续执行此过程，直到完成了整个程序结构的构造不用编写驱动模块，需要编写桩模块(2) 自底向上集成测试自底向上集成测试就是从原子模块 (程序结构的最底层构件) 开始进行构造和测试。由于构件是自底向上集成的，在处理时所需要的从属于给定层次的模块总是存在的，因此，没有必要使用桩模块。自底向上集成策略可以利用以下步骤来实现  连接底层构件以构成完成特定子功能的簇  编写驱动模块 (测试的控制程序) 以协调测试用例的输入和输出  测试簇  去掉驱动程序，沿着程序结构向上逐步连接簇不需要编写桩模块，需要编写驱动模块(3) 回归测试每当加入一个新模块作为集成测试的一部分时，软件发生变更，建立了新的数据流路径，可能出现新的 I/O，以及调用新的控制逻辑。这些变更可能会使原来可以正常工作的功能产生问题。在集成测试策略的环境下，回归测试是重新执行已测试过的某些子集，以确保变更没有传播不期望的副作用回归测试有助于保证变更不引入无意识行为或额外的错误。回归测试可以手工进行，方法是重新执行所有测试用例的子集，或者利用捕捉/回放工具自动执行。捕捉/回放工具使软件工程师能够为后续的回放与比较捕捉测试用例和测试结果。回归测试要执行的测试子集包含以下 3 种测试用例  能够测试软件所有功能的具有代表性的测试样本  额外测试，侧重于可能会受变更影响的软件功能  侧重于已发生变更的软件构件测试随着集成测试的进行，回归测试的数量可能变得相当庞大，因此，应将回归测试用例设计成只包括设计每个主要程序功能的一个或多个错误类的测试。一旦发生变更，对每个软件功能重新执行所有的测试是不切实际的，而且效率很低(4) 冒烟测试当开发软件产品时，冒烟测试是一种常见的集成测试方法，是时间关键项目的决定性机制，它让软件团队频繁地对项目进行评估测试方法在软件测试过程中，应该为定义软件测试模板，即将特定的测试方法和测试用例设计放在一系列的测试步骤中软件测试方法分为静态测试和动态测试  静态测试。静态测试是指被测试程序不在机器上运行，而是采用人工检测和计算机辅助静态分析的手段对程序进行检测          人工检测。人工检测不依靠计算机而是依靠人工审查程序或评审软件，包括代码检查、静态结构分析和代码质量度量等      计算机辅助静态分析。利用静态分析工具对被测试程序进行特性分析，从程序中提取一些信息，以便检查程序逻辑的各种缺陷和可疑的程序构造        动态测试。动态测试是指通过运行程序发现错误。在对软件产品进行动态测试时可以采用黑盒测试法和白盒测试法测试用例由测试输入数据和与之对应的预期输出结果组成。在设计测试用例时，应当包括合理的输入条件和不合理的输入条件(一) 黑盒测试黑盒测试也称为功能测试，在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性常见的黑盒测试技术有等价类划分、边界值分析、错误推测和因果图等(1) 等价类划分等价类划分将程序的输入域划分为若干等价类，然后从每个等价类中选取 一个代表性数据作为测试用例。每一类的代表性数据在测试中的作用等价于这一类中的其他值，这样就可以用少量代表性的测试用例取得较好的测试效果。等价类型划分有两种不同的情况：有效等价类和无效等价类。在设计测试用例时，要同时考虑这两种等价类(2) 边界值分析输入的边界比中间更加容易发生错误，因此用边界值分析来补充等价类划分的测试用例设计技术。边界值划分选择等价类边界的测试用例，即注重于输入条件边界，又适用于输出域测试用例(3) 错误推测错误推测是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性地设计测试用例的方法。其基本思想是列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例(4) 因果图因果图法是从自然语言描述的程序规格说明中找出因 (输入条件) 和果 (输出或程序状态的改变) ，通过因果图转换为判定表(二) 白盒测试白盒测试也称为结构测试，根据程序的内部结构和逻辑来设计测试用例，对程序的路径和过程进行测试，检查是否满足设计的需要白盒测试常用的技术是逻辑覆盖、循环覆盖和基本路径测试白盒测试的原则如下：  程序模块中的所有独立路径至少执行一次  在所有的逻辑判定中，取 “真” 和取 “假” 的两种情况至少都能执行一次  每个循环都应在边界条件和一般条件下各执行一次  测试程序内部数据结构的有效性等(1) 逻辑覆盖逻辑覆盖考察用测试数据运行被测程序时对程序逻辑的覆盖程度，主要的逻辑覆盖标准有语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖 6 种  语句覆盖。语句覆盖是指选择足够的测试数据，使被测试程序中的每条语句至少执行一次。语句覆盖对程序执行逻辑的覆盖很低，因此一般认为它是很弱的逻辑覆盖  判定覆盖。判定覆盖是指设计足够的测试用例，使得被测程序中的每个判定表达式至少获得一次 “真” 值和 “假” 值，或者说是程序中的每一个取 “真” 分支和取 “假” 分支至少都通过一次，因此判定覆盖也称为分支覆盖。判定覆盖要比语句覆盖更强一些  条件覆盖。条件覆盖是指构造一组测试用例，使得每一判定语句中每个逻辑条件的各种可能的值至少满足一次  判定/条件覆盖。判定/条件覆盖是指设计足够的测试用例，使得判定中每个条件的所有可能取值 (真/假) 至少出现一次，并使每个判定本身的判定结果 (真/假) 也至少出现一次  条件组合覆盖。条件组合覆盖是指设计足够的测试用例，使得每个判定中条件的各种可能值的组合都至少出现一次。满足条件组合覆盖的测试用例是一定满足判定覆盖、条件覆盖和判定/条件覆盖的  路径覆盖。路径覆盖是指覆盖被测试程序中所有可能的路径(2) 循环覆盖执行足够的测试用例，使得循环中的每个条件都得到验证(3) 基本路径测试基本路径测试法是在程序控制流图的基础上通过分析控制流图的环路复杂性，导出基本可执行路径集合，从而设计测试用例调试调试发生在测试之后，其任务是根据测试时所发现的错误找出原因和具体的位置，进行改正常用的调试方法有以下几种(1) 试探法调试人员分析错误的症状，猜测问题所在的位置，利用在程序中设置输出语句，分析寄存器、存储器的内容等手段获得错误的线索，一步步地试探和分析错误的所在(2) 回溯法调试人员从发现错误症状的位置开始，人工沿着程序的控制流程往回跟踪代码，直到找出错误根源为止(3) 对分查找法这种方法主要用来缩小错误的范围，如果已经知道程序中的变量在若干位置的正确取值，可以在这些位置上给这些变量以正确值，观察程序运行的输出结果，如果没有发现问题，则说明从赋予变量一个正确值开始到输出结果之间的程序没有错误，问题可能在除此之外的程序中。否则错误就在所考察的这部分程序中，对含有错误的程序段再使用这种方法，直到把故障范围缩小到比较容易诊断为止(4) 归纳法归纳法就是从测试所暴露的问题出发，收集所有正确或不正确的数据，分析它们之间的关系，提出假想的错误原因，用这些数据来证明或反驳，从而查出错误所在(5) 演绎法演绎法根据测试结果，列出所有可能的错误原因；分析已有的数据，排除不可能和彼此矛盾的原因；对其余的原因，选择可能性最大的，利用已有的数据完善该假设，使假设更具体；用假设来解释所有的原始测试结果，如果能解释这一切，则假设得以证实，也就找出错误"
  },
  
  {
    "title": "软件工程-需求分析与系统设计",
    "url": "/archives/97",
    "categories": "软件工程",
    "tags": "",
    "date": "2023-03-29 17:04:45 +0800",
    





    
    "snippet": "软件工程系列文章二软件生存周期  可行性分析与项目开发计划  需求分析  概要设计  详细设计  编码  测试  维护软件需求在进行需求获取之前，首先要明确需要获取什么，也就是需求包含哪些内容。软件需求是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望  功能需求。考虑系统要做什么，在何时做，在何时以及如何修改或升级  性能需求。考虑软件开发的技术性指标。例如，存储容量限制、执行...",
    "content": "软件工程系列文章二软件生存周期  可行性分析与项目开发计划  需求分析  概要设计  详细设计  编码  测试  维护软件需求在进行需求获取之前，首先要明确需要获取什么，也就是需求包含哪些内容。软件需求是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望  功能需求。考虑系统要做什么，在何时做，在何时以及如何修改或升级  性能需求。考虑软件开发的技术性指标。例如，存储容量限制、执行速度、响应时间及吞吐量  用户或人的因素。考虑用户的类型。例如，各种用户对使用计算机的熟练程度，需要接受的训练，用户理解、使用系统的难度，用户错误操作系统的可能性等  环境需求。考虑未来软件应用的环境，包括硬件和软件。对硬件设备的需求包括机型、外设、接口、地点、分布、湿度、磁场干扰等；对软件的需求包括操作系统、网络、数据库等  界面需求。考虑来自其他系统的输入，到其他系统的输出，对数据格式的特殊规定，对数据存储介质的规定  文档需求。考虑需要哪些文档，文档针对哪些读者  数据需求。考虑输入、输出数据的格式，接收、发送数据的频率，数据的准确性和精度，数据流量，数据需保持的时间  资源使用需求。考虑软件运行时所需要的数据、其他软件、内存空间等资源；软件开发、维护所需的人力、支撑软件、开发设备等  安全保密要求。考虑是否需要对访问系统或系统信息加以控制，隔离用户数据的方法，用户程序如何与其他程序和操作系统隔离以及系统备份要求等  可靠性要求。考虑系统的可靠性要求，系统是否必须检测和隔离错误；出错后，重启系统允许的时间  软件成本消耗与开发进度需求。考虑开发是否有规定的时间表，软/硬件投资有无限制等  其他非功能性要求。如采用某种开发模式，确定质量控制标准、里程碑和评审、验收标准、各种质量要求的优先级等，以及可维护性方面的要求系统设计系统设计的主要目的就是为系统指定蓝图，在各种技术和实施方法中权衡利弊，精心设计，合理地使用各种资源，最终勾画出新系统的详细设计方案概要设计开发人员把确定的各项功能需求转换成需要的体系结构1. 设计软件系统总体结构其基本任务是采用某种设计方法，将一个复杂的系统按功能划分为模块；确定每个模块的功能；确定模块之间的调用关系；确定模块之间的接口，即模块之间传递的信息；评价模块结构的质量软件系统总体结构的设计是概要设计关键的一步，直接影响到下一个阶段详细设计与编码的工作。软件系统的质量及一些整体特性都在软件系统总体结构的设计中决定2. 数据结构及数据库设计(1) 数据结构的设计逐步细化的方法也适用于数据结构的设计。在需求分析阶段，已经通过数据字典对数据的组成、操作约束和数据之间的关系等方面进行了描述，确定了数据的结构特性，在概要设计阶段要加以细化，详细设计阶段则规定具体的实现细节。在概要设计阶段，宜使用抽象的数据类型(2) 数据库的设计数据库的设计是指数据存储文件的设计，主要进行以下几方面设计  概念设计。在数据分析的基础上，采用自底向上的方法从用户角度进行视图设计，一般用 E-R 模型来表述数据模型。E-R 模型既是设计数据库的基础，也是设计数据结构的基础  逻辑设计。E-R 模型是独立于数据库管理系统 (DBMS) 的，要结合具体的 DBMS 特征来建立数据库的逻辑结构  物理设计。对于不同的 DBMS，物理环境不同，提供的存储结构与存取方法各不相同。物理设计就是设计数据模式的一些物理细节，如数据项存储要求、存取方法和索引的建立等3. 编写概要设计文档文档主要有概要设计说明书、数据库设计说明书、用户手册以及修订测试计划4. 评审对设计部分是否完整地实现了需求中规定的功能、性能等要求，设计方法的可行性，关键的处理及内外部接口定义的正确性、有效性、各部分之间的一致性等都一一进行评审详细设计  对每个模块进行详细的算法设计，用某种图形、表格和语言等工具将每个模块处理过程的详细算法描述出来  对模块内的数据结构进行设计  对数据库进行物理设计，即确定数据库的物理结构  其他设计。根据软件系统的类型，还可能要进行以下设计          代码设计。为了提高数据的输入、分类、存储和检索等操作，节约内存空间，对数据库中某些数据项的值要进行代码设计      输入/输出格式设计      用户界面设计        编写详细设计说明书  评审。对处理过程的算法和数据库的物理结构都要评审系统设计的结果是一系列的系统设计文件，这些文件是物理实现一个信息系统 (包括硬件设备和编制软件程序) 的重要基础"
  },
  
  {
    "title": "软件工程-软件过程与软件过程模型",
    "url": "/archives/96",
    "categories": "软件工程",
    "tags": "",
    "date": "2023-03-28 15:45:47 +0800",
    





    
    "snippet": "软件工程系列文章一软件过程软件开发的中所遵循的线路图称为 “软件过程”能力成熟度模型 (CMM)CMM 将软件过程改进分为以下 5 个成熟度级别  初始级 (Initial)​\t软件的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤，项目的完成完全依赖个人的努力和英雄式核心人物的作用  可重复级 (Repeatable)​\t建立了基本的项目管理过程和实践来跟踪项目的费用、进度和功能特性...",
    "content": "软件工程系列文章一软件过程软件开发的中所遵循的线路图称为 “软件过程”能力成熟度模型 (CMM)CMM 将软件过程改进分为以下 5 个成熟度级别  初始级 (Initial)​\t软件的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤，项目的完成完全依赖个人的努力和英雄式核心人物的作用  可重复级 (Repeatable)​\t建立了基本的项目管理过程和实践来跟踪项目的费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功  已定义级 (Defined)​\t管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件  已管理级 (Managed)​\t制定了软件过程和产品质量的详细度量标准。软件过程的产品质量都被开发组织的成员所理解和控制  优化级 (Optimized)​\t加强了定量分析，通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进CMM 模型提供了一个框架，将软件过程改进的进化步骤组织成 5 个成熟度等级，为过程不断改进奠定了循序渐进的基础。这 5 个成熟度等级定义了一个有序的尺度，用来测量一个组织的软件过程成熟度和评价其软件过程能力能力成熟度模型集成 (CMMI)CMM 的成功导致了适用不同学科领域的模型的衍生，但一个工程常常涉及多个交叉学科，因此有必要将各种过程改进的工作集成起来。CMMI 是若干过程模型的综合和改进CMMI 提供了两种表示方法：阶段式模型和连续式模型1. 阶段式模型阶段式模型的结构类似于 CMM，它关注组织的成熟度。CMMI-SE/SW/IPPD 1.1 版中有 5 个成熟度等级  初始的：过程不可预测且缺乏控制  已管理的：过程为项目服务  已定义的：过程为组织服务  定量管理的：过程已度量和控制  优化的：集中于过程改进2. 连续式模型连续式模型关注每个过程域的能力，一个组织对不同的过程可以达到不同的过程域能力等级 (Capability Level, CL) 。CMMI 中包括 6 个过程域能力等级，等级号为 0~5。能力等级包括共性目标及相关的共性实践，这些实践在过程域内被添加到特定目标和实践中。当组织满足过程域的特定目标和共性目标时，就说该组织达到了那个过程域的能力等级  CL0 (未完成的) ：过程域未执行或未得到 CL1 中定义的所有目标  CL1 (已执行的) ：其共性目标是过程将可标识的输入工作产品转换成可标识的输出工作产品，以实现支持过程域的特定目标  CL2 (已管理的) ：其共性目标集中于已管理的过程的制度化。根据组织级政策规定过程的运作将使用哪个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制和评审  CL3 (已定义级的) ：其共性目标集中于已定义的过程的制度化。过程是按照组织的剪裁指南从组织的标准过程集中剪裁得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进  CL4 (定量管理的) ：其共性目标集中于可定量管理的过程的制度化。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的定量目标作为管理准则  CL5 (优化的) ：使用量化 (统计学) 手段改变和优化过程域，以满足客户要求的改变和持续改进计划中的过程域的功效软件过程模型软件过程模型习惯上也称为软件开发模型，它是软件开发全部过程、活动和任务的结构框架。典型的软件过程模型有瀑布模型、增量模型、演化模型 (原型模型、螺旋模型) 、喷泉模型、基于构件的开发模型和形式化方法模型等瀑布模型瀑布模型是将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型，包括需求分析、设计、编码、测试、运行与维护。它规定了由前至后、相互衔接的固定次序，如同瀑布流水逐级下落瀑布模型为软件的开发和维护提供了一种有效的管理模式，根据这一模式制定开发计划，进行成本预算，组织开发力量，以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，所以它是以文档作为驱动、适合于软件需求很明确的软件项目的模型瀑布模型假设，一个待开发的系统需求是完整的、简明的、一致的，而且可以先于设计和实现完成之前产生瀑布模型的优点是，容易理解，管理成本低；强调开发的阶段性早期计划及需求调查和产品测试不足之处是，客户必须能够完整、正确和清晰地表达他们的需要；在开始的两个或三个阶段中，很难评估真正的进度状态；当接近项目结束时，出现了大量的集成和测试工作；直到项目结束之前，都不能演示系统的能力在瀑布模型中，需求或设计中的错误往往只有到了项目后期才能够被发现，对于项目风险的控制能力较弱，从而导致项目常常延期完成，开发费用超出预算V 模型瀑布模型的一个变体是 V 模型V 模型描述了质量保证活动和沟通、建模相关活动以及早期构建相关的活动之间的关系。随着软件团队工作沿着 V 模型左侧步骤向下推进，基本问题需求逐步细化，形成问题及解决方案的技术描述。一旦编码结束，团队沿着 V 模型右侧的步骤向上推进工作，其实际上是执行了一系列测试 (质量保证活动) ，这些测试验证了团队沿着 V 模型左侧步骤向下推进过程中所生成的每个模型。V 模型提供了一种将验证确认活动应用于早期软件工程工作中的方法增量模型增量模型融合了瀑布模型的基本成分和原型实现的迭代特征，它假设可以将需求分段为一系列增量产品，每一增量可以分别开发。该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”当使用增量模型时，第一个增量往往是核心的产品。客户对每个增量的使用和评估都作为下一个增量发布的新特征和功能，这个过程在每一个增量发布后不断重复，直到产生了最终的完善产品。增量模型强调每一个增量均发布一个可操作的产品增量模型作为瀑布模型的一个变体，具有瀑布模型的所有优点。此外，它还有以下优点：第一个可交付版本所需要的成本和时间很少；开发由增量表示的小系统所承担的风险不大；由于很快发布了第一个版本，因此可以减少用户需求的变更；运行增量投资，即在项目开始时，可以仅对一个或两个增量投资增量模型有以下不足之处：如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布；管理发生的成本、进度和配置的复杂性可能会超出组织的能力演化模型软件类似于其他复杂的系统，会随着时间的推移而演化。在开发过程中，常常会面临以下情形：商业和产品需求经常变化，直接导致最终产品难以实现；严格的交付时间使得开发团队不可能圆满地完成软件产品，但是必须交付功能有限的版本以应对竞争或商业压力；很好地理解了核心产品和系统需求，但是产品或系统拓展的细节问题却没有定义。在上述情况和类似情况下，软件开发人员需要一种专门应对不断演变的软件产品的过程模型演化模型是迭代的过程模型，使得软件开发人员能够逐步开发出更完整的软件版本。演化模型特别适用于对软件需求缺乏准确认识的情况。典型的演化模型有原型模型和螺旋模型等原型模型 (Prototype Model)并非所有的需求都能够预先定义，大量的实践表明，在开发初期很难得到一个完整的、准确的需求规格说明。这主要是由于客户往往不能准确地表达对未来系统地全面要求，开发者对要解决的应用问题模糊不清，以至于形成的需求规格说明常常是不完整的、不准确的，有时甚至是有歧义的。此外，在整个开发过程中，用户可能会产生新的要求，导致需求的变更。而瀑布模型难以适应这种需求的不确定性和变化，于是出现了快速原型 (Rapid Prototype) 这种新的开发方法。原型方法比较适合于用户需求不清、需求经常变化的情况。当系统规模不是很大也不太复杂时，采用该方法比较好原型是预期系统的一个可执行版本，反映了系统性质的一个选定的子集。一个原型不必满足目标软件的所有约束，其目的是能快速、低成本地构建原型。当然，能够采用原型方法是因为开发工具的快速发展，使得能够迅速地开发出一个让用户看得见、摸得着的系统框架。这样，对于计算机不是很熟悉的用户就可以根据这个框架提出自己的需求。开发原型系统首先确定用户需求，开发初始原型，然后征求用户对初始原型的改进意见，并根据意见修改原型原型模型开始于沟通，其目的是定义软件的总体目标，标识需求，然后快速制定原型开发的计划，确定原型的目标和范围，采用快速设计的方式对其进行建模，并构建原型。被开发的原型应交付给客户使用，并收集客户的反馈意见，这些反馈意见可在下一轮中对原型进行改进。在前一个原型需要改进，或者需要扩展其范围的时候，进入下一轮原型的迭代开发螺旋模型对于复杂的大型软件，开发一个原型往往达不到要求。螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析，弥补了这两种模型的不足螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合，每个螺旋周期分为如下 4 个工作步骤  制定计划。确定软件的目标，选定实施方案，明确项目开发的限制条件  风险分析。分析所选的方案，识别风险，消除风险  实施工程。实施软件开发，验证阶段性产品  用户评估。评价开发工作，提出修正建议，建立下一个周期的开发计划螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。因此，该模型特别适用于庞大、复杂并且具有高风险的系统与瀑布模型相比，螺旋模型支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供了方便，有助于提高软件的适应能力，并且为项目管理人员及时调整管理决策提供了便利，从而降低了软件开发的风险。在使用螺旋模型进行软件开发时，需要开发人员具有相当丰富的风险评估经验和专门知识。另外，过多的迭代次数会增加开发成本，延迟提交时间喷泉模型喷泉模型是一种以用户需求为动力，以对象作为驱动的模型，适合于面向对象的开发方法。它克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。喷泉模型使开发过程具有迭代性和无间隙性迭代意味着模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统，无间隙是指在开发活动 (如分析、设计、编码) 之间不存在明显地边界，也就是说，它不像瀑布模型那样，在需求分析活动结束后才开始设计活动，在设计活动结束后才开始编码活动，而是允许各开发活动交叉、迭代地进行喷泉模型的各个阶段没有明显的界限，开发人员可以同步进行。其优点是可以提高软件项目的开发效率，节省开发时间。由于喷泉模型在各个开发阶段是重叠的，在开发过程中需要大量的开发人员，不利于项目的管理。此外，这种模型要求严格管理文档，使得审核的难度加大统一过程 (UP) 模型统一过程模型是一种“用例和风险驱动，以架构为中心，迭代并且增量”的开发过程，由 UML 方法和工具支持。迭代的意思是将整个软件开发项目划分为许多个小的“袖珍项目”，每个“袖珍项目”都包含正常软件项目的所有元素：计划、分析和设计、构造、集成和测试，以及内部和外部发布统一过程定义了 4 个技术阶段及其制品      起始阶段 (Inception Phase)    初始阶段专注于项目的初创活动，产生的主要工作产品有构想文档 (Vision Document) 、初始用例模型、初始项目术语表、初始业务用例、初始风险评估、项目计划 (阶段及迭代) 、业务模型以及一个或多个原型 (需要时)        精化阶段 (Elaboration Phase)    精化阶段在理解了最初的领域范围之后进行需求分析和架构演进，产生的主要工作产品有用例模型、补充需求、分析模型、软件体系结构描述等        构建阶段 (Construction Phase)    构建阶段关注系统的构建，产生实现模型，产生的主要工作产品有设计模型、软件构件、集成的软件增量、测试计划及步骤、测试用例以及支持文档        移交阶段 (Transition Phase)    移交阶段关注于软件提交方面的工作，产生软件增量，产生的主要工作产品有提交的软件增量、β 测试报告和综合用户反馈  每次迭代产生包括最终系统的部分完成的版本和任何相关的项目文档的基线，通过逐步迭代基线之间相互构建，直到完成最终系统。在每个迭代中有 5 个核心工作流：  捕获系统应该做什么的需求工作流  精化和结构化需求的分析工作流  在系统架构内实现需求的设计工作流  构造软件的实现工作流  验证实现是否如期望那样工作的测试工作流随着 UP 的阶段进展，每个核心工作流的工作量发生了变化。4 个技术阶段由主要里程碑所终止  初始阶段：生命周期目标  精化阶段：生命周期架构  构建阶段：初始运作功能  移交阶段：产品发布统一过程的典型代表是 RUP (Rational Unified Process) 。RUP 是 UP 的商业扩展，完全兼容 UP，但比 UP 更完整、更详细敏捷方法敏捷开发的总体目标是通过“尽可能早地、持续地对有价值的软件的交付”使客户满意。通过在软件开发过程中加入灵活性，敏捷方法 (Agile Development) 使用户能够在开发周期的后期增加或改变需求敏捷过程的典型方法有很多，每一种方法基于一套原则，这些原则实现了敏捷方法所宣称的理念 (敏捷宣言)1. 极限编程 (XP)XP 是一种轻量级 (敏捷) 、高效、低成本、柔性、可预测的、科学的软件开发方式。它由价值观、原则、实践和行为 4 个部分组成，彼此相互依赖、关联，并通过行为贯穿于整个生存周期  4 大价值观：沟通、简单性、反馈和勇气  5 大原则：快速反馈、简单性假设、逐步修改、提倡修改和优质工作  12 个最佳实践          计划游戏 (快速制定计划、随着细节的不断变化而完善)      小型发布 (系统的设计要能够尽可能早地交付)      隐喻 (找到合适的比喻传达信息)      简单设计 (只处理当前的需求，使设计保持简单)      测试先行 (先写测试代码，然后再编写程序)      重构 (重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求)      结对编程      集体代码所有制      持续集成 (可以按日甚至按小时为客户提供可运行的版本)      每周工作 40 个小时      现场客户 (系统最终用户代表应该全程配合 XP 团队)      编码标准      2. 水晶法 (Crystal)水晶法认为每一个不同的项目都需要一套不同的策略、约定和方法论认为人对软件质量有重要的影响，因此随着项目质量和开发人员素质的提高，项目和过程的质量也随之提高。通过更好地交流和经常性的交付，软件生产力得到提高3. 并列争求法 (Scrum)并列争求法使用迭代的方法，其中，把每 30 天一次的迭代称为一个“冲刺”，并按需求的优先级别来实现产品。多个自组织和自治的小组并行地递增实现产品，协调是通过简短的日常情况会议来进行，就像橄榄球中的“并列争球”。步骤如下：4. 自适应软件开发 (ASD)ASD 有 6 个基本的原则  有一个使命作为指导  特征被视为客户价值的关键点  过程中的等待是很重要的，因此“重做”与“做”同样关键  变化不被视为改正，而是被视为对软件开发实际情况的调整  确定的交付时间迫使开发人员认真考虑每一个生产的版本的关键需求  风险也包含其中5. 敏捷统一过程 (AUP)敏捷统一过程 (Agile Unified Process, AUP) 采用“在大型上连续”以及在“小型上迭代”的原理来构建软件系统。采用经典的 UP 阶段性活动 (初始、精化、构建和转换) ，提供了一系列活动，能够使团队为软件项目构想出一个全面的过程流。在每个活动里，一个团队迭代使用敏捷，并将有意义的软件增量尽可能快地交付给最终用户。每个 AUP 迭代执行以下活动  建模。建立对商业和问题域的模型表述，这些模型“足够好”即可，以便团队继续前进  实现。将模型翻译为源代码  测试。像 XP 一样，团队设计和执行一系列的测试来发现错误以保证源代码满足需求  部署。对软件增量的交付以及获取最终用户的反馈  配置及项目管理。着眼于变更管理、风险管理以及对团队的任一制品的控制。项目管理追踪和控制开发团队的工作进展并协调团队活动  环境管理。协调标准、工具以及适用于开发团队的支持技术等过程基础设施"
  },
  
  {
    "title": "Git 学习",
    "url": "/archives/95",
    "categories": "技术工具",
    "tags": "Git",
    "date": "2023-03-05 15:03:43 +0800",
    





    
    "snippet": "整理一下自己学的 Git 相关的内容吧一、安装  在 Windows 上安装 Git从 Git 官网下载安装：https://git-scm.com/download/win安装完成后运行一次 Git Bash  在 Linux 上安装 GitDebian：sudo apt-get install gitFedora：dnf install gitCentOS：yum install git...",
    "content": "整理一下自己学的 Git 相关的内容吧一、安装  在 Windows 上安装 Git从 Git 官网下载安装：https://git-scm.com/download/win安装完成后运行一次 Git Bash  在 Linux 上安装 GitDebian：sudo apt-get install gitFedora：dnf install gitCentOS：yum install git其他参考：https://git-scm.com/download/linux  在 Mac OS X 上安装 Git一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/二是直接从 AppStore 安装 Xcode，Xcode 集成了 Git，不过默认没有安装，你需要运行 Xcode，选择菜单 Xcode - Preferences，在弹出窗口中找到 Downloads，选择 Command Line Tools，点 Install 就可以完成安装了Xcode 是 Apple 官方 IDE，功能非常强大，是开发 Mac 和 iOS App 的必选装备，而且是免费的二、配置安装完成后需要配置自己的身份信息git config --global user.name \"Your Name\"git config --global user.email \"email@example.com\"其中 Your Name 替换为您的姓名，email@example 替换为您的邮箱三、创建版本库 (仓库)选择一个文件夹，然后执行命令git init这样该文件夹就称为可以被 Git 管理的仓库，请勿乱修改 ./.git 目录下的文件 (通常这是隐藏文件)，该目录内容为 Git 跟踪管理版本库的或者也可以从 Github 上克隆仓库到本地  克隆别人的仓库如果不修改然后提交使用 HTTPS 就行，例如git clone https://github.com/yexca/typecho-theme-book.git仓库链接可访问仓库所在网页，点击 Code 获得如果克隆下来需要提交更改，需要仓库的拥有者将您的密钥添加到仓库的 Deploy keys ，此时可以使用 SSH 克隆git clone git@github.com:yexca/typecho-theme-book.git  不过一般修改提交的话还是先 fork 一份修改然后再 Pull requests 提交比较好  参考：如何使用github给大佬递茶 - idealclover  如何在 GitHub 提交第一个 pull request  克隆自己的仓库先在个人的设置处添加 SSH 公钥：SSH and GPG keys (github.com)然后以上俩方法皆可四、文件提交本地仓库一通操作后，多了几个文件，该提交到仓库了将文件添加到本地仓库git add filename# 或者下面是提交所有修改的文件git add .添加完成后该提交了git commit -m \"some details\"在 some details 处描述本次提交了什么那如果有些文件我不想提交到仓库呢，也就是有些文件可能不需要 Git 进行跟踪是否被修改创建 .gitignore 文件，然后把不想被 Git 管理的文件名填入一行一个即可# .gitignore 文件test/    # 忽略 test 文件夹test    # 忽略 test 文件*.py[cod]    # 忽略 *.pyc *.pyo *.pyd 文件!app.pyc    # 不忽略 app.pyc 文件忽略了也可以强制提交：git add -f test.pyc也有一些现成的文件，可以参考一下：https://github.com/github/gitignore五、日志与撤销使用 git status 可以查看仓库的状态使用 git diff 查看上次提交修改的内容使用 git log 查看历史记录，即日志，如果信息太多可以加上 --pretty=oneline 参数，此时可以看到 commit ID在 commit ID 后如果有 HEAD -&gt; master 则说明此为最新提交，也就是当前版本，Git 使用 HEAD 表示当前版本，上一个版本就是 HEAD^，上上个版本是 HEAD^^ ，往上 60 个版本可以写成 HEAD~60回退到上一个版本 git reset --hard HEAD^回退到指定版本：git reset --hard commitID# 例如 commit ID 为 eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0，可以写如下：git reset --hard eaadf4# 只要写前几位并可以识别就行，没必要写全如果你操作失误回退了，请不要关闭命令行窗口，查看命令日志：git reflog 找到刚才的版本号回退即可del六、本地仓库链接 Github本地创建了一个仓库，想要上传到 Github 的话，可以在 Github 上新建一个 repo ，然后将本地仓库链接远程仓库以上传git remote add origin git@github.com:[your repo]如果是从远程仓库克隆的不需要链接然后是在本地做了一些修改并提交，需要推送至远程仓库推送命令：git push origin master命令为推送到远程仓库的 master 分支这里需要注意的是使用 VS Code 创建的仓库默认分支为 master 而 Github 默认分支为 main，直接推送 git push origin main 会失败，可以先修改本地分支名字再推送git branch -m master main如果链接仓库时输入错了首先查看远程仓库信息：git remote -v然后删除：git remote rm RepoName一般远程仓库名称为 origin，所以删除命令为 git remote rm origin七、分支管理暂时用不到，简单记录创建分支：git branch cheny切换到分支：git checkout cheny提交到分支：git push origin cheny八、创建服务端参考：搭建Git服务端及同步到指定目录九、其他同时使用 GitLab 和 Github：document-library/Git-study.md at master · LiangJunrong/document-library (github.com)参考文章document-library/Git-study.md at master · LiangJunrong/document-library · GitHubGit教程 - 廖雪峰的官方网站 (liaoxuefeng.com)如何连接本地仓库与GitHub仓库_joy_we1的博客-CSDN博客如何使用github给大佬递茶 - idealclover如何在 GitHub 提交第一个 pull request将本地master分支代码提交到远程main分支"
  },
  
  {
    "title": "数据库记录已下载画师作品",
    "url": "/archives/94",
    "categories": "折腾记录",
    "tags": "MySQL, Pixiv",
    "date": "2023-03-02 10:16:38 +0800",
    





    
    "snippet": "秉持着 “不在自己硬盘的东西就不是自己的” 的原则，以及个人手机中日益增多的图片迫切需要整理放入硬盘中保存，以缓解手机内存危机，于是决定采取分画师下载储存。于是便需要一个方便记录，快速查询修改的方法，原来使用 Markdown 的清单，可随着画师增多，查询不免变得很慢时隔两天再次回想，「记录」这个东西，最好用的不就是数据库嘛！下载与安装经过思考，决定使用 MySQL ，下载可参考：MySQL...",
    "content": "秉持着 “不在自己硬盘的东西就不是自己的” 的原则，以及个人手机中日益增多的图片迫切需要整理放入硬盘中保存，以缓解手机内存危机，于是决定采取分画师下载储存。于是便需要一个方便记录，快速查询修改的方法，原来使用 Markdown 的清单，可随着画师增多，查询不免变得很慢时隔两天再次回想，「记录」这个东西，最好用的不就是数据库嘛！下载与安装经过思考，决定使用 MySQL ，下载可参考：MySQL下载与安装 - 知乎 ，部分变了，不过也差不多啦安装我直接默认，一直下一步到完成 (太麻烦了)启动服务，win+R 输入 services.msc 找到服务开启数据库设计说实话这也没啥好设计的吧，暂时主要下载 Pixiv 上画师，部分是 Twitter 上的，所以只用一张表应该就可以啦            ID      name      downloadDate      lastDownloadID      platform      url                  画师唯一标识      姓名      下载日期      最后下载作品 ID      平台      链接      这设计是第几范式呢？ 代码如下：-- 创建数据库create database hello;-- 选择数据库use hello;-- 创建表create table pic(\tID varchar(99),    name varchar(255),    downloadedDate datetime,    lastDownloadID varchar(255),    platform varchar(50),    url varchar(255),    primary key(ID));作品下载  Pixiv使用 Powerful Pixiv Downloader 拓展，Chrome 应用商店链接Github 链接：xuejianxianzun/PixivBatchDownloader  记得开启慢速抓取，不然下太快或一次下载过多会暂时封 IP  Twitter使用 Twitter Media Downloader 拓展，Chrome 应用商店链接官网链接：Twitter メディアダウンローダ：ユーザータイムラインの原寸画像や動画をまとめてダウンロードするユーザースクリプト(PC用Google Chrome・Firefox等対応) - 風柳メモ数据插入-- 选择数据库use hello;-- 插入数据insert into pic values('6049901', '鬼针草', '2023-02-09', '105176620', 'pixiv', 'https://www.pixiv.net/users/6049901')多行数据的话，数据直接用 , 分隔数据更新update picset downloadedDate = '2023-03-02', lastDownloadID = '105716156'where ID = '6049901'了解更多：数据库学习三 SQL 语言 – yexca’Blog了解数据库？我编写的：数据库学习一 数据库导论 – yexca’Blog菜鸟教程：SQL 教程-菜鸟教程参考文章MySQL常见建表选项及约束 - GeaoZhang - 博客园"
  },
  
  {
    "title": "面向对象基础",
    "url": "/archives/93",
    "categories": "软件工程",
    "tags": "Java, 面向对象",
    "date": "2023-02-25 19:34:30 +0800",
    





    
    "snippet": "面向对象 (Object-Oriented, OO) 是一种非常实用的系统化软件开发方法面向过程和面向对象以一个问题引入：把大象装进冰箱，需要几步？一般先打开冰箱，然后把大象装进冰箱，最后关上冰箱面向过程：关心我该怎么做？一步步去实现这个功能对于上述问题:  我打开冰箱  我把大象装进冰箱里  我关上冰箱门面向对象关心我该让谁去做？去调用对象的操作来实现这个功能对于上述问题创建对象：大象，冰...",
    "content": "面向对象 (Object-Oriented, OO) 是一种非常实用的系统化软件开发方法面向过程和面向对象以一个问题引入：把大象装进冰箱，需要几步？一般先打开冰箱，然后把大象装进冰箱，最后关上冰箱面向过程：关心我该怎么做？一步步去实现这个功能对于上述问题:  我打开冰箱  我把大象装进冰箱里  我关上冰箱门面向对象关心我该让谁去做？去调用对象的操作来实现这个功能对于上述问题创建对象：大象，冰箱  冰箱打开门  大象钻进冰箱  冰箱关上门面向对象基础面向对象 = 对象 + 分类 + 继承 + 通过消息的通信可以说，采用这四个概念开发的软件系统是面向对象的对象客观世界由许多具体的事物、事件、概念和规则组成，这些均可被看成对象在面向对象的系统中，对象是基本的运行时的实体，它既包括数据 (属性) ，也包括作用于数据的操作 (行为) 。一个对象通常可由对象名、属性和方法 3 个部分组成消息对象之间进行通信的一种构造叫做消息。的一个消息发送给某个对象时，包含要求接收对象去执行某些活动的信息。接收到信息的对象经过解释，然后予以相应类似于方法调用的传参类一个类定义了一组大体上相似的对象。一个类所包含的方法和数据描述一组对象的共同行为和属性。把一组对象的共同特征加以抽象并存储在一个类中是面向对象技术最重要的一点。是否建立了一个丰富的类库，是衡量一个面向对象程序设计语言成熟与否的重要标志类是在对象之上的抽象，对象是类的具体化，是类的实例。在分析与设计时，通常把注意力集中在类上，而不是具体的对象。也不必逐个定义每个对象，只需对类做出定义，而对类的属性进行不同赋值即可得到该类的对象实例类可以分为三种：实体类、接口类 (边界类) 和控制类。控制类的对象用来控制活动流，充当协调者有些类之间存在一般和特殊关系，即一些类是某个类的特殊情况，某个类是一些类的一般情况。特殊类是一般类的子类，一般类是特殊类的父类通常，把一个类和这个类的所有对象称为 “类及对象” 或对象类方法重载方法重载方式  方法名相同，参数个数不同  方法名相同，参数类型不同  方法名相同，参数类型顺序不同以 java 为例，java 的函数 (方法) 的格式如下/*权限修饰符 返回值类型 方法名(参数类型1 参数名1, 参数类型2 参数名2,···){\t方法体}*/以下为例子public class Test{    // 原方法    public void sum(int a, double b)    {        System.out.println(a + b);    }    // 1. 方法名相同，参数个数不同    public void sum(int a, double b, int c)    {        System.out.println(a + b + c);    }    // 2. 方法名相同，参数类型不同    public void sum(int a, int b)    {        System.out.println(a + b);    }    // 3. 方法名相同，参数类型顺序不同    public void sum(double a, int b)    {        System.out.println(a + b);    }}面向对象三大特征面向对象的三个基本特征是：封装、继承、多态封装封装是一种信息隐蔽技术，它的目的是使对象的使用者和生产者分离，使对象的定义和实现分开。从程序设计者来看，对象是一个程序模块；从用户来看，对象为他们提供了所希望的行为也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏public class Person{    private String name;\t// 使用 private 限制权限    private int age;        public void setName(String name){        // 通过 public 方法提供修改对象属性的途径        this.name = name;    }    public String getName(){        // 通过 public 方法提供获取对象属性的途径        return name;    }        public void setAge(int age){        if (age &gt;= 0 &amp;&amp; age &lt;= 150)        \tthis.age = age;    }    public int getAge(){        return age    }        public void run(){        System.out,println(\"润！\")    }}继承继承是父类和子类之间共享数据和方法的机制。这是类之间的一种关系，在定义和实现一个类的时候，可以在一个已经存在的父类的基础上进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容一个父类可以有多个子类，这些子类都是父类的特例，父类描述了这些子类的公共属性和方法。一个子类可以继承它的父类 (或祖先类) 中的属性和方法，这些属性和操作在子类中不必定义，子类中还可以定义自己的属性和方法如果子类只从一个父类得到继承，称为 “单重继承” 。如果一个子类有两个或更多个父类，则称为 “多重继承”  注：Java 中一个子类只能有一个父类// 接上一段代码看public class Student extends Person{    // 使用关键字 extends 指明要继承的父类    private int id;        public void setId(int id){        this.id = id;    }    public int getId(){        return id;    }        public void study(){        System.out.println(getName() + \"正在学习\");    }        // 重写父类方法    public void run(){        System.out,println(getName + \"想润\")    }}多态在收到消息时，对象要予以响应。不同对象收到同一消息可以产生完全不同的结果，这一现象称为多态。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节则由接收对象自行决定。这样，同一消息就可以调用不同的方法多态的实现受到继承的支持，利用类的继承的层次关系，把具有通用功能的消息存放在高层次，而不同的实现这一功能的行为放在较低层次，在这些低层次上生成的对象能够给通用消息以不同的响应// 父类public class Person{    public void work(){        System.out.println(\"工作\");    }}// 子类 1public class Student extends Person{    // 重写父类方法    public void work(){        System.out.println(\"上学\");    }        public void run(){                System.out.println(\"Only the young CAN RUN!\");    }}// 子类 2public class Worker extends Person{    // 重写父类方法    public void work(){        System.out.println(\"上班\");    }        public void sleep(){        System.out.println(\"睡觉\");    }}// mainpublic class main{    public static void main(String[] args){        // 编译看左边，运行看右边        Person stu = new Student();        stu.work;        // 不可调用 stu.run(); 方法                Person wok = new Worker();        wok.work;        // 不可调用 wok.sleep(); 方法    }}// 运行输出：// 上学// 上班多态的形式多态有不同的形式，Cardelli 和 Wegner 把它分为 4 类参数多态：应用比较广泛的多态，被称为最纯的多态包含多态：在许多语言中都存在，最常见的例子就是子类型化，即一个类型是另一个类型的子类型过载多态：同一个名字在不同的上下文中所代表的含义不同动态绑定和静态绑定绑定是一个把过程调用和响应调用所执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行的，叫做静态绑定。动态绑定则是在运行时进行的。因此，一个给定的过程调用和代码的结合直到调用发生时才进行动态绑定是和类的继承以及多态相联系的。在继承关系中，子类是父类的一个特例，所以父类可以出现的地方，子类对象也可以出现。因此在运行过程中，当一个对象发送消息请求服务时，要根据接收对象的具体情况将请求的操作与实现的方法进行连接，即动态连接面向对象分析面向对象分析 (Object-Oriented Analysis, OOA) 的目的是为了获得对应用问题的理解。理解的目的是确定系统的功能、性能要求面向对象分析包含 5 个活动：认定对象、组织对象、描述对象间的相互作用、确定对象的操作、定义对象的内部信息面向对象设计面向对象设计 (Object-Oriented Design, OOD) 是将 OOA 所创建的分析模型转化为设计模型，其目标是定义系统构造蓝图。通常的情况是，由概念模型生成的分析模型被装入到相应的执行环境中时，需要考虑实现问题加以调整和增补，如根据所用编程语言是否支持多继承或继承，而调整类结构。OOA 与 OOD 之间不存在鸿沟，采用一致的概念和一致的表示法，OOD 同样应遵循抽象、信息隐蔽、功能独立、模块化等设计准则面向对象设计的活动OOD 在复用 OOA 的模型的基础上，包含与 OOA 对应如下五个活动  识别类及对象  定义属性  定义服务  识别关系  识别包面向对象设计原则  单一责任原则​\t就一个类而言，应该仅有一个引起它变化的原因。即，当需要修改某个类的时候原因有且只有一个，让一个类只做一种类型责任  开放-封闭原则​\t软件实体 (类、模块、函数等) 应该是可以扩展的，即开放的；但是不可修改的，即封闭的  里氏替换原则​\t子类型必须能够替换掉他们的基 (父) 类型。即，在任何父类可以出现的地方，都可以用子类的实例来赋值给父类型的引用。当一个子类型的实例应该能够替换任何其超类的实例时，它们之间才具有是一个 (is-a) 关系  依赖倒置原则​\t抽象不应该依赖于细节，细节应该依赖于抽象。即，高层不应该依赖于底层模块，二者都应该依赖于抽象  接口分离原则​\t不应该强迫客服依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。即：依赖于抽象，不要依赖于具体，同时在抽象级别不应该有对于细节的依赖。这样做的好处就在于可以最大限度地应对可能的变化以上为面向对象方法中的五大原则。除了这五大原则之外，Robert C. Martin 提出的面向对象设计原则还包括以下几个  重用发布等价原则​\t重用的颗粒就是发布的粒度  共同封闭原则​\t包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其他的包不造成任何影响  共同重用原则​\t一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么就要重用包中的所有类  无环依赖原则​\t在包的依赖关系图中不允许存在环，即包之间的结构必须是一个直接的无环图形  稳定依赖原则​\t朝着稳定的方向进行依赖  稳定抽象原则​\t包的抽象程度应该和其稳定程度一致面向对象测试就测试而言，用面向对象方法开发的系统测试与其他方法开发的系统测试没有什么不同一般来说，对面向对象软件的测试可分为下列 4 个层次进行  算法层  类层  模板层  系统层面向对象程序设计程序设计范型 (Programming Paradigm) 是人们在程序设计时所采用的基本方式模型，决定了程序设计时采用的思维方式、使用的工具，同时又有一定的应用范畴。其发展经历了过程程序设计、模块化程序设计、函数程序设计、逻辑程序设计，发展到现在的面向对象程序设计范型面向对象程序设计 (Object-Oriented Programming, OOP) 的实质是选用一种面向对象程序设计语言 (Object-Oriented Programming Language, OOPL) ，采用对象、类及其相关概念所进行的程序设计。它的关键在于加入了类和继承性，从而进一步提高了抽象程度。特定的 OOP 概念一般是通过 OOPL 中特定的语言机制来体现的OOP 现在已经扩展到系统分析和软件设计的范畴，出现了面向对象分析和面向对象设计的概念，这部分在前面已经有所体现"
  },
  
  {
    "title": "数据库学习七 数据库的控制功能",
    "url": "/archives/92",
    "categories": "数据库",
    "tags": "",
    "date": "2023-02-12 08:15:00 +0800",
    





    
    "snippet": "事务管理事务是一个操作序列，这些操作 “要么都做，要么都不做”事务和程序是两个不同的概念，一般一个程序可包含多个事务在 SQL 语言中，事务定义的语句有以下三条-- 事务开始BEGIN TRANSACTION-- 事务提交COMMIT-- 事务回滚ROLLBACK事务具有 ACID 性质，原子性 (Atomicity) 、一致性 (Consistency) 、隔离性 (Isolation) ...",
    "content": "事务管理事务是一个操作序列，这些操作 “要么都做，要么都不做”事务和程序是两个不同的概念，一般一个程序可包含多个事务在 SQL 语言中，事务定义的语句有以下三条-- 事务开始BEGIN TRANSACTION-- 事务提交COMMIT-- 事务回滚ROLLBACK事务具有 ACID 性质，原子性 (Atomicity) 、一致性 (Consistency) 、隔离性 (Isolation) 和持久性 (Durability)  原子性事务是原子的，要么都做，要么都不做  一致性事务执行的结果必须保证数据库从一个一致性状态变到另一个一致性状态因此，当数据库只包含成功事务提交的结果时，称数据库处于一致性状态  隔离性事务相互隔离当多个事务并发执行时，任一事务的更新操作直到其成功提交的整个过程，对其他事务都是不可见的  持久性一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效数据库的备份与恢复在数据库的运行过程中，难免会出现计算机系统的软、硬件故障，这些故障会影响数据库中数据的正确性，甚至破坏数据库，使数据库中的全部或部分数据丢失。因此，数据库的关键技术在于建立冗余数据，即备份数据。如何在系统出现故障后能够及时地使数据库恢复到故障前地正确状态，就是数据库恢复技术故障类型数据库中的 4 类故障  事务内部故障采取REDO重做和UNDO撤销技术  系统故障 DBMS系统突然停转，系统要重启  介质故障硬件损坏  计算机病毒备份方法恢复的基本原理是 “建立数据冗余” (重复存储) 。建立冗余数据的方法是进行数据转储和登记日志文件。数据的转储分为静态转储和动态转储、海量转储和增量转储、日志文件  静态转储和动态转储静态转储是指在转储期间不允许对数据库进行任何存取、修改操作动态转储是在转储期间允许对数据库进行存取、修改操作因此，转储和用户事务可并发执行  海量转储和增量转储海量转储是指每次转储全部数据增量转储是指每次只转储上次转储后更新过的数据  日志文件在事务处理的过程中，DBMS (数据库管理系统) 把事务开始、事务结束以及对数据库的插入、删除和修改的每一次操作写入日志文件。一旦发生故障，DBMS 的恢复子系统利用日志文件撤销事务对数据库的改变，回退到事务的初始状态。因此，DBMS 利用日志文件来进行事务故障恢复和系统故障恢复，并可协助后备副本进行介质故障恢复恢复  事务恢复有以下 3 个步骤  反向扫描文件日志 (即从最后向前扫描日志文件) ，查找该事务的更新操作  对事务的更新操作执行逆操作  继续反向扫描日志文件，查找该事务的其他更新操作，并做同样的处理，直到事务的开始标志即事务异常终止，那么就撤销之前的所有操作  系统故障的恢复还没执行完的事务UNDO，丢失的事务REDO  介质故障的恢复重装数据库，重做已经完成的事务并发控制并发操作带来的问题  丢失修改我修改的东西没生效。比如我把网站logo改了，结果还是原来的  不可重复读我在一个事务中，连续两次读到的数据不一样比如我刚开始读到银行余额为10元。此时单位突然发工资100元，那么第二次读就变成110元  读脏数据我要读取字段A，B，但读取时其他用户正在更新这两个字段如果他跟新到一半我就读取（更新了A，正在更新B），此时读取的数据就是脏数据并发控制技术并发控制的主要技术是封锁。基本封锁的类型有排他锁 (简称 X 锁或写锁) 和共享锁 (简称 S 锁或读锁)  排他锁若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其他事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁  共享锁若事务 T 对数据对象 A 加上 S 锁，则只允许 T 读取 A，但不能修改 A，其他事务只能再对 A 加 S 锁，直到 T 释放 A 上的 S 锁。这就保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 进行任何修改封锁协议  一级封锁协议（解决丢失修改）修改时，必须加X锁，直到结束  二级封锁协议（解决读脏数据）读的时候，加S锁，用完就放  三级封锁协议（解决不可重复读）读的时候，加S锁，直到结束可串行性假设多种情况都可以，然后获得结果如果并发执行的结果跟上面的结果里面任意一个一样就可以事务T1：读取B，A=B+1，写回A事务T2：读取A，B=A+1，写回B那么结果假设先T1，再T2，那么A=4，B=3；假设先T2，再T1，那么A=3，B=4.这个并发执行满足可串行性分布式数据库  分片透明用户或应用程序不需要知道逻辑上访问的表具体是怎么分块存储的  复制透明采用复制技术的分布方法，用户不需要知道数据是复制到哪些节点，如何复制的  位置透明用户无需知道数据存放的物理位置  逻辑透明用户或应用程序无需知道局部场地使用的是哪种数据模型  共享性数据存储在不同的结点数据共享  自治性每结点对本地数据都能独立管理  可用性当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪  分布性数据在不同场地上的存储"
  },
  
  {
    "title": "数据库学习六 数据库设计",
    "url": "/archives/91",
    "categories": "数据库",
    "tags": "",
    "date": "2023-02-11 08:15:00 +0800",
    





    
    "snippet": "数据库设计的策略自顶向下与自底向上，常常两种方法综合使用数据库设计的步骤新奥尔良法是目前得到公认的，较完整、较权威的数据库设计方法，它把数据库设计分为四个主要阶段  用户需求分析。收集用户需求，确定系统边界  概念设计。描述概念模型较理想的是采用 E-R 方法  逻辑设计。E-R 图转换为关系模式，规范化  物理设计。逻辑模型在计算机中的具体实现方案然后进行数据库实施阶段与数据库运行、维护阶...",
    "content": "数据库设计的策略自顶向下与自底向上，常常两种方法综合使用数据库设计的步骤新奥尔良法是目前得到公认的，较完整、较权威的数据库设计方法，它把数据库设计分为四个主要阶段  用户需求分析。收集用户需求，确定系统边界  概念设计。描述概念模型较理想的是采用 E-R 方法  逻辑设计。E-R 图转换为关系模式，规范化  物理设计。逻辑模型在计算机中的具体实现方案然后进行数据库实施阶段与数据库运行、维护阶段需求分析阶段需求分析是在项目确定之后，用户和设计人员对数据库系统所要涉及的内容 (数据) 和功能 (行为) 的整理和描述，是以用户的角度来认识系统。这一过程是后续开发的基础，以后的逻辑设计和物理设计以及应用程序的设计都会以此为依据  需求分析阶段的工作调查机构情况 → 熟悉业务活动 → 明确用户需求 → 确定系统边界 → 分析系统功能 → 分析系统数据 → 编写分析报告  需求分析阶段的文档需求调查所得到的数据可能是零碎的、局部的，分析师和设计人员必须进一步分析和表达用户的需求，建立需求说明文档、数据字典和数据流程图E-R 模型E-R (实体-联系) 模型是概念模型，用来描述现实世界的概念模型实体用矩形表示，矩形框内写明实体名联系用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁边标注上联系的类型 (1 : 1、1 : n、m : n)&lt;1&gt; 两个不同实体之间的联系  一对一 (1 : 1)：指实体集 E1 中的一个实体最多只与实体集 E2 中的一个实体相联系  一对多 (1 : n)：表明实体集 E1 中的一个实体可与实体集 E2 中的多个实体相联系  多对多 (m : n)：表明实体集 E1 中的多个实体可与实体集 E2 中的多个实体相联系&lt;2&gt; 两个以上不同实体集之间的联系两个以上不同实体集之间存在 1 : 1 : 1、1 : 1 : n、1 : m : n 和 r : n : m 的联系&lt;3&gt; 同一实体集内的二元联系同一实体集内的各实体之间也存在 1 : 1、1 : n 和 m : n 的联系属性属性是实体某方面的特性，用椭圆表示，椭圆框内写明属性名 (主属性的属性名用下划线标记)，并用无向边与有关实体连接起来每个属性都有其取值范围。在同一实体集中，每个实体的属性及其域是相同的，但可能取不同的值E-R 模型中的属性有以下分类  简单属性和复合属性简单属性是原子的、不可再分的。复合属性可以细分为更小的部分 (即划分为别的属性)若不特别声明，通常指的是简单属性  单值属性和多值属性单值属性是定义的属性对于一个特定的实体都只有单独的一个值多值属性是定义的属性对于一个特定的实体有多个值  NULL 属性当实体在某个属性上没有值或者属性值未知时，使用 NULL 值，表示无意义或不知道  派生属性派生属性可以从其他属性得来例如职工有 入职时间 与 工作时长 属性，则 工作时长 可以由当前时间与 入职时间 之差获得，这里 工作时长 就是一个派生属性弱实体在现实世界中有一种特殊的联系，这种联系代表实体间的所有关系。例如，职工与家属的联系，家属总是属于某职工的。这种实体对于另一些实体具有很强的依赖关系，即一个实体的存在必须以另一个实体为前提，将这类实体称为弱实体在 E-R 图中，弱实体使用双线矩形框表示超类和子类实体例如职员实体是飞行员、机械师和管理员实体的超类 (父类)，超类和子类之间具有继承关系子类实体矩形两边有竖线，超类与子类的连线中有圆圈概念结构设计阶段用 E-R 方法建立概念模型对需求分析阶段所得到的数据进行分类、聚集和概括，确定实体、属性和联系。概念结构的具体工作步骤包括选择局部应用、逐一设计分 E-R 图和 E-R 图合并需求分析阶段 → 抽象数据 → 设计局部视图 → 合并取消冲突 → 修改重构消除冗余 → 逻辑结构设计阶段选择局部应用选择适当层次的数据流图，让这一层的每一部分对应一个局部应用，实现某一项功能逐一设计分 E-R 图划分好各个局部应用之后，就要对每一个局部应用逐一设计分 E-R 图，又称为局部 E-R 图E-R 图合并根据局部应用设计好各局部 E-R 图之后，就可以对各分 E-R 图进行合并，合并的目的在于在合并过程中解决分 E-R 图中相互间存在的冲突。最终构成一张全局 E-R 图分 E-R 图之间的冲突主要有以下三类：  属性冲突同一属性可能会存在于不同的分 E-R 图，由于设计人员不同或者出发点不同，对属性的类型、取值范围和数据单位等可能会不一致，这些属性对应的数据将来只能以一种形式在计算机中存储，这就需要在设计阶段进行统一  命名冲突相同的意义在不同分 E-R 图上有着不同的命名，或是名称相同的属性在不同的分 E-R 图中代表着不同的意义，这些也要进行统一  结构冲突同一实体在不同的分 E-R 图中有不同的属性，同一对象在某一分 E-R 图中被抽象为实体，而在另一分 E-R 图中又被抽象为属性，需要统一逻辑结构设计阶段逻辑结构设计是在概念结构设计的基础上进行数据模型设计，可以是层次模型、网状模型和关系模型，本节介绍如何在全局 E-R 图基础上进行关系模型的逻辑结构设计。逻辑结构设计阶段的主要工作步骤包括确定数据模型、将 E-R 图转换成为指定的数据模型、确定完整性约束 (实体完整性，参照完整性和用户自定义完整性) 和确定用户视图概念设计阶段 → 转换为数据模型 → 关系规范化 → 模式优化 → 设计用户子模式 → 物理设计阶段E-R 图关系模式的转换E-R 方法所得到的全局概念模型是对信息世界的描述，并不适用于计算机处理，为适合关系数据库系统的处理，必须将 E-R 图转换成关系模式。E-R 图是由实体、属性和联系三要素构成，而关系模式中只有唯一的结构 — 关系模式，通常采用以下方法加以转换一、实体向关系模式的转换将 E-R 图中的实体逐一转换成为一个关系模式，实体名对应关系模式的名称，实体的属性转换成关系模式的属性，实体标识符就是关系的吗 (键)二、联系向关系模式的转换  一对一联系的转换一种方式是将联系归并到并联的两个实体的任一方，给待归并的一方实体属性集中增加另一方实体的码和该联系的属性即可，归并后的实体，码保持不变另一种方式 (一般不用) 是将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性包括该联系所关联的两个实体的码及联系的属性，关系的码取自任一方实体的码  一对多联系的转换一种方式是将联系归并到关联的两个实体的多方，给待归并的多方实体属性集中增加一方实体的码和该联系的属性即可，归并后的多方实体码保持不变另一种方式 (一般不用) 是将联系转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个实体的码及联系的属性，关系的码是多方实体的码  多对多联系的转换多对多联系只能转换成一个独立的关系模式，关系模式的名称取联系的名称，关系模式的属性取该联系所关联的两个多方实体的码及联系的属性，关系的码是多方实体的码构成的属性组  多对多对多联系的转换与第三个大致相同  超类和子类的转换超类、子类实体都可转换为一个关系，并将超类实体的主码加到子类实体中关系模式的规范化  根据语义确定各关系模式的数据依赖  根据数据依赖确定关系模式的范式  如果关系模式不符合要求，要根据关系模式的分解算法对其进行分解，达到 3NF、BCNF 或 4NF  关系模式的评价及修正物理设计阶段逻辑设计阶段 → 确定数据库的物理模式 → 评价数据库的物理模式 → 数据库实施阶段数据库的实施与维护物理结构设计阶段 → 定义数据库 → 数据装入与编写应用程序 → 数据库试运行 → 数据库运行维护阶段"
  },
  
  {
    "title": "数据库学习五 范式",
    "url": "/archives/90",
    "categories": "数据库",
    "tags": "",
    "date": "2023-02-10 08:13:00 +0800",
    





    
    "snippet": "关系数据库中的关系必须满足一定的规范化要求，对于不同的规范化程度可以使用范式来衡量。目前主要有 6 钟范式：1NF、2NF、3NF、BCNF、4NF 和 5NF满足最低要求的称为 1NF，在 1NF 基础上进一步满足一些要求的为 2NF，以此类推。在这些范式中，最重要的是 3NF 和 BCNF，它们是进行规范化的主要目标一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模...",
    "content": "关系数据库中的关系必须满足一定的规范化要求，对于不同的规范化程度可以使用范式来衡量。目前主要有 6 钟范式：1NF、2NF、3NF、BCNF、4NF 和 5NF满足最低要求的称为 1NF，在 1NF 基础上进一步满足一些要求的为 2NF，以此类推。在这些范式中，最重要的是 3NF 和 BCNF，它们是进行规范化的主要目标一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这个过程称为规范化第一范式 (1NF)定义：设 R 是一个关系模式，R 属于第一范式当且仅当 R 中每一个属性 A 的值域只包含原子项，即不可分割的数据项1NF 不能排除数据冗余、更新 (插入、删除) 异常和修改复杂等问题，因为其中可能存在部分函数依赖第二范式 (2NF)定义：设 R 是一个关系模式，R 属于第二范式当且仅当 R 是 1NF，且每个非主属性都完全依赖于候选码属于 2NF 的关系模式 R 也可能存在数据冗余和更新异常等问题，因为其中可能存在传递函数依赖第三范式 (3NF)定义：设 R 是一个关系模式，R 属于第三范式当且仅当 R 是 2NF，且每个非主属性都非传递依赖于候选码属于 3NF 的关系模式 R 可能存在主属性对码的部分依赖和传递依赖BC 范式 (BCNF)定义：设 R 是一个关系模式，F 是它的依赖集，R 属于 BCNF 当且仅当 R 是 3NF，当且仅当其 F 中每个依赖的决定因素必定包含 R 的某个候选码由 BCNF 的定义可以得到结论，一个满足 BCNF 的关系模式有：  所有非主属性对每一个码都是完全函数依赖  所有的主属性对每一个不包含它的码，也是完全函数依赖  没有任何属性完全函数依赖于非码的任何一组属性一个满足 BCNF 的关系模式 R 已消除了插入和删除异常只有两个属性的关系模式一定是 BCNF第四范式 (4NF)定义：设有一关系模式 R&lt;U, F&gt; 是 1NF，如果对于 R 的每个非平凡多值依赖 X →→ Y (Y ⊈ X)，X 都包含了 R 的一个候选码，则称 R 是第四范式  多值依赖给定的关系模式 R&lt;U, F&gt;，有 X、Y、Z 是 U 的子集，并且 Z = U - X - Y，关系模式 R 中的多值依赖 X →→ Y 成立，当且仅当对 R 的任一关系 r，给定一对 (x, z) 值，有一组 Y 的值，这组值仅仅决定于 x 值而与 z 值无关  平凡的多值依赖若以上多值依赖的定义中有 X →→ Y 成立，而且 Z 为空集，则称 X →→ Y 为平凡的多值依赖范式总结  1NF（第一范式）所有字段值都是不可分解的原子值  2NF（第二范式）不包含非主属性对码的部分函数依赖，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中  3NF（第三范式）不包含非主属性对码的传递函数依赖，确保数据表中每一列数据都和主键直接相关，而不能间接相关  BCNF（BC范式）消除每一属性对候选键的传递依赖，BCNF是修正的3NF1NF → 2NF：消除非主属性对码的部分函数依赖2NF → 3NF：消除非主属性对码的传递函数依赖3NF → BCNF：消除主属性对码的部分和传递函数依赖BCNF → 4NF：消除非平凡且非函数依赖的多值依赖候选码都是单个属性至少是 2NF关系模式的分解对存在数据冗余、插入异常、删除异常问题的关系模式，应采取一个关系模式分解为多个关系模式的方法进行处理，相应地，原来存储在一个二维表内的数据就要分散到多个二维表中，要使这个分解有意义，起码的要求是后者不能丢失前者的信息在分解处理中会涉及一些新问题，为使分解后的模式保持原模式所满足的特性，其基本要求是模式分解具有无损连接性和保持函数依赖性无损连接无损连接指的是对关系模式分解时，原关系模式下任一合法的关系实例在分解之后应能通过自然连接运算恢复起来即分解后的关系通过自然连接可以恢复为原关系保持函数依赖做模式分解后的 F’ (各个子模式函数依赖的并集) 是否与 F (原有的函数依赖集) 等价，F’ 包含所有的 F 中的函数依赖则可以得出保持函数的依赖性 (充分条件)即分解后依赖不变参考：模式分解保持函数依赖判断——数据库考试复习_guoyp2126的博客-CSDN博客已知 R (ABCDEGH), F={A-&gt;D, E-&gt;D, D-&gt;B, BC-&gt;D,DC-&gt;A}, 求保存函数依赖的 3NF 的分解1）求出最小函数依赖集2）把不在F里面的属性都找出来，单独分一类3）把每一个依赖左边相同的分成一类，没有一样的，那么就把A-&gt;D改为{AD}, 如果一样{A-&gt;B,A-&gt;C}那么就改为{ABC}4）如果候选码没出现在分离里面，把任意一个候选码作为一类最先函数依赖集Fmin={A-&gt;D, E-&gt;D, D-&gt;B, BC-&gt;D, DC-&gt;A}GH没在F里面，单独一类{GH}候选码：CEAE{AD}{ED}{DB}{BCD}{DCA}{CE}{GH}"
  },
  
  {
    "title": "数据库学习四 关系数据库理论",
    "url": "/archives/89",
    "categories": "数据库",
    "tags": "",
    "date": "2023-02-09 08:10:00 +0800",
    





    
    "snippet": "关系模式一个关系模式应当是一个五元组 (含关系名)R&lt;U, D, dom, F&gt;  R 为关系名，它是符号化的元组语义  U 为一组属性  属性组 U 中的属性来自域 D  dom 为属性列表到域的映射  F 为属性组 U 上的一组数据依赖 (函数依赖)由于第三点与第四点对模式设计关系不大，因此通常把关系模式看作是一个三元组：R&lt;U, F&gt;，当且仅当 U 上的一个关系...",
    "content": "关系模式一个关系模式应当是一个五元组 (含关系名)R&lt;U, D, dom, F&gt;  R 为关系名，它是符号化的元组语义  U 为一组属性  属性组 U 中的属性来自域 D  dom 为属性列表到域的映射  F 为属性组 U 上的一组数据依赖 (函数依赖)由于第三点与第四点对模式设计关系不大，因此通常把关系模式看作是一个三元组：R&lt;U, F&gt;，当且仅当 U 上的一个关系 r 满足 f 时，r 称为关系模式 R&lt;U, F&gt; 的一个关系例如：R 为成绩表，U 为 (学号，姓名，课程号，成绩)，F 为 {学号 → 姓名，课程号 → 课程名，(学号，课程号) → 成绩}函数依赖函数依赖是一种最重要、最基本的数据依赖设 R(U) 是属性集 U 上的关系模式，X、Y 是 U 的子集。若对 R(U) 的任何一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等，而在 Y 上的属性值不等，则称 X 函数决定 Y 或 Y 函数依赖于 X。记作 X → Y  非平凡的函数依赖如果 X → Y，但 Y ⊈ X，则称 X → Y 是非平凡的函数依赖。一般情况下，总是讨论非平凡的函数依赖  平凡的函数依赖如果 X → Y，但 Y ⊆ X，则称 X → Y 是平凡的函数依赖  完全函数依赖在 R(U) 中，如果 X → Y，并且对于 X 的任何一个真子集 X’ 都有 X’ 不能决定 Y，则称 Y 对 X 完全函数依赖，记作 X -F-&gt; Y  部分函数依赖如果 X → Y，但 Y 不完全函数依赖于 X，则称 Y 对 X 部分函数依赖，记作 X -P-&gt; Y。部分函数依赖也称为局部函数依赖  传递依赖在 R(U, F) 中，如果 X → Y，Y ⊈ X，Y → Z，则称 Z 对 X 传递依赖参考：Untitled Document (pop0726.github.io)码设 K 为 R(U, F) 中属性的组合，若 K → U，且对于 K 的任何一个真子集 K’ 都有 K’ 不能决定 U，则 K 为 R 的候选码。若有多个候选码，则选一个作为主码。候选码通常也称为候选键，或者候选关键字  主属性和非主属性包含在任意一个候选码中的属性称为主属性，否则称为非主属性  外码若 R(U) 中的属性或属性组 X 非 R 的码，但 X 是另一个关系的码，则称 X 为外码  超码能表示出所有属性的集合，候选码是最小的超码  全码所有的属性都是主码函数依赖的公理系统 (Armstrong 公理系统)设关系模式 R(U, F)，其中 U 为属性集，F 是 U 上的一组函数依赖，那么有以下 推理规则  自反律：若 Y ⊆ X ⊆ U，则 X → Y 为 F 所蕴涵  增广律：若 X → Y 为 F 所蕴涵，且 Z ⊆ U，则 XZ → YZ 为 F 所蕴涵  传递律：若 X → Y，Y → Z 为 F 所蕴涵，则 X → Z 为 F 所蕴涵根据上述三条推理规则又可推出下述三条推理规则  合并规则：若 X → Y，X → Z，则 X → YZ 为 F 所蕴涵  伪传递律：若 X → Y，WY → Z 为 F 所蕴涵，则 XW → Z 为 F 所蕴涵  分解规则：若 X → Y，Z ⊆ Y，则 X → Z 为 F 所蕴涵属性闭包计算闭包计算即找出候选码，如何选出候选码？  只出现在左边的一定是候选码  只出现在右边的一定不是候选码  左右都出现的不一定  左右都不出现的一定是候选码  再求确定的候选码的闭包，如果可以推出全部，那么当前确定的就是候选码，否则，你要把每一个可能的值放进当前确定的候选码里面进行求闭包例如：R&lt;U, F&gt;，U(A, B, C, D, E, G)  F = {AB → C, CD → E, E → A, A → G}, 求候选码1)只出现在左边：B, D    一定是候选码2)只出现在右边：G       一定不是候选码3)左右都出现的：A，C，E 不一定是候选码5)求闭包BD → 啥也推不出来，所以要把每一个可能的求闭包(BDA)+ ：可推出C，E，A，G    所以可以推出ABCDEG(BDC)+ ：可推出E，A，G       所以可以推出ABCDEG(BDE)+ ：可推出A，G，C       所以可以推出ABCDEG所以，它的候选码最终是{(BDA),(BDC),(BDE)}求最小函数依赖集如何求最小依赖集？1）拆右边为多个元素的（比如A-&gt;BC 拆为 A-&gt;B和A-&gt;C）2）出去当前元素，求它的闭包，把集合里面所有元素都弄完3）左边最小化（通过遮住元素来看能不能推出其他元素） 比如BCD，遮住B看能推出CD吗，遮住C看能推出BD吗，遮住D看能推出BC吗例：已知关系 R&lt;U,F&gt; U{A, B, C, D, E, F, G}F = {BCD-&gt;A, BC-&gt;E, A-&gt;F, F-&gt;G, C-&gt;D, A-&gt;G}  求F的最小依赖集解：// (1)(BCD)+ = BCDED(BC)+ = BCD(A)+ = AG(F)+ = F(C)+ = C(A)+ = AFG（删除，因为有G）// (2)BCD-&gt;A —&gt; BC-&gt;ABC-&gt;EA-&gt;FF-&gt;GC-&gt;D"
  },
  
  {
    "title": "数据库学习三 SQL 语言",
    "url": "/archives/88",
    "categories": "数据库",
    "tags": "MySQL",
    "date": "2023-02-08 08:00:00 +0800",
    





    
    "snippet": "SQL 语言的分类  DDL (Data Definition Language, 数据定义语言)在数据库系统中，每一个数据库、数据库中的表、视图和索引等都是数据库的对象，要建立和删除一个数据库对象，都可以通过 SQL 语言来完成。DDL 包括 CREATE、ALTER 和 DROP 等  DML (Data Manipulation Language, 数据操纵语言)DML 是指用来添加、...",
    "content": "SQL 语言的分类  DDL (Data Definition Language, 数据定义语言)在数据库系统中，每一个数据库、数据库中的表、视图和索引等都是数据库的对象，要建立和删除一个数据库对象，都可以通过 SQL 语言来完成。DDL 包括 CREATE、ALTER 和 DROP 等  DML (Data Manipulation Language, 数据操纵语言)DML 是指用来添加、修改和删除数据库中数据的语句，包括 INSERT、DELETE 和 UPDATE 等  DQL (Data Query Language, 数据查询语言)查询是数据库的基本功能，查询操作通过 SQL 数据查询语言来实现。例如，用 SELECT 查询表中的内容  DCL (Data Control Language, 数据控制语言)DCL 包括数据库对象的权限管理和事务管理等(一)、DDL 数据定义语言1. 建立数据库create database &lt;数据库名&gt;2. 建立基本表create table &lt;表名&gt;(\t&lt;列名&gt; &lt;数据类型&gt; [列级完整性约束条件],    [···,]    [表级完整性约束条件,]    [···])&lt;1&gt; 数据类型  INT / INTEGER : 整数  FLOAT(n) : 浮点数，精度至少为 n 位数字  NUMERIC(p, d) / DECIMAL(p, d) / DEC(p, d) : 定点数，由 p 位数字 (不包括符号、小数点) 组成，小数点后面有 d 位数字  CHAR(n) : 长度为 n 的定长字符串  DATETIME : 日期时间型-- 例如create table test(\tf1 char(10),    f2 int)&lt;2&gt; 列级完整性约束      not null : 不为空        unique : 唯一        not null unique : 不为空且唯一        default : 定义一个默认值  -- 例如create table test(\tf1 int not null,     -- 该列不能为空        f2 int unique,     -- 该列值可以为空，但每行应不一样        f3 int not null unique,     -- 该列不为空且每行不一样        f4 char(5) default 'nashi'     -- 若新增行未赋值，此列默认赋值 'nashi')&lt;3&gt; 表级完整性约束            名称      子句      对应关系完整性                  主键子句      PRIMARY KEY      实体完整性              检查子句      CHECK      用户自定义完整性              外键子句      FOREIGN KEY      参照完整性      -- 例如create table student(\tsid int,    primary key(sid) -- not null unique)-- 或者create table student(\tsid int primary key)create table course(\tcid int,    sid int,    score int,    check(score &gt;= 0 and score &lt;= 100),    foreign key(sid) references student(sid))对于完整性的检查  断言 (一般不主张用)CREATE ASSERTION &lt;断言名&gt; &lt;check子句&gt;  -- 其中check子句与where子句的表达式类似-- 删除断言名称DROP ASSERTION &lt;断言名&gt;;  触发器当对一个表增、删、改的时候，对触发器里面的条件进行检查，如果成立，则执行触发器里面的动作，否则不执行里面的动作。CREATE TRIGGER &lt;触发器名&gt;           -- 每当触发事件发生时，该触发器被激活{BEFORE|AFTER} &lt;触发事件&gt; ON &lt;表名&gt; -- 指明触发器激活的时间是在执行触发事件前或后REFERERCING NEW|OLD ROW AS &lt;变量&gt;  -- REFERENCING指出引用的变量FOR EACH{ROW|STATEMENT}            -- 定义触发器的类型，指明动作体执行的频率[WHEN &lt;触发事件&gt;] &lt;触发动作体&gt;      -- 仅当触发条件为真时才执行出发动作体 -- 删除触发器DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;3. 修改基本表结构  增加一个新列alter table &lt;表名&gt; add &lt;列名&gt; &lt;类型&gt;-- 例如alter table test add f3 datetime  修改一个列alter table &lt;表名&gt; alter column &lt;列名&gt; &lt;新类型&gt;-- MySQL-- alter table &lt;表名&gt; modify &lt;列名&gt; &lt;新类型&gt;-- 例如alter table test alter column f3 float-- alter table test modify f3 float  删除一个列alter table &lt;表名&gt; drop column &lt;列名&gt;-- MySQL-- alter table &lt;表名&gt; drop &lt;列名&gt;-- 例如alter table test drop column f3-- alter table test drop f34. 删除基本表drop table &lt;表名&gt;-- 例如drop table test(二)、DML 数据操纵语言以下内容的例子基于这几张表-- 注：为方便理解使用中文，在实际开发中，请尽量不要使用中文-- 学生表create table student(\t学号 char(5) not null unique,    姓名 char(8),    性别 char(2),    出生日期 datetime,    班号 char(5))-- 成绩表create table score(\t学号 char(5),    课程号 char(5),    分数 int)-- 教师表create table teacher(\t教师编号 char(5) not null unique,    姓名 char(8),    性别 char(2),    出生日期 datetime,    职称 char(6),    系别 char(10))-- 课程表create table course(\t课程号 char(5) not null unique,    课程名 char(20),    任课教师编号 char(5))1. INSERT 插入语句向 SQL 的基本表中插入数据有两种方式：直接插入元组值 或 插入一个查询的结果值  直接插入元组值insert into 表名[(列名序列)] values (元组值)[, ···]-- 或者insert into 表名[(列名序列)](table (元组值)[, (元组值), ···])-- 例如insert into studentvalues ('108', '张三', '男', '2000-01-01', '09033'),('109', '李四', '男', '2000-05-05', '09034')-- 插入指定列insert into student(学号，姓名，性别，出生日期)values (110, '王五', '男', '2000-04-18')  插入一个查询的结果值insert into 表名[(列名序列)] select &lt;查询语句&gt;-- 例如insert into studentselect 111, '赵六', '男', '2000-03-19', '09035'2. DELETE 删除语句delete from &lt;表名&gt; [where &lt;条件表达式&gt;]-- 例如delete from student -- 删除整个表的所有内容-- 删除学号为 111 的元组delete from studentwhere 学号 = 1113. UPDATE 修改语句update &lt;表名&gt;set &lt;列名&gt; = &lt;值表达式&gt;[, ···][where &lt;条件表达式&gt;]-- 例如update studentset 班号 = '09058'where 学号 = 110-- 或者update studentset 班号 = '09057', 性别 = '女'where 学号 = 110 and 班号 = '09058'(三)、DQL 数据查询语言SQL 数据查询功能是通过 SELECT 语句实现，完整语法如下select &lt;目标表的列名或列表达式序列&gt;from &lt;关系表序列&gt;[where &lt;行条件表达式&gt;][group by &lt;列名序列&gt;][having &lt;组条件表达式&gt;][order by &lt;列名&gt; [asc|desc]]1. 投影查询使用 SELECT 命令可以选择查询表中的任意列，当为多个列时，中间使用逗号 , 分隔。当 FROM 子句中的关系表不止一个时，每个表的表名都要写出-- 例如select 1 + 1select 学号 * 100 from student-- 查询学生学号与分数select student.学号, score.分数from student, score-- 查询所有列select *from student使用 DISTINCT 可以去除重复行-- 去除重复行，查询被选修的课程select distinct 课程号from score使用 AS 可为查询结果自定义列名-- 例如select 学号 as 'sno'from student2. 选择查询选择查询就是指定查询条件，只从源表提取或显示满足该查询条件的记录选择查询通常使用下列几类运算：            运算符      代码      描述                  集合成员运算符      INNOT IN      在集合中不在集合中              字符串匹配运算符      LIKE      与 _ 和 % 进行单个或多个字符匹配              空值比较运算符      IS NULLIS NOT NULL      为空不能为空              算数运算符      &gt;&gt;=«br /&gt;&lt;==&lt;&gt;      大于大于等于小于小于等于等于不等于              逻辑运算符      ANDORNOT      与或非      &lt;1&gt; 条件表达式的比较运算--- 查询分数在 60-80 之间的记录select *from scorewhere 分数 between 60 and 80-- 使用 between 指包含 60 与 80，即 [60, 80]-- 等价于 where 分数 &gt;= 60 and 分数 &lt;= 80&lt;2&gt; 字符串的匹配运算where [not] like '匹配串' [escape '匹配串']其中 '匹配串' 可以是完整字符串，也可以包含通配符 % 和 _  % : 代表任意长度的字符  _ : 代表任意单个字符&lt;3&gt; 集合的比较运算-- 查询成绩为 85、86 或 88 的记录select *from scorewhere 分数 in (85, 86, 88)&lt;4&gt; 逻辑组合运算-- 查询 09031 班的所有女学生select *from studentwhere 班号 = '09031' and 性别 = '女'3. 排序查询通过使用 ORDER BY 子句可以对查询结果进行排序-- 升序 asc (默认，可省略)select 学号, 姓名from studentorder by 学号-- 降序 descselect 学号, 姓名from studentorder by 学号 desc也可以指定多个列排序，将会先排序第一个，然后排序第二个-- 以课程号升序，分数降序检索结果select *from scoreorder by 课程号 asc, 分数 desc  ORDER BY 子句必须放在查询的最后！4. 聚合函数聚合函数实现数据统计等功能，用于对一组值进行计算并返回单一的值通常与 group by 子句一起使用，常用的聚合函数有：            函数名      描述                  AVG      平均值              COUNT      计算指定表达式中选择的项数COUNT(*) 统计查询输出的行数              MIN      最小值              MAX      最大值              SUM      数值总和              STDWV      计算指定表达式中所有数据的标准差              STDEVP      总体标准差      聚合函数参数的一般格式为：[all|distinct] expr其中 ALL 表示对所有值进行聚合函数运算，默认值。而 DISTINCT 指定每个唯一值都被考虑。expr 为表达式-- 查询 '09031' 班学生人数select count(*) as '人数'from studentwhere 班号 = '09031'5. 数据分组因为聚合函数只会输出一个结果，查询某个列和聚合函数放一起时会报错可以通过数据分组计算某一个类别的聚合函数结果，即聚合函数作用范围变成了每组的所有记录如果想使用聚合函数作为筛选条件，必须放在 HAVING 子句后-- 查询最低分大于 70，最高分小于 90 的学生学号select 学号from scorewhere 分数 is not nullgroup by 学号having min(分数) &gt; 70 and max(分数) &lt; 90当 WHERE 子句、GROUP BY 子句、HAVING 子句和聚合函数同时出现在一个查询中时，SELECT 命令的执行顺序如下：  执行 WHERE 子句，从表中选取行  由 GROUP BY 对选取的行进行分组  执行聚合函数  执行 HAVING 子句选取满足条件的分组-- 查询每个课程的平均分select 课程号, avg(分数)from scoregroup by 课程号  聚合函数作为条件只能放在 HAVING 子句后，不能放在 WHERE 子句后  当 SELECT 子句中由 列名 与 聚合函数 时，所有的 列名 都应该被分组6. 表的连接查询在 FROM 子句中指定要连接的表，在 WHERE 子句中给出连接条件select &lt;列名1&gt;[, ···]from &lt;表1&gt;[, ···]where 连接条件对于两个表的公共列，需要提供前缀，例如 student.学号在 SQL Server 中，连接分为内连接和外连接&lt;1&gt; 内连接 INNER JOINΘ 连接，等值连接，自然连接内连接是最基本的连接方式，使用 INNER JOIN 关键字，不使用该关键字时默认均为内连接  等值连接即两个表之间的连接关系为 “等于”-- 查询所有学生的姓名、课程号和分数列select student.姓名, score.课程号, score.分数from student, scorewhere student.学号 = score.学号-- 即select student.姓名, score.课程号, score.分数from studentinner join scoreon student.学号 = score.学号为简化输入，可以使用表的别名-- 上一个例子的简化select x.姓名, y.课程号, y.分数from student x, score ywhere x.学号 = y.学号  非等值连接即两个表之间的连接关系不是 “等于”  自连接将同一个表进行连接，这种连接称之为自连接-- 查询选修了 '3-105' 并且成绩高于 '109' 号同学成绩的学生记录select x.课程号, x.学号, x.分数from score x, score ywhere x.课程号 = '3-105' and x.分数 &gt; y.分数\t\tand y.学号 = '109' and y.课程号 = '3-105'order by x.分数 desc&lt;2&gt; 外连接 OUTER JOIN左外连接 : LEFT OUTER JOIN 或 LEFT JOIN右外连接 : RIGHT OUTER JOIN 或 RIGHT JOIN全外连接 : FULL OUTER JOIN 或 FULL JOIN-- 左外连接例子-- 查询所有课程的任课教师的姓名select course.课程名, teacher.姓名from course left join teacheron (course.任课教师编号 = teacher.教师编号)7. 子查询&lt;1&gt; 一般子查询当一个查询是另一个查询的条件时，换言之，当从表中选取数据行的条件依赖于该表本身或其他表的联合信息时，需要使用子查询来实现子查询最常用于 SELECT 语句中的 WHERE 子句中-- 查询与学号为 '105' 的同学同年出生的学生select 学号, 姓名, year(出生日期) as '出生年份'from studentwhere year(出生日期) = (\t\t\t\t\t\tselect year(出生日期)    \t\t\t\t\tfrom student    \t\t\t\t\twhere 学号 = '105'\t\t\t\t\t\t)&lt;2&gt; 相关子查询在一般子查询中，每个子查询仅执行一次，返回的值为主查询的 WHERE 子句所用。当主查询在判断每个待选行时，必须 “唤醒” 子查询，然后反馈给主查询。即内层的条件涉及到外层属性的子查询称为相关子查询-- 查询成绩比该课程平均成绩低的学生select 学号, 课程号, 分数from score awhere 分数 &lt; (\t\t\t\tselect avg(分数)    \t\t\tfrom score b    \t\t\twhere a.课程号 = b.课程号     \t\t\t\tand 分数 is not null\t\t\t\t)&lt;3&gt; 带 EXISTS 测试的子查询EXISTS 代表存在量词 ∃，只返回逻辑真值或逻辑假值-- 查询所有任课教师的姓名和系别select 姓名, 系别from teacher awhere exists (\t\t\t\tselect *    \t\t\tfrom course b    \t\t\twhere a.教师编号 = b.任课教师编号\t\t\t\t)或者还有 NOT EXISTS ，将结果取反8. 查询结果的并、交、差运算可以使用以下运算符将两个 SELECT 查询语句的结果进行相应运算  UNION : 并  INSTERSECT : 交  EXCEPT : 差-- 并的例子-- 查询所有教师和学生的姓名、性别和出生年份select 姓名, 性别, year(出生日期) as '出生年份'from teacherunionselect 姓名, 性别, year(出生日期) as '出生年份'from student-- order by 出生年份(四)、DCL 数据控制语言数据控制控制的是用户对数据的存储权力，是由 DBA (数据库管理员) 决定的数据库的安全性不安的因素：  非授权对数据库的恶意存取和破坏  数据库中重要的数据泄露  安全环境的脆弱性安全性控制：  用户身份鉴别：静态口令鉴别、动态口令鉴别、生物特征鉴别、智能卡鉴别  存取控制  自主存取控制方法 (用户可以自定义和分配其他用户的操作权限)自主存取控制DBMS (数据库管理系统) 数据控制应具有以下功能  通过 GRANT 和 REVOKE 将授权通知系统，并存入数据字典  当用户提出请求时，根据授权情况检查是否执行操作请求SQL 标准包括 DELETE 、INSERT 、SELECT 和 UPDATE 权限。SELETE 权限对应于 READ 权限，SQL 还包括了 REFERENCES 权限，用来限制用户在创建关系时定义外码的能力1. 授权的语句格式grant &lt;权限&gt;[, ···] on &lt;对象类型&gt; &lt;对象名&gt;[, ···]to &lt;用户&gt;[, ···][with grant option]不同类型的操作对象有不同的权限，常见的权限如下            对象      对象类型      操作权限                  属性列      TABLE      SELECT、INSERT、UPDATE、DELETE、ALL PRIVILEGES (4 种权限的总和)              视图      TABLE      SELECT、INSERT、UPDATE、DELETE、ALL PRIVILEGES (4 种权限的总和)              基本表      TABLE      SELECT、INSERT、UPDATE、DELETE、ALTER、INDEXALL PRIVILEGES (6 种权限的总和)              数据库      DATABASE      CREATETAB 建立表的权限，可由 DBA 授予普通用户        PUBLIC : 接受权限的用户可以是单个或多个具体的用户，PUBLIC 参数可将权限赋给全体用户  WITH GRANT OPTION : 若指定了此子句，那么获得了权限的用户还可以将权限赋给其他用户2. 收回权限语句格式revoke &lt;权限&gt;[, ···]on &lt;对象类型&gt; &lt;对象名&gt;[, ···]from &lt;用户&gt;[, ···]数据库的角色角色指的时一类人，比如 CEO、总监、普通职员，可以给一类人授权  角色的创建create role &lt;角色名&gt;  角色授权grant &lt;权限&gt; on &lt;对象类型&gt; &lt;对象名&gt; to &lt;角色1&gt;[, ···]  把角色授权给其他用户或角色grant &lt;角色&gt; to &lt;角色&gt;或&lt;用户名字&gt;[with admin option]with admin option 意味着这个用户可以把这权限授予其他角色或用户  角色权限的收回revoke &lt;权限&gt; on &lt;对象名&gt; from &lt;角色名字&gt;视图机制视图是从一个或者多个基本表或视图中导出的表，是一个虚拟表为不同的用户定义不同的视图，把不需要的数据给隐藏起来，这样用户就不会进行误操作视图的创建create view &lt;视图名(列表名)&gt;as select &lt;查询子句&gt;[with check option]  子查询的 SELECT 语句通常不允许含有 ORDER BY 子句和 DISTINCT 语句  WITH CHECK OPTION 表示对 UPDATE 、INSERT 、DELECT 操作时保证被操作的行满足视图定义中的谓语条件 (即子查询中的条件表达式)  组成视图的属性列名或者全部省略或者全部指定。如果省略，则隐含该视图由 SELECT 子查询目标列的主属性组成-- 关系模式：student(sno, sname, sex, SD, email)-- 建立 '计算机系 (CS)' 学生的视图，并且进行修改操作时-- 保证视图中只有计算机系的学生会受到影响create view cs-student\tas select sno, sname, sex\tfrom student\twhere SD = 'CS'\twith check option视图的删除drop view &lt;视图名&gt;--例如drop view cs-student审计把对数据库的所有操作都记录到审计日志中，然后就可以通过日志审查这个里面是否有一些非法的行为-- 对修改“SC”数据的操作进行审计AUDIT UPDATE ON SC;-- 取消对“SC”表的一切审计NOAUDIT UPDATE ON SC;数据加密通过一些加密算法，把明文变成密文，这样别人就无法查看索引利用索引可以使数据库程序无需对整个表进行扫描，就可以在其中找到所需数据数据库中的索引是某个表中一列或者若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单由内模式定义 (内模式定义所有的内部记录类型、索引和文件的组织方式)建立索引create [unique] [cluster] index &lt;索引名&gt;\ton &lt;表名&gt;(列名[次序], ···)次序：可选 ASC (默认) 或 DSCUNIQUE ：表明此索引的每一个索引值只对应唯一的数据记录CLUSTER ：表明要建立的索引是聚簇索引，意为索引项的顺序是与表中记录的物理顺序一致的索引组织删除索引drop index &lt;索引&gt;"
  },
  
  {
    "title": "数据库学习二 关系模型",
    "url": "/archives/87",
    "categories": "数据库",
    "tags": "",
    "date": "2023-02-07 06:00:00 +0800",
    





    
    "snippet": "关系模型中的基本术语关系数据库系统是支持关系模型的数据库系统。有关关系模型的的一些基本术语如下：  关系：一个关系就是一张二维表，每个关系有一个关系名  元组：表中的一行即为一个元组，对应存储文件中的一个记录值  属性：表中的列称为属性，每一列有一个属性名，属性值相当于记录中的数据项或者字段值  域：属性的取值范围，即不同元组对同一个属性的值所限定的范围  关系模式：对关系的描述称为关系模式...",
    "content": "关系模型中的基本术语关系数据库系统是支持关系模型的数据库系统。有关关系模型的的一些基本术语如下：  关系：一个关系就是一张二维表，每个关系有一个关系名  元组：表中的一行即为一个元组，对应存储文件中的一个记录值  属性：表中的列称为属性，每一列有一个属性名，属性值相当于记录中的数据项或者字段值  域：属性的取值范围，即不同元组对同一个属性的值所限定的范围  关系模式：对关系的描述称为关系模式，由关系名和其属性集合构成，关系模式的格式为：关系名(属性名 1，···，属性名 n)通常一个关系模式对应一个关系文件的结果  候选码 (候选键)：属性或属性组合，其值能够唯一地标识一个元组  主码 (主键)：在一个关系中可能有多个候选码，从中选择一个作为主码  主属性：包含在任何候选码中的属性称为主属性，不包含在任何候选码中的属性称为非主属性  外码 (外键)：如果一个关系中的属性或属性组并非该关系的码，但他们是另外一个关系的码，则称其为该关系的外码  全码：关系模式的所有属性组是这个关系模式的候选码，称为全码  超码 (超键)：一个包含码的属性集称为超码关系模型的定义关系的描述称为关系模式，他可以形式化地表示为：R(U, D, dom, F)其中 R 为关系名，U 为组成该关系的属性名集合，D 为属性组 U 中属性所来自的域，dom 为属性向域的映像集合，F 为属性间数据的依赖关系集合通常简记为 R(U) 或 R(A1, A2, ···)，其中 R 为关系名，U 为属性名集合，A1、··· 为个属性名关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成关系数据结构关系模型中数据的逻辑关系是一张二维表格关系操作集合关系模型给出了关系操作的能力常见的关系操作有：选择、投影、连接、除、并、交、差等查询操作和增加、删除操作等关系完整性约束关系模型中的三个完整性规则如下：  实体完整性：关系中主码的值不能为空或部分为空，也就是说，主码中属性即主属性不能取空值  参照完整性：如果关系 R2 的外码 X 与关系 R1 的主码相对应 (基本关系 R1 和 R2 不一定是不同的关系，即它们可以是同一个关系)，则外码 X 的每一个值必须在关系 R1 中主码的值中找到，或者为空值  用户定义的完整性：指用户对某一具体数据指定的约束条件进行检验关系代数运算符            运算符      符号      含义                  集合运算符      ∪–∩×      并差交笛卡尔积              专门的关系运算符      σπ⋈÷      选择投影连接除              比较运算符      ＞≥＜≤＝≠      大于大于等于小于小于等于等于不等于              逻辑运算符      ¬∧∨      非与或      传统的集合运算专门的关系运算符  连接连接有 θ 连接、等值连接与自然连接  θ 连接：连接条件不为等于  等值连接：连接条件为等于  自然连接：除去重复属性的等值连接。最常用的连接运算  投影投影运算是从关系的垂直方向进行运算，在关系 R 中选出若干属性列 A 组成新的关系，记作 πA(R)  选择选择运算是从关系的水平方向进行运算，是从关系 R 中选择满足给定条件的元组，记作 σF(R)  外连接外连接运算是连接运算的扩展，可以处理由于连接运算而缺失的信息  左外连接：取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值 null 填充所有来自右侧关系的属性  有外连接：取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，用空值 null 填充所有来自左侧关系的属性  全外连接：完成左外连接和右外连接的操作  除法符号转 SQL 语言关系 R:            A      B      C                  1      2      3              4      5      6              7      8      9      投影转 SQL 语言π?(?)select ? from ?πA, B, C(R) 或者 π1, 2, 3(R)select A, B, C from R  注：SQL 语言不支持列 (属性) 的序号选择转 SQL 语言π?(σ?(?))select ? from ? where ?πA, B, C(σB &gt;= ‘5’(R)) 或者 π1, 2, 3(σ2 &gt;= ‘5’(R))select A, B, C from R where B &gt;= '5'# 或者select A, B, C from R where B &gt;= 5笛卡尔积转 SQL 语言πR.A, R.B, R.C, S.A, S.B, S.D(R×S)select R.A, R.B, R.C, S.A, S.B, S.Dfrom R, S# 升序排列order by R.A asc自然连接转 SQL 语言关系 R(A, B, C) 与 S(B, C, D)πR.A, R.B, R.C, S.D(σR.B = S.B ∩ R.C = S.C(R×S))select R.A, R.B, R.C, S.Dfrom R, Swhere R.B = S.B and R.C = S.C"
  },
  
  {
    "title": "数据库学习一 数据库导论",
    "url": "/archives/86",
    "categories": "数据库",
    "tags": "",
    "date": "2023-02-06 19:57:35 +0800",
    





    
    "snippet": "引言之前数据库的写的很不好看，重新复习编写一下 (虽然这个也挺乱就是了)数据库的四个基本概念数据描述事物的符号记录数据库概括地讲，数据库数据具有永久存储、有组织和可共享的三个基本特点严格地讲，数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易拓展性，并可为各种用户共享数据库管理系统是位于用户和操...",
    "content": "引言之前数据库的写的很不好看，重新复习编写一下 (虽然这个也挺乱就是了)数据库的四个基本概念数据描述事物的符号记录数据库概括地讲，数据库数据具有永久存储、有组织和可共享的三个基本特点严格地讲，数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易拓展性，并可为各种用户共享数据库管理系统是位于用户和操作系统之间的一层数据管理软件。和操作系统一样是计算机的基础软件主要功能：      数据定义功能        数据组织、存储和管理        数据操纵功能        数据库的事务管理和运行管理        数据库的建立和维护功能        其他功能（通信功能，数据转换功能，互访和互操作功能等）  数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DBA）组成的存储、管理、处理和维护数据的系统计算机数据管理的发展  人工管理阶段 (20 世纪 50 年代中期以前)数据不保存、不共享，不具有独立性  文件系统阶段 (20 世纪 50 年代后期至 60 年代中后期)可保存，但共享性差，冗余度大，独立性差  数据库系统阶段 (20 世纪 60 年代 后期开始)数据库系统的出现使信息系统从以 加工数据的程序为中心 转向围绕 共享的数据库 为中心的新阶段，实现整体数据的结构化数据的共享性高、冗余度低且易扩充：数据可以大大减少数据冗余，节约存储空间，数据独立性高数据模型的分类根据模型应用的不同目的，可将模型分成两类或者两个层次，从信息世界中抽象的数据模型称为概念数据模型，从计算机世界中抽象出的 DBMS (数据库管理系统) 支持的数据模型称为结构数据模型 (或者数据模型)概念数据模型 (概念模型)概念数据模型是独立于计算机系统的模型，完全不涉及信息在系统中的表示，只是用来描述某个特定组织所关心的信息结构，即按照用户的观点来对数据和信息建模，用于信息世界建模，一般采用实体 - 联系方法 (E-R 方法) 表示。主要用于数据库设计概念数据模型中的几个常用术语如下：      实体：客观存在并可以相互区别的事物称为实体        属性：描述实体的特性称为属性        码：唯一标识实体的属性集称为码        实体型：用实体名及其属性集合来抽象和刻画同类实体        实体集：同一类型实体的集合        域：属性的取值范围称为该属性的域        联系：实体之间的对应关系称为联系    两个实体之间的联系有三种类型          一对一联系      一对多联系      多对多联系      实体 - 联系方法表示的概念数据模型称为 E-R 图。实体用矩形，属性用椭圆，并用无向边将其与有关实体连接结构数据模型 (逻辑模型)结构数据模型是直接面向数据库的逻辑结构，任何一个 DBMS 都以某个结构数据模型为基础。主要用于数据库管理系统的实现结构数据模型主要包括：层次、网状、关系和面向对象模型  层次模型层次模型是用 “树结构” 来表示数据之间的联系，它的数据结构是一颗 “有向树”  网状模型网状模型是用 “图结构” 来表示数据之间的联系  关系模型关系模型是一种用二维表格结构来表示实体以及实体之间联系的数据模型。每个二维表由行、列组成，又可称为关系，关系模式是对关系的描述。因此可以说，关系模型是由关系模式组成的集合物理模型是对数据最底层的抽象，它描述数据在系统内部的表述方法和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的数据库系统的结构数据库产品很多，存储结构也各不相同，但体系结构基本上都具有相同的特征，采用 “三级模式和两级映像”三级模式  概念模式 (基本表)也称为模式或逻辑模式，是数据库中全部数据的逻辑结构和特征的描述，是所有用户的公共数据视图  外模式 (视图)也称为用户模式或子模式，是用户与数据库系统的接口，是用户用到的那部分数据的描述  内模式 (存储文件)也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式两级映像数据库系统在三级模式之间提供了两级映像：模式/内模式映像、外模式/模式映像正因为这两级映像保证了数据库中的数据具有较高的逻辑独立性和物理独立性  模式/内模式映像 (存储)存在于概念级和内部级之间，实现了概念模式和内模式之间的相互转换当数据库的存储结构改变时，有数据库管理员对模式 / 内模式作相应改变，可以使模式保持不变，从而应用程序也不用改变。保证了数据与程序的物理独立性  外模式/模式映像 (视图)存在于外部级和概念级之间，实现了外模式和概念模式之间的相互转换当模式改变时，由数据库管理员对各个外模式 / 模式映像作相应改变，可以使外模式保持不变。应用程序不必修改。保证了数据与程序的逻辑独立性数据的独立性是指数据与程序独立，将数据的定义从程序中分离出去。数据的独立性是由 DBMS 的二级映像功能来保证的。数据的独立性包括数据的物理独立性和数据的逻辑独立性      数据的物理独立性：指用户的应用程序与数据库中数据的物理存储是相互独立的        数据的逻辑独立性：指用户的应用程序与数据库中的逻辑结构是相互独立的  数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。另外，由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改数据库系统的组成  硬件平台及数据库足够大的内存、磁盘或磁盘阵列等设备，较高的通道能力以提高数据的传送率  软件数据库管理系统，支持数据库管理系统运行的操作系统，具有与数据库接口的高级语言及其编译系统，以数据库管理系统为核心的应用开发工具，为特定应用环境开发的数据库应用系统  人员开发、管理和使用数据库的人员主要包括数据库管理员、系统分析员和数据库设计人员、应用程序员和最终用户数据库管理员职责：决定数据库中信息内容和结构、决定数据库的存储结构和存取策略、定义数据的安全性要求和完整性约束条件、监控数据库的使用和运行、数据库的改进和重组、重构"
  },
  
  {
    "title": "Linux 学习 第十二章 管理磁盘和文件系统",
    "url": "/archives/85",
    "categories": "Linux",
    "tags": "读书笔记",
    "date": "2023-01-03 13:37:48 +0800",
    





    
    "snippet": "第十二章 管理磁盘和文件系统12.1 了解磁盘存储器在大多数现代操作系统中，数据存储器的基本工作原理都是相同的。磁盘用作永久存储器，而 RAM (Random Access Memory，随机存储器) 和交换区则用作临时存储器。例如，当运行一条命令时，该命令将从硬盘复制到 RAM，以便计算机处理器 (CPU) 可以更快地访问该命令相对于从硬盘中访问数据，CPU 可以更快地从 RAM 中访问数...",
    "content": "第十二章 管理磁盘和文件系统12.1 了解磁盘存储器在大多数现代操作系统中，数据存储器的基本工作原理都是相同的。磁盘用作永久存储器，而 RAM (Random Access Memory，随机存储器) 和交换区则用作临时存储器。例如，当运行一条命令时，该命令将从硬盘复制到 RAM，以便计算机处理器 (CPU) 可以更快地访问该命令相对于从硬盘中访问数据，CPU 可以更快地从 RAM 中访问数据。但因为 RAM 造价过高，且断电即清除数据，磁盘容量是远大于 RAM 的当运行太多进程或运行了一个带有内存泄漏的进程而将 RAM 填满时，如果系统没有提供一种拓展系统内存的方法，则会导致新进程失败，于是便有了交换空间。采用一些算法将一些数据从 RAM 中换到磁盘中，在需要时再换回去  当需要在不同类型的操作系统之间交换文件时，通常采用 VFAT 文件系统12.2 对硬盘进行分区更改分区可能导致系统无法启动，建议先拿空硬盘熟练掌握后再实际应用12.2.1 理解分区表从传统上将，PC 体系结构的计算机使用 MBR (Master Root Record) 分区表来存储关于硬盘分区大小和布局信息。然而，近年来，一种被称为 GUID (Global Unique Identifier) 分区表的新标准在部分 UEFI 计算机体系结构的计算机上得到了应用，从而取代了较老的 BIOS 系统启动方法MBR 规范所固有的局限性带来了对 GUID 分区的需求。MBR 分区的大小被限制在 2TB，而 GUID 分区可以创建最大 9.4ZB 的分区fdisk 命令不支持 gpt 分区，可以使用 parted 命令12.2.2 查看磁盘分区fdisk -l /dev/sda 或 parted -l /dev/sdb      由 sd? 设备 (如 sda 、sdb 等) 所表示的 SCSI 或者 USB 存储设备最多可以有 16 个次要设备 (比如主 /dev/sdc 设备以及 /dev/sdc1 到 /dev/sdc15) ，所以共有 15 个分区        由 nvme 设备 (如 nvme0 、nvme1 等) 所表示的 NVMe SSD 存储设备可以划分一个或多个名称空间 (大多数设备只使用第一个) 和分区，例如 /dev/nvme0n1p1 表示第一个 nvme 设备上第一个名称空间的第一个分区        对于 x86 计算机，磁盘最多可以有 4 个主分区。所以如果想要 4 个以上的分区，至少有一个分区时扩展分区。四个主分区外的任何分区都是逻辑分区，使用了来自拓展分区的空间  12.2.3 创建单分区硬盘一般添加一个存储介质的过程：      安装新的硬盘或插入新的 USB 闪存驱动器        对新硬盘进行分区        在新硬盘上创建文件系统        挂载文件系统    如果使用 parted 命令进行修改，请谨慎执行每一步，因为 parted 命令的更改是立即生效的而 fdisk 命令是可撤销的，只有在确定应用更改时才会实际更改  数据无价，谨慎操作  确定新增加的设备的名称方法有许多，例如查看系统日志journalctl -f例如分配的名称为 /dev/sdb  如果设备自动挂载需要先卸载查看是否挂载 /dec/sdb：mount | grep sdb卸载分区：umount /dev/sdb1  使用 parted 命令创建分区parted /dev/sdb执行后将处于 parted 命令模式，可以使用 parted 单字母命令设置来使用分区  删除分区单命令 p 列出所有分区使用 rm 命令，回车后输入相应 Number 即可删除某分区  创建 gpt 分区表使用命令 mklabel gpt  创建新分区输入 mkpart 命令，系统会提示输入分区名称，文件系统类型，然后是分区的开始和结束例如命名 yexca-UDisk ，文件类型为 xfs ，分区从 1MB 开始，到 123GB 结束：(parted) mkpartPartition name? []? yexca-UDiskFile system type? [ext2]? xfsStart? 1End? 123GB  检查分区是否正确创建单命令 p 列出所有分区  分区创建完成后需要在分区上创建文件系统例如创建 xfs 文件系统：mkfs -t xfs /dev/sdb1若没有 -t 选项，默认创建 ext2 文件系统  挂载文件系统# 创建挂载文件夹mkdir /mnt/tmp# 挂载 /dev/sdb1 到 /mnt/tmpmount /dev/sdb1 /mnt/tmp  卸载文件系统使用命令 umount /dev/sdb1  默认情况下一般插入 USB 设备会自动挂载如果需要手动挂载，可在 /etc/fstab 添加一行/dev/sdb1    /mnt/tmp    xfs    defaults    0  1共六段      分区        挂载的文件夹        文件系统        分区启动时挂载        是否使用 dump 命令备份分区文件 (0 为不备份)        在一定的挂载数量之后对分区进行错误检查  12.2.4 创建一个多分区磁盘使用 fdisk 命令介绍  进入 fdisk 命令模式fdisk /dev/sdb  创建分区单命令 n ，然后选择主分区 p 或拓展分区 e ，选择分区位置 (默认即可)然后是分配的空间，起始空间可以默认，回车后输入结尾空间：例如分配 5 GB 空间则输入 +5G ，若直接输数字则会被认为是扇区第四个分区，即拓展分区，分配空间可以两次都是默认  检查分区单命令 p  默认的分区类型是 Linux ，如果想要转换分区类型使用命令 t ，选择分区数，然后输入 L 查看分区类型列表，找到十六进制码，然后输入以更改  检查更改并保存更改单命令 p 以检查，单命令 w 以保存更改  更改完毕后，检查内核是否知道对分区表的更改grep sdb /proc/partitions# 如果没有输出预料的结果，执行以下命令partprobe /dev/sdb# 再次检查grep sdb /proc/partitions  创建文件系统# 创建 ext4 文件系统mkfs -t ext4 /dev/sdb1# 创建交换区mkswap /dev/sdb2# 创建 ext2 文件系统 (默认值)mkfs /dev/sdb3# 创建 VFAT 文件系统mkfs -t vfat /dev/sdb4# 使该分区称为 LVM 物理卷pvcreate /dev/sdb512.3 使用逻辑卷管理分区如果磁盘空间不足，恐怕只能将数据复制到另一个更大的磁盘中，但该过程需要停机且效率低下LVM (Logical Volume Management ，逻辑卷管理) 可采用灵活且高效的方式处理更改存储器的需求。通过使用 LVM ，可将物理磁盘分区添加到被称为 卷组 的空间池。逻辑卷根据需要从卷组分配空间12.3.1 检查现有的 LVM使用命令 fdisk -l /dev/sda 查看是否存在 Linux LVM 分区，假设 /dev/sda2 为 LVM 分区查看该 LVM 分区是否在 LVM 组中使用pvdisplay /dev/sda2假设卷组 (VG Name) 是 vg_abc ，查看卷组的信息vgdisplay vg_abc可以从物理卷使用的最小存储单位是 PE (Physical Extent) Size查看卷组的 PE 分配的位置lvdisplay vg_abc输出将展示多个逻辑卷名称，这些逻辑卷可以和物理卷一样直接使用名字进行挂载12.3.2 创建 LVM 逻辑卷LVM 逻辑卷的使用是自上而下进行的，而创建 LVM 逻辑卷的过程则是从下而上进行。首先创建一个或多个物理卷 (pv) ，然后使用物理卷创建卷组 (vg) ，最后从卷组创建逻辑卷 (lv)  准备一个有 LVM 分区的存储设备创建过程 12.2.4 有提及  将该物理卷加入卷组vgcreate myvg0 /dev/sdb5  查看卷组vgdisplay myvg0  若分区为 400M ，可以使用 396M 空间 (以 4M 为单位)# 从卷组部分空间创建一个逻辑卷，例如创建 1G 逻辑卷lvcreate -n name -L 1G myvg0# 查看该逻辑卷是否存在ls /dev/mapper/myvg0*# 输出以下则创建成功/dev/mapper/myvg0-name  放入文件系统并挂载# 创建 ext4 文件系统mkfs -t ext4 /dev/mapper/myvg0-name# 创建挂载文件夹mkdir /mnt/tmp# 挂载mount /dev/mapper/myvg0-name /mnt/tmp# 检查是否挂载成功df -h /mnt/tmp  或者也可以写入 /etc/fstab 以自动挂载12.3.3 扩大 LVM 逻辑卷如果用完了逻辑卷的空间，可添加空间而不必卸载该逻辑卷。为此，卷组中必须有可用的空间，然后扩大逻辑卷  检查剩余空间# 检查卷组可用空间vgdisplay myvg0# 检查逻辑卷可用空间df -h /mnt/tmp  拓展逻辑卷lvextend -L +1G /dev/mapper/myvg0-name  调整文件系统大小resize2fs -p /dev/mapper/myvg0-name  检查是否调整成功df -h /mnt/tmp12.4 挂载文件系统事实上在上两节中已经涉及了挂载文件系统命令 mount 已经自动挂载配置 (文件 /etc/fstab)12.4.1 被支持的文件系统输入命令 cat /proc/filesystems 以查看支持的文件系统类型，以下仅部分            文件系统      描述                  ext4      流行的 ext3 文件系统的继承者。支持最大 1EB 的卷以及最大 16 TB 的文件              iso9660      从 High Sierra 文件系统 (CD-ROM 的原始标准) 演变而来。数据 CD-ROM 通常使用该文件系统              Minix      最初用于 UNIX 的 Minix 版本。支持最多只有 30 个字符的文件名              msdos      MS-DOS 文件系统类型，可用于挂载来自 Windows 操作系统的软盘              vfat      Microsoft 扩展的 FAT 文件类型              exfat      为 SD 卡、USB 驱动器和其他闪存优化的扩展 FAT 文件系统              proc      不是真正的文件系统。是一个 Linux 内核的文件系统接口。/proc 的挂载点应该是一个 proc 文件系统。许多实用工具依赖 /proc 才能访问 Linux 内核信息              ReiserFS      日志文件系统。曾经的多个 Linux 发行版本默认文件系统类型，但如今是 ext 和 xfs              swap      用于交换分区              squashfs      压缩且只读的文件系统类型              NFS      Network Filesystem，用于在其他 Linux 或 UNIX 计算机上挂载文件系统              ntfs      Windows NT 文件系统              xfs      最早由 Silicon Graphics 开发的高性能文件系统，可很好地使用大文件              gfs2      一种共享磁盘文件系统，运行多台计算机使用相沟通的共享磁盘，而不必通过网络文件系统层，如 CIFS 、NFS 等      输入 man fs 了解更多 Linux 文件系统相关信息12.4.2 启动交换区# 查看交换分区数量free -m# 创建交换分区mkswap /var/opt/myswap# 启用交换分区swapon /var/opt/myswap如果在 /etc/fstab 添加了交换分区相关条目，如：/var/opt/myswap swap swap defaults 0 0可以使用 swapon -a 启用12.4.3 禁用交换区swapoff /var/opt/myswap12.4.4 使用 fstab 文件定义可挂载的文件系统12.2.3 已介绍，不过字段二可以使用 UUID 而非设备名，因为设备名是可变的查看 UUID：blkid12.4.5 使用 mount 命令挂载文件系统同样在 12.2.3 已介绍12.4.6 以环回方式挂载磁盘镜像也就是将 ISO 镜像文件挂载# 创建挂载文件夹mkdir /mnt/tmp# 挂载mount -o loop name.iso /mnt/tmp12.4.7 使用 umount 命令可以输入设备分区名或目录名设备分区名：umount /dev/sdb1目录名：umount /mnt/tmp通常，最好使用目录名如果一个目录正繁忙无法被卸载，可以：      延迟卸载：umount -l        强制卸载：umount -f  12.5 使用 Cockpit 管理存储GUI ，开启参考第八章"
  },
  
  {
    "title": "Linux 学习 第十一章 获取用户账户",
    "url": "/archives/84",
    "categories": "Linux",
    "tags": "读书笔记",
    "date": "2023-01-02 12:29:03 +0800",
    





    
    "snippet": "第十一章 获取用户账户用户账户保持了使用系统的人与运行在系统中的进程之间的边界，而组是一种将系统的权限一次性分配给多个用户的方法11.1 创建用户账户每一个使用 Linux 系统的人都应该有一个单独的用户账户。通过拥有一个用户账户，可以提供用来完全存储文件的区域，以及调整用户界面 (GUI、路径、环境变量等) ，从而适合用户使用电脑的习惯可以通过 Cockpit 使用 GUI 创建账户，若没...",
    "content": "第十一章 获取用户账户用户账户保持了使用系统的人与运行在系统中的进程之间的边界，而组是一种将系统的权限一次性分配给多个用户的方法11.1 创建用户账户每一个使用 Linux 系统的人都应该有一个单独的用户账户。通过拥有一个用户账户，可以提供用来完全存储文件的区域，以及调整用户界面 (GUI、路径、环境变量等) ，从而适合用户使用电脑的习惯可以通过 Cockpit 使用 GUI 创建账户，若没有安装：yum install cockpit -ysystemctl enable --now cockpit.socket然后浏览器打开 localhost:9090 以操作11.1.1 使用 useradd 命令添加用户多数情况下使用 GUI 是比较麻烦的，所以可以使用 useradd 命令以添加用户 (root 权限) ，唯一必要的参数是用户的登录名，可用选项包括：            可用选项      描述                  -c “comment”      提供了对新用户账户的描述。一般为用户的全名              -d home_dir      设置账户所使用的主目录。默认使用登录名命名并放入 /home 目录              -D      并不创建新账户，而是将所提供的信息保存作为创建新用户的默认设置              -e expire_date      以 YYYY-MM-DD 格式分配账户的有效期限。例如：-e 2024-08-01              -f -1      设置密码过期后多少天，便永久封禁该账户。默认值 -1 表示禁用此选项              -g group      设置用户所在的主组 (必须已存在于 /etc/group 文件中) 。若没有该选项，将创建一个新组 (使用用户名作为组名) ，并将其作为用户的主组              -G grouplist      将新用户添加到以逗号分隔的增补组列表中。例如：-G wheel, sales, tech              -k skel_dir      设置用户主目录的文件，复制自 skel_dir ，默认为 /etc/skel              -m      自动创建用户的主目录。对于 Fedora 和 RHEL 该选项是默认的，但对于 Ubuntu 来说不是              -M      不创建用户主目录，尽管有 -m 选项也不创建              -n      禁用创建一个与新用户名和用户 ID 相匹配的新组的默认行为              -o      使用 -u uid 创建一个与另一个用户账户具有相同 UID 的用户账户              -p passwd      设置密码 (使用 MD5 加密过后的) 。如果此时未设置，可以使用 passwd user 命令。使用 openssl passwd 以输出通过 MD5 加密后的密码              -s shell      设置默认 shell 。例如：-s /bin/csh              -u user_id      为账户指定用户 ID 号，若没有则自动分配。自动分配给常规用户的 ID 从 1000 开始      一般情况使用：# root 权限下useradd yexcapasswd yexca在创建 yexca 这个账户的过程中，useradd 命令完成了以下活动：      读取 /etc/login.defs 和 /etc/default/useradd 文件，获取创建账户所使用的默认值        检查命令行参数，找出哪些默认值被重写        根据默认值和命令行参数，在 /etc/passwd 和 /etc/shadow 文件中创建新用户条目        在 /etc/group 文件中创建新的组条目        在 /home 目录中根据用户名创建一个主目录        将 /etc/skel 目录中的所有文件复制到新的主目录中。其中通常包括登录和应用程序启动脚本  在 /etc/passwd 文件中的用户行：yexca:x:1001:1001::/home/yexca:/bin/bash字段之间以冒号分隔，分别为登录名、密码、用户 ID 、主组 ID 、注释字段、主目录、默认登录终端密码字段为 x 是被加密存储在 /etc/shadow在 /etc/group 文件中的组行：yexca:x:1001:同样以冒号分隔，分别为组名、组密码、组 ID 以及组中用户列表11.1.2 设置用户默认值useradd 命令通过读取 /etc/login.defs 和 /etc/default/useradd 文件确定默认值，所以可以修改文件以修改默认值在不同 Linux 系统中 login.defs 不同，以下仅部分PASS_MAX_DAYS    99999PASS_MIN_DAYS    0PASS_MIN_LEN    5PASS_WARN_AGE    7UID_MIN    1000UID_MAX    60000SYS_UID_MIN    200SYS_UID_MAX    999GID_MIN    1000GID_MAX    60000SYS_GID_MIN    201SYS_GID_MAX    999CREATE_HOME    yes修改其他默认选项可以参阅 /etc/default/useradd 文件，可以通过 useradd -D 查看当前默认设置也可以将 -D 与一些其他选项搭配使用以修改 /etc/default/useradd 文件      -b default_home — 设置所创建主目录所在目录。通常为 /home        -e default_expire_date — 设置禁用用户账户的默认的截止日期。应当使用 YYYY-MM-DD 的日期格式        -f default_inactive — 设置密码过期后多少天账户被禁用        -g default_group — 新用户默认所在的组。通常会创建与用户具有相同名称和 ID 号的新组        -s default_shell — 默认 shell  11.1.3 使用 usermod 修改用户usermod 命令提供了一种简单明了的方法来更改账户参数            选项      描述                  -c “username”      更改描述              -d home_dir      更改主目录              -e expire_date      分配一个 YYYY-MM-DD 格式的新过期时间              -f -1      更改密码过期之后多少天永久禁用账户。默认值 -1 表示禁用该选项              -g group      更改用户所在主组 (需存在该组)              -G grouplist      将用户的附属组设置为以逗号分隔的组列表。如果想保留原先组，请使用 -Ga              -l login_name      更改登录名              -L      锁定账户 (在 /etc/shadow 文件的加密密码前添加一个感叹号)              -m      将原主目录内容复制到新主目录。仅当 -d 选项被使用时该选项才有效              -o      只能与 -u 一起使用以取消 UID 必须唯一的限制              -s shell      更改 shell              -u user_id      更改用户 ID              -U      接触锁定 (将 /etc/shadow 文件的加密密码前的感叹号删除)      11.1.4 使用 userdel 删除用户例如命令 userdel -r yexca 将用户 yexca 把 /etc/passwd 文件删除，-r 表示将主目录 /home/yexca 也删除在删除用户前可以先使用 find 命令查找用户遗留的文件，如：find / -user yexca -ls 或 find / -uid 1001 -ls因为没有分配给用户的文件可能会是一个安全隐患，比较好的做法是分配给一个真实的账户，可以使用 find / -nouser -ls 命令找到不与任何用户关联的文件11.2 了解组账户如果要在多个用户中共享一组文件，那么组账户是非常有用的通过 chgrp grpName fileOrDir 命令以更改文件或目录所属组11.2.1 使用组账户每一个用户都分配给一个主组，主组由 /etc/passwd 文件中每一条目的第三个字段的数字来表示一个用户可以属于多个增补组，也可以不属于任何增补组。如果用户 yexca 是组 yexca 和组 hi 的一名成员，那么在 /etc/group 文件中的条目将如下所示：yexca:x:1001:yexcahi:x:1002:yexca只有 root 权限的人才能改变分组，也就是普通用户无法更改自己的分组，也不能将其他用户添加到自己的组如果想要以某组身份创建文件，可以使用 newgrp 命令以临时成为某一组成员拥有 root 权限的用户可以使用 gpasswd 命令设置某组的组密码11.2.2 创建组账户创建：groupadd groupName分配组号：groupadd -g gid groupName或者更改某用户的组，可以使用组名或组号groupmod -g gid userNamegroupmod -n groupName userName而如果改变增补组，参考 usermod 命令11.3 在企业中管理用户通过使用 ACL (Access Control Lists) 技术以使任何用户，可将文件或目录的特定权限分配给任何用户和组11.3.1 使用 ACL 设置权限两个命令，设置 setfacl 和获取 getfacl 某目录权限设置时，通过 -m 修改或 -x 删除权限，例如setfacl -m u:userName:rwx filename11.3.2 为用户添加目录以便进行协作当使用 chmod 命令更改权限时，一般会忽略一组特殊的三权限位，这些权限位可以在命令和目录上设置特殊权限例如：chmod 775 /home/yexca/tmp.txt ，实际上权限为 0775            名称      数值      字母值                  设置用户 ID 位      4      u+s              设置组 ID 位      2      g+s              粘滞位      1      o+t        创建组协作目录 (设置 GID 位)# 创建一个用于协作的组groupadd -g 301 cooperation# 添加一些用户usermod -aG cooperation yexca# 创建协作目录mkdir /mnt/co-tmp# 将组 cooperation 分配给该目录chgrp cooperation /mnt/co-tmp# 更改目录权限chmod 2775 /mnt/co-tmp# 此时如果查看该目录权限应该为 rwxrwsr-x现在，若用户 yexca 在目录 /mnt/co-tmp 创建一个文件，该文件所属组为 cooperation，而不是 yexca  创建受限制的删除目录 (粘滞位)命令：chmod 1775 /mnt/tmp在受限制的删除目录中，除非是 root 用户或者目录的拥有者，不能删除其他用户的文件，即使拥有写入权限例如 /tmp 目录就是一个受限制的删除目录 (权限为 rwxrwxrwt)  设置用户位 Set UID  拥有设置用户位的可执行文件 (rwsr-xr-x) 代表其他用户可执行，但执行命令进程为拥有该文件的用户  例如 su 命令，所有用户可执行，但执行的进程属于 root 用户11.4 集中用户账户Linux 默认验证用户的方法是根据 /etc/passwd 文件和 /etc/shadow 文件的密码，但也可以使用其他方式例如 LDAP (Lightweight Directory Access Protocol)、NIS (Network Information Service)、Winbind 等"
  },
  
  {
    "title": "Linux 学习 第十章 获取和管理软件",
    "url": "/archives/83",
    "categories": "Linux",
    "tags": "读书笔记",
    "date": "2022-12-08 16:35:57 +0800",
    





    
    "snippet": "第十章 获取和管理软件10.1 在桌面管理软件通过软件与 GUI 管理10.2 超越 Software 窗口Software 中能检索到的软件有限10.3 了解 Linux RPM 和 DEB 软件包软件包称为 tarball (压缩包)，包含可执行文件 (命令)、文档、配置文件以及库  DEB (.deb) 包Debian GNU/Linux 项目创建了 .deb 包，这种包被 Debia...",
    "content": "第十章 获取和管理软件10.1 在桌面管理软件通过软件与 GUI 管理10.2 超越 Software 窗口Software 中能检索到的软件有限10.3 了解 Linux RPM 和 DEB 软件包软件包称为 tarball (压缩包)，包含可执行文件 (命令)、文档、配置文件以及库  DEB (.deb) 包Debian GNU/Linux 项目创建了 .deb 包，这种包被 Debian 以及其他基于 Debian 的发行版本 (Ubuntu、Linux Mint、KNOPPIX 等) 所使用。通过 apt 或 dpkg 命令以安装、管理、更新和删除软件  RPM (.rpm) 包最初为 Red Hat Package Manager，后被命名为 RPM Package Manager。RPM 是 SUSE、Red Hat 发行版本 (RHEL、Fedora) 以及其他发行版本 (需基于 Red Hat 发行版本，如 CentOS、Oracle Linux 等) 的首选软件包格式。通过原先的 rpm 或增强的 yum 以及现在的 dnf 命令管理软件yum 终将被 dnf 命令所取代10.3.1 理解 DEB 包Debian 软件包以存档文件格式保存了许多文件以及与一些软件相关的元数据。这些文件可以是可执行文件 (命令) 、配置文件以及其他软件项目。而元数据包括依赖项、许可、包大小、描述以及其他信息通过 apt* 命令以获取 (apt-get) 、搜索 (apt-cache search) 、查看详情 (apt-cache show) 、安装 (apt-get install) 、升级 (apt-get upgrade) 、列出已安装软件 (apt-cache pkgnames) 等通过 aptitude 命令以在 shell 中使用面向屏幕的菜单从而安装软件10.3.2 理解 RPM 包RPM 包是不同文件的合并，而每个文件提供了一项功能。RPM 内部可以是构成软件功能的命令、配置文件以及文档或者元数据 (关于软件包的内容、软件包的来源、运行所需的条件以及其他信息)使用 rpm -q -i pakageName 命令查看某软件信息10.4 使用 yum 管理 RPM 软件包10.4.1 从 yum 到 dnf 的转换DNF 自称为 Dandified yum https://github.com/rpm-softwes-management/dnf/虽然 dnf 与 yum 保持了基本的命令行兼容性，但主要区别之一是它遵循严格的 API，并鼓励开发 dnf 的扩展和插件以下 yum 命令均可作为 dnf 命令使用有关 dnf 更多信息，可参考 https://dnf.readthedocs.io/10.4.2 了解 yum 的工作原理基本语法 yum [options] command例如安装 Firefox：yum install firefox  检查 /etc/yum.conf文件中gpgcheck 表明是否对软件包验证installonly_limit=3 表明允许在系统中保存同一包的最多三个版本 (请不要将其设置为小于 2，以确保始终拥有至少两个内核包)clean_requirements_on_remove=True 表示在卸载某软件将一起卸载依赖项 (如果该依赖不被其他软件使用)best=True 表示升级软件时优先尝试最新版本cachedir 表示缓存位置keepcache 是否保留缓存debuglevel 写入日志的详细级别，越高越详细metadata_expire 元数据超时时间详细了解，使用 man yum.conf 命令  检查 /etc/yum.repos.d/*.repo 文件若想启用某软件库，将 .repo 文件放到此目录。文件内容大致如下[myrepo]    # 开头，`[]` 内为库名name=My repo    # 详细描述baseurl=https://rpmrepo.yexca.xyz/    # 虚构网址，不存在# 包含 RPM 文件的 url 可以是 http://, ftp://,file://enabled=1    # 是否启用该库，若没有默认启用gpgcheck=1    # 是否检查软件包签名gpgkey=file:///etc/MYKEY    # 用于检查软件包的密钥位置可以启用任意数量的软件库，但每次允许 yum 命令时将检查每一个库，将软件包相关元数据下载到本地系统，所有不要启用过多的软件库  从 YUM 库中下载 RPM 软件包和元数据在 rpm 目录有一个 repodata 目录，为所有启用库的 repodata 目录汇总元数据信息存储在 /var/cache/yum ，在达到超时时间后将获取最新元数据，yum 默认为 6h，dnf 默认为 48h  将 RPM 软件包安装到 Linux 文件系统相关软件下载到缓存中后，yum 命令通过运行 rpm 命令安装。如果软件包有脚本，先执行脚本。然后将软件包内容 (命令、配置文件、文档等) 复制到 RPM 元数据指定位置。最后运行安装后执行的脚本  将 YUM 库的元数据存储到本地 RPM 数据库包含在每个 RPM 软件库中的元数据最终被复制到本地的 RPM 数据库中，而 RPM 数据库存储在 /var/lib/rpm 目录的多个文件中10.4.3 借助第三方软件库使用 yum为了稳定性，建议仅使用官方自带，但自己使用以舒适度优先，可以启用 RPM Fusion 第三方库，参考 https://rpmfusion.org/10.4.4 使用 yum 命令管理软件  搜索软件包yum search keyword  获取某软件详细信息yum info firefox  若知道命令、配置文件或库名，但不知道软件包名称yum provides keyword  使用 list 子命令以不同方式列出软件包名称yum list firefoxyum list availableyum list installedyum list all  查看某软件包的依赖、提供者等yum deplist firefox | less  安装和删除软件包  install 子命令用于安装一个或多个软件包，以及相应依赖包yum install firefox 或 yum -y install firefox 以不需要同意之间安装  reinstall 子命令可以重新安装某软件yum reinstall firefox  remove 子命令删除软件及其他包不需要的依赖项yum remove firefox  或者通过历史记录撤销  使用 yum history 查看安装历史记录，yum history info 12 查看 id 为 12 的安装历史记录详情，yum history undo 12 撤销 id 为 12 的安装事务  更新软件包yum check-update 检查更新，yum update 更新全部软件，yum update firefox 更新 Firefox  更新软件包组为更方便地管理一套完整的软件包，yum 支持软件包组yum grouplist | less 查看软件包组yum groupinfo LXDE 查看 LXDE 桌面相关软件包组yum groupinstall LXDE 安装 LXDE 软件包组yum groupremove LXDE 删除整个 LXDE 组  维护 RPM 软件包数据库和缓存yum clean packages 清除软件安装包yum clean metadata 清除元数据yum clean all虽然可能不大，但 RPM 数据库有受损的可能yum check 检查缓存和数据库情况rpm --rebuilddb 重建数据库注：一般使用本地 RPM 数据库的最适合命令为 rpm  从 YUM 库下载 RPM只是下载，但不安装，下载到当前目录yumdownloader firefoxdnf download firefox10.5 使用 rpm 命令安装、查询和验证软件大部分情况下使用 rpm 命令对本地的安装包文件使用10.5.1 使用 rpm 安装和删除软件包  安装rpm -i pakageName需要使用 rpm 包的完整名称，即包括基名、版本、内核等  升级rpm -Uhv pakageName-h 为打印 # 标识 (安装进度) ，-v 为更详细的输出  更新若当前目录有数以千计的 rpm 包，仅想对以此计算机已经安装过的升级rpm -Fhv *.rpm  重新安装rpm -Uhv --replacepkgs pakageName  降级rpm -Uhv --oldpackage pakageName  删除删除时仅需要基名，如删除 Firefoxrpm -e firefox但并不会删除该软件的依赖10.5.2 查询 rpm 信息安装玩软件后，使用 -q 选项以查询关于该软件包的信息，如相关描述 -qi 、文件列表 -ql 、配置文件 -qc查询使用基名即可，如：rpm -qi firefox还可以查询依赖 -q --requires 、软件包所提供的软件版本 -q --provides 、删除之前和之后运行的脚本 -q --scripts 、更改日记 -q --changelog通过 --queryformat 查询信息的不同标记，--querytags 以查看所有可用标记  以上为本地 RPM 数据库查询，若添加 -p 选项可查询当前目录的软件包，此时需要输入全程，如 rpm -qip zsh-5.7.1-1.fc30.x86_64.rpm10.5.3 验证 rpm 软件包注：该选项查阅其他资料并未发现，但本人 Linux 已删除，无法验证 (之前用的时候看到这没复现) ，但既然看到了，还是记录一下比较好通过使用 -V 选项对已安装的软件包检查，了解自首次安装以来是否被更改。若二进制文件 (/bin 目录下) 被更改，可能表明系统被破解。配置文件更改很常见查询已安装的 Firefox 的情况 rpm -V firefox如果输出以下字符，代表相应地方被修改；没有输出表示每个文件为原始状态            字符      描述                  S      文件大小不一致              M      模式不一致 (包括许可和文件类型)              5      MD5 校验不一致              D      设备主要 / 次要编号不匹配              L      readLink (2) 路径不匹配              U      用户所有权不一致              G      组所有权不一致              T      mTime 不一致              P      caPabilities 不一致      这些指示符来自 rpm 手册的 Verify 部分可以使用 --replacekgs 以恢复至原始状态  如果对安全性要求过高，可以备份 RPM 数据库，即 /var/lib/rpm 目录，然后存入只读介质，毕竟如果数据库也被破解，那校验将毫无意义10.6 在企业中管理软件如 Kickstart 文件、PXE 启动、Satellite 服务器 (Spacewalk) 、容器映像可以自动化批量安装软件"
  },
  
  {
    "title": "Linux 学习 第八、九章 学习系统管理与安装 Linux",
    "url": "/archives/82",
    "categories": "Linux",
    "tags": "读书笔记",
    "date": "2022-12-07 16:29:05 +0800",
    





    
    "snippet": "第八章 学习系统管理8.1 理解系统管理      su 命令 — 以 root 用户身份打开一个 shell        sudo 命令 — 普通用户通过此命令运行其他命令时，该才会被赋予 root 权限  8.2 使用图形化管理工具Cockpit 是基于浏览器的系统管理工具  安装 Cockpitsudo dnf install cockpit  以 root 身份登录，启用 Cock...",
    "content": "第八章 学习系统管理8.1 理解系统管理      su 命令 — 以 root 用户身份打开一个 shell        sudo 命令 — 普通用户通过此命令运行其他命令时，该才会被赋予 root 权限  8.2 使用图形化管理工具Cockpit 是基于浏览器的系统管理工具  安装 Cockpitsudo dnf install cockpit  以 root 身份登录，启用 Cockpit 套接字sudo systemctl enable --now cockpit.socker  在浏览器打开界面： localhost:90908.2.1 使用 system-config-* 工具            工具      命令      描述                  域名系统      system-config-bind      如果计算机充当 DNS 服务器，应创建和配置区域 (Zone)              HTTP      system-config-httpd      Apache Web 服务器              NFS      system-config-nfs      设置与其他使用了 NFS 服务的计算机共享的目录              Root Password      system-config-rootpassword      更改 root 密码              Samba NFS      system-config-samba      配置 Win 共享文件夹              Services      system-config-services      显示和更改 Fedora 中在不同运行级别的服务              Authentication      authconfig-gtk      更改系统中对用户进行身份验证的方式              Date &amp; Time      system-config-date      设置日期和时间或与 NTP 服务器保存同步              Firewall      system-config-firewall      配置防火墙              Language      system-config-language      选择语言              Printing      system-config-printer      配置本地和网络打印机              SELinux Management      policycoreutils-gui      设置 SELinux 的强制模式和默认策略              Users &amp; Groups      system-config-users      用户账户相关      8.3 使用 root 用户账户8.3.1 通过 shell 成为 root 用户使用命令 su 即可转为 root 用户，但此时环境变量还是原来的账户使用 su - 以将变量也转变为 root 用户的此外，通过 su - username 可切换到指定用户8.3.2 使用 sudo 获取管理访问权限使用 sudo 运行的命令拥有 root 权限，而且不需要 root 密码，只需要赋予相应用户权限即可以下为赋予 sudo 权限      以 root 身份运行 visudo 命令        添加如下所示行  yexca    ALL=(ALL)    ALL# 或下面为使用 sudo 时不需要密码# (该用户的密码，不是 root 用户的密码)yexca    ALL=(ALL)    NOPASSWD:ALL这样将赋予用户 yexca 以 sudo 权限  保存更改后文件8.4.2 管理配置文件大部分配置文件以纯文本的形式存在 /etc 目录下，以下为部分文件            目录      描述                  /etc/cron*      定义了 crond 计划执行的程序，如 cron.daily、cron.hourly              /etc/cups      配置 CUPS 打印服务的文件              /etc/default      为各种实用工具设置默认值的文件              /etc/httpd      配置 Apache Web 服务器行为              /etc/rc?.d      针对每一种有效的系统状态，都有一个单独的 rc?.d 目录：rc0.d (关闭状态)、rc1.d (单用户状态)、rc2.d (多用户状态)、rc3.d (多用户加网络状态)、rc4.d (用户定义的状态)、rc5.d (多用户、网络与 GUI 登录状态) 和 rc6.d (重新启动状态)              /etc/skel      创建新用户时，该目录文件被复制到新用户的主目录              /etc/sysconfig      包含各种服务所创建和维护的重要系统配置文件              /etc/systemd      包含与 systemd 实用工具 (用来管理启动进程和系统服务) 相关联的文件              /etc/xinetd.d      包含一组文件，每一个文件定义了一个 xinted 守护进程监听某一个特定端口所需的点播网络服务      8.4.3 管理日志文件和 Systemd.Journalrsyslogd 和 systemd 的 journalctl 命令rsyslogd 及前身 syslogd 将文件放到 /var/log 目录8.5 使用其他管理账户例如 lp 、apache 、bin 等用户，默认不允许登录如果要登录需要将默认 shell 从 /sbin/nologin 或 /bin/false 改为真实 shell，例如 /bin/bash8.6 检查和配置硬件8.6.1 检查硬件通过 dmesg 或 journalctl 命令查看 Linux 启动时硬件检测信息以及驱动加载信息通过 lspci 命令查看计算机上 PCI 总线及连接到这些总线上的设备，lsusb 命令列出 USB 设备信息，lscpu 列出处理器信息8.6.2 使用可加载模块如果想添加未被正确识别的硬件，可能需要手动加载  列出可加载模块通过 lsmod 命令，如要获取某一模块详情，通过 modinfo -d 模块 命令  加载模块使用 modprobe 命令加载任何被编译并安装到运行内核的模块  删除模块使用 rmmod 命令，或使用 modprobe -r 以将依赖模块一起删除8.7 小结在 Linux中应该把各项服务 (http、git 等) 单独创建用户并限制登录权限以保证系统安全第九章 安装 Linuxなし图形化安装不必多说，其他安装可参考 Arch 参考手册我也写了一篇比 Arch 手册垃圾的文章：虚拟机中 Arch Linux 安装记录 – yexca’Blog另有远程安装例 PXE 启动之类因无法复现，无法理解"
  },
  
  {
    "title": "Linux 学习 第七章 编写简单的 shell 脚本",
    "url": "/archives/81",
    "categories": "Linux",
    "tags": "读书笔记",
    "date": "2022-12-05 20:47:43 +0800",
    





    
    "snippet": "第七章 编写简单的 shell 脚本如果需要反复执行某一任务，而该任务又需要输入大量的命令行，那么可以通过写入 shell 脚本以实现一条命令完成所有任务7.1 理解 shell 脚本shell 脚本是一组包含命令、函数、变量或其他可以通过 shell 使用的功能。这些项目被输入一个纯文本文件中，而该文件可以作为一条命令来运行  类似于 Windows 中的批处理文件 (.bat)7.1.1...",
    "content": "第七章 编写简单的 shell 脚本如果需要反复执行某一任务，而该任务又需要输入大量的命令行，那么可以通过写入 shell 脚本以实现一条命令完成所有任务7.1 理解 shell 脚本shell 脚本是一组包含命令、函数、变量或其他可以通过 shell 使用的功能。这些项目被输入一个纯文本文件中，而该文件可以作为一条命令来运行  类似于 Windows 中的批处理文件 (.bat)7.1.1 执行和调试 shell 脚本shell 脚本的主要优点是可以在任何文本编辑器中打开以查看脚本的内容，最大的缺点是大型或复杂的 shell 脚本的执行通常比编译后的程序要慢。可以通过两种基本的方法执行 shell 脚本      将脚本名称作为 shell 的一个参数，例如：bash myscript        在 shell 脚本第一行添加解释器名称 (#!/bin/bash)，给该文件添加执行权限后 (chmod +x myscript)，通过在命令行输入脚本的路径运行，例如 (./myscript.sh)  在执行时跟在脚本名称后面的为命令行参数  注释为 #  可以在脚本开头添加 set-x 以使用 $ bash -x myscript 显示正在执行的命令7.1.2 理解 shell 变量shell 变量中的变量名称是大小写敏感的，注意定义时等号 (=) 左右无空格，例如NAME=value可以为变量分配常量，例如文本、数字及下划线也可为变量赋值一个命令，例如：MYDATE=$(date) 以将 date 命令的输出分配给变量 MYDATE这样每次使用变量 MYDATE 将运行一次 date 命令并将结果赋值给 MYDATE 。可以将命令放在引号 ' 中以获得赋值时命令的运行结果特殊的 shell 字符：美元符号 ($)、引号 (')、星号 (*)、感叹号 (!) 等如果想在命令行输出显示 $HOME 需要转义 $，可使用 echo '$HOME' 或 echo \\$HOME ，即：如果想要 shell 从字面上解释单个字符，使用反斜杠 \\如果想从字面上解释一组字符，则使用单引号 (') 包围这些字符如果想从字面上解释一部分字符，使用双引号 (\") 包围一组文本，其中美元符号 ($)、引号 (') 和感叹号 (!) 将被解释，而其他字符 (例如星号 *) 则不会被解释  为变量赋值直接使用变量名，而引用变量，即需要获取变量值时需要在变量名前加美元符号 ($)  例如将某变量的值赋值给新变量：newVar=\"$oldVar\"      特殊的 shell 位置参数  位置参数 ，或 命令行参数 ，名为 $0、$1、$2…$n其中 $0 为被调用脚本的名称，而其他的则被赋予从命令行传递而来的参数值，例如：#!/bin/bashecho \"第一个参数是 $1 ，第二个参数是 $2 \"echo \"该脚本名称为 $0 \"echo \"一共传入了 $# 个参数\"echo \"所有的参数为：$@ \"执行命令：./myscript hello bye ，运行结果为下：第一个参数是 hello ，第二个参数是 bye该脚本名称为 /home/yexca/tmp/myscript一共传入了 2 个参数所有的参数为：hello bye还有一个有意思的参数 $? 接受最后一条被执行的命令的退出状态，一般正常退出会返回 0      读取参数  通过使用 read 命令读取用户输入#!/bin/bashread -p \"请输入两个名词：\" var1 var2echo \"刚刚输入了 $var1 和 $var2\"  在 Bash 中进行参数扩展想获取一个变量的值，需要在变量名前加美元符号 ($) ，例如 $var ，这其实是 ${var} 的简写Bash 有一些规则可以以不同方式扩展参数值，以下为比较常用的，以 ${var} 为例            示例      描述                  ${var:-value}      如果变量未设置或为空，在将其扩展为 value              ${var#pattern}      从 var 的值的 前面 开始砍掉与 pattern 最 短  的匹配项              ${var##pattern}      从 var 的值的 前面 开始砍掉与 pattern 最 长 的匹配项              ${var%pattern}      从 var 的值的 末尾 开始砍掉与 pattern 最 短 的匹配项              ${var%%pattern}      从 var 的值的 末尾 开始砍掉与 pattern 最 长 的匹配项      基于这些特性，可以有一些有用的应用，例如：myFileName=/home/yexca/myfile.txt# file 变为 myfile.txtfile=${myFileName##*/}# dir 变为 /home/yexcadir=${myFileName%/*}# name 变为 myfilename=${file%.*}# extension 变为 txtextension=${file##*.}7.1.3 在 shell 脚本中执行算法Bash 使用了非类型化变量，除非使用 declare 告诉 Bash，否则变量被视为字符串。在进行运算时会自动转为整数，不需要在赋值时指定类型可以使用内置 let 命令或外部 expr 命令或 bc 命令完成整数运算如：let result=$num/16 ，或 let num=$RANDOM同时也有自增运算符，i++ 和 ++i  let 命令要求每个操作数与数学运算符之间不能存在空格  expr 命令则要求每个操作数和数字运算符之间存在空格  而 bc 命令对空格没有要求，可以完成浮点运算7.1.4 在 shell 脚本中使用编程结构  “if…then” 语句if [ %var -eq 1 ]; then    echo \"The var is 1\"fi如果比较数字，-eq 比较好，但若比较字符串值，等号 (=) 不失为一个更好的选择if [ $str = \"hello\"]; then    echo \"hello\"fi此外还有不等号 !=通过使用 elif 语句，以提供更多的选择。使用 else 以代表其他情况$str=\"$HOME\"if [ -f \"$str\"]; then    echo \"$str 是一个普通文件\"elif [ -d \"$str\"]    echo \"$str 是一个目录\"else    echo \"???\"fi以下是一些可使用的测试条件            运算符      测试的内容                  -a file      文件是否存在，与 -e 相同              -b file      文件是否为一个专用设备              -c file      文件是否是特殊字符或字符设备。用来识别串行线路和终端设备              -d file      文件是否是一个目录              -e file      文件是否存在，与 -a 相同              -f file      文件是否存在，是否为普通文件 (不是目录、套接字、管道、链接或设备文件)              -g file      文件是否设置了 SGID 位              -h file      文件是否设置了一个符号链接，与 -L 相同              -k file      文件是否设置了粘滞位              -L file      文件是否设置了一个符号链接，与 -h 相同              -n string      字符串的长度是否大于 0 字节              -O file      是否拥有该文件              -p file      文件是否为命名管道              -r file      文件是否可读              -s file      文件是否存在，并且大于 0 字节              -S file      文件是否存在，并且为套接字              -t file      文件是否为连接到终端的描述符              -u file      文件是否设置了 SUID 位              -w file      文件是否可写              -x file      文件是否可执行              -z string      字符串的长度是否为 0 字节      以下为两个变量之间比较            运算符      测试的内容                  expr1 -a expr2      俩表达式是否都为真              expr1 -o expr2      有一个为真              file1 -nt file2      第一个文件是否比第二个文件新 (使用修改时间戳)              file1 -ot file2      第一个文件是否比第二个文件旧 (使用修改时间戳)              file1 -ef file2      两个文件是否通过一个链接相关联 (硬链接或符号链接)              var1 = var2      第一个变量是否等于第二个变量              var1 -eq var2      第一个变量是否等于第二个变量              var1 -ge var2      第一个变量是否大于等于第二个变量              var1 -gt var2      第一个变量是否大于第二个变量              var1 -le var2      第一个变量是否小于等于第二个变量              var1 -lt var2      第一个变量是否小于第二个变量              var1 != var2      第一个变量是否不等于第二个变量              var1 -ne var2      第一个变量是否不等于第二个变量      此外还可以把测试运算符与 &amp;&amp; 和 || 组合成类似于 C 语言中的三元运算符C：a&gt;b ? a : bShell：[$a -gt $b] &amp;&amp; $a || $b也可单独使用。例如[$a -eq $b] &amp;&amp; $a 为若 a 等于 b，则返回 a 的值[-d \"$dirName\"] || mkdir \"$dirName\" 为若 $dirName 路径不存在，则执行命令 mkdir \"$dirName\"  case 命令与 C 语言中的 switch 语句类似，用于选择。一般形式为case \"VAR\" in    Result1)        body        ;;    Result2 | Result3)        body        ;;    *)        body        ;;easc  for…do 循环for 循环一般用于遍历一个列表for VAR in LISTdo    bodydone# 或者这样for VAR in LIST ; do    bodydone 例如：for num in 0 1 2 3 4do    echo \"The number is $num\"done# 或者将命令输出作为列表for file in '/bin/ls' ; do    echo $filedone  while…do 和 until…do 循环结构如下# while...dowhile conditiondo    bodydone# until...dountil conditiondo    bodydone7.1.5 使用一些有用的文本操作程序最常用的程序包括 grep、cut、tr、awk、sed。大部分程序都设计为使用标准输入和输出  一般正则表达式分析器也就是 grep ，是一种查找文件或文本模式的方法。可以当成一个有用的搜索工具格式 grep 要查找的内容 输入通过查看 man grep 以了解更多  删除文本的行段cut 命令可以从文本或文件中提取字段。例如grep /home /etc/passwd | cut -d':' -f6 -首先 grep 命令从 /etc/passwd 文件获取包含 /home 的行，然后传入 cut 命令，cut 命令将这些行以 : 分割，然后取第六段 (-f6)  转换或者删除字符tr 命令是一个基于字符的转换器，可用于替换一个或一组字符，或者从文本行中删除一个字符# 转换大写为小写FOO = \"AbcDEF\"echo $FOO | tr [A-Z] [a-z]# 将该列表中文件名中空格转换为下划线for file in *; do    f='echo $file | tr [:blank:] [_]'    [\"$file\" = \"$f\"] || mv -i -- \"file\" \"$f\"done  流编辑器sed 命令是一个简单的脚本编辑器，只能执行一些简单的编辑，比如删除文本匹配特定模式的行，使用一种模式的字符替换另一种模式的字符等过于复杂，请通过在线文档了解7.1.6 使用简单的 shell 脚本电话列表的例子#!/bin/bash# (@)/ph# A very simple telephone list# Type \"ph new name number\" to add to the list, or# just type \"ph name\" to get a phone numberPHONELIST=~/.phonelist.txt# If no command line parameters ($#), there# is a problem, so ask what they're talking about.if [$# -lt 1]; then    echo \"Whose phone number did you want? \"    exit 1fi# Did you want to add a new phone number?if [$1 = \"new\"]; then    shift    echo $*&gt;&gt; $PHONELIST    echo $* added to database    exit 0fi# Nope. But does the file have anything in it yet?# This might be out first time using it, after all.if [! -s $PHONELIST]; then    echo \"No names in the phone list yet!\"    exit 1else    grep -i -q \"$*\" $PHONELIST    # Quietly search the file    if [$? -ne 0]; then    # Did we find anything?        echo \"Sorry, that name was not found in the phone ist\"        exit 1    else        grep -i \"$*\" $PHONELIST    fifiexit 07.2 小结通过编写 shell 脚本，可以自动完成许多最常见的系统管理任务#"
  },
  
  {
    "title": "欧姆社漫画数字电路读后",
    "url": "/archives/80",
    "categories": "日常",
    "tags": "读书笔记",
    "date": "2022-12-04 16:54:29 +0800",
    





    
    "snippet": "引言最近？看了《漫画数字电路》一书，大概记录一下书上的很多东西并没有记录在此处前述数字电路分 组合电路 与 时序电路组合电路：现在输入信息的组合决定输出的电路时序电路：带有 “记忆” 的电路MIL 符号逻辑电路的 与门 与 或门 符号引申为多个输入一个输出  符号含义与门 (ALL) ：多个输入全 1，输出为 1或门 (EXIST) ：有一个输入为 1，输入为1  电路线有 圆圈 的为 低电...",
    "content": "引言最近？看了《漫画数字电路》一书，大概记录一下书上的很多东西并没有记录在此处前述数字电路分 组合电路 与 时序电路组合电路：现在输入信息的组合决定输出的电路时序电路：带有 “记忆” 的电路MIL 符号逻辑电路的 与门 与 或门 符号引申为多个输入一个输出  符号含义与门 (ALL) ：多个输入全 1，输出为 1或门 (EXIST) ：有一个输入为 1，输入为1  电路线有 圆圈 的为 低电平 (0、L)无 圆圈 的为 高电平 (1、H)组合电路的制作多数表决电路多个人投票从两个结果中选出一个      列出真值表，即所有可能出现的情况        在真值表 H 输出的地方添加下划线        “输入的线” 与 “将输入 NOT 的线” 搭建框架  两列向下的电路线，第二列为 NOT 线，即从第一列连 非门 到第二列      连接到 AND (与门)                  输入为 L 时，从将输入 NOT 的地方开始 (第二列)                    输入为 H 时，从最开始的地方划线 (第一列)                    然后，接入 AND            重复此过程将 第二步 所划线的全部做完  将 AND 的所有输出连接到 OR电路的化简数字电路设计流程：整理问题 - 真值表 - 化简 - 绘制电路通过 卡诺图 进行化简  真值表转化为卡诺图真值表制作时列从最高开始，例如 [C、B、A]，结果为 Z卡诺图为二维的真值表，一般用 0 与 1 表示电平如果三个输入，可以行为 B、A，列为 C，然后将结果填入二维表  化简前了解卡诺图的 左右 与 上下 都是连起来的，因为卡诺图的横方向与竖方向都是按 比特 (1 位) 变化的      化简                  将在一起的 1 作为一个集合划分在一起                    寻找行与列的共同点                    若共同点为某值为 0 则使用 逆运算 ，即字母上一横杠                  例如              C\\BA      00      01      11      10                  0             1      1                     1                                  上表中 共同点为 C 为 0，A 为 1，则表达式为 !C * A  化简的规则      集合体的形状只能是长、宽为 1、2、4 的矩形 (或正方形)        集合体可以相互重叠        集合体的个数越少，面积越大越好  注：左右和上下可以构成一个集合体；如果无法进一步 “形成集合体” 则说明电路已经无法再化简化简后画出电路图，只需要把所有的表达式按上一步的画图步骤 (第三步开始) 走即可电路的忽略在刚开始确定输入时，因为二进制数的特性，可能会有不需要考虑的输入例如输入为月份，需要使用四位二进制数，一共有 16 个输入，其中 0、13、14、15 均为不需要考虑的输入这样的输入在卡诺图里可以使用 - 代替，可以化简计入集合体时序电路的制作时序电路需要 组合电路 与 触发器关于 时序电路 的 “记忆”，例如自动贩卖机在投币时会记录当前投币总数，若无记忆则仅有最后一个硬币的面值引入一个触发器，例如 时钟 (CLK)，仅在 CLK 触发时，输入才会对输出有影响，否则输出保持不变以绘制电子骰子为例  绘制状态迁移图随着时间的变化，电子骰子如何变化？若停止为低电平，从 1 开始到 6 到 1如果为高电平，则在某点一直停止  用二进制数来表示状态把每种情况或者说状态使用二进制表示，然后绘制出 状态迁移表通过状态迁移表画出电路，可以使用 D 触发器存储状态  设计组合电路从 现在的状态 决定 下一个状态 事实上就是 组合电路"
  },
  
  {
    "title": "Linux 学习 第六章 管理运行中的进程",
    "url": "/archives/79",
    "categories": "Linux",
    "tags": "读书笔记",
    "date": "2022-12-03 15:07:03 +0800",
    





    
    "snippet": "第六章 管理运行中的进程Linux 是一种多用户的操作系统，也是一种多任务系统。多任务意味着可以同时运行多个程序，运行程序的实例通常被称为进程可通过 shell 启动、暂停、停止或杀死进程，还可将进程放到后台以及带到前台6.1 理解进程进程是命令的运行实例。系统中的进程通过一个进程 ID (PID) 进行识别，PID 相对于当前系统是唯一的。除了 PID 号之外，进程还与一个特定的用户账户和...",
    "content": "第六章 管理运行中的进程Linux 是一种多用户的操作系统，也是一种多任务系统。多任务意味着可以同时运行多个程序，运行程序的实例通常被称为进程可通过 shell 启动、暂停、停止或杀死进程，还可将进程放到后台以及带到前台6.1 理解进程进程是命令的运行实例。系统中的进程通过一个进程 ID (PID) 进行识别，PID 相对于当前系统是唯一的。除了 PID 号之外，进程还与一个特定的用户账户和组账号相关联，有助于确定该进程可以访问哪些系统资源  用来显示进程相关信息的命令主要从 /proc 文件系统中存储的原始数据获取信息。每个进程都在 /proc 的一个子目录 (以该进程的 PID 命名) 中存储了自己的信息6.2 列出进程使用 ps 命令或者 top 命令，其中 top 命令提供了一种 更面向屏幕的方式列出进程6.2.1 使用 ps 命令列出进程使用 ps u 可显示用户名以及其他信息VSZ：虚拟内存大小 (Virtual Set Size) 显示了镜像进程的大小 (单位：KB)RSS：(Resident Set Size) 显示了内存中程序的大小VSZ 是分配给进程的内存数量，RSS 是进程实际使用的内存数量 (表明了不能被交换的物理内存)STAT 列：S 表示一个当前运行的进程，R 表示一个睡眠进程，+ 表示进程与前台操作相关联查看当前用户所有进程：ps ux | less查看所有用户进程：ps aux | less也可以自定义输出列，并且根据某一列排序，例如ps -eo pid,user,uid,group,gid,vsz,rss,comm --sort=-vsz | less-e 为显示每一个运行中的进程，-o 后为显示的列，其中 comm 为命令，然后 --sort=-vsz 以 vsz 列从大到小排序6.2.2 使用 top 命令列出和更改进程使用 top 命令，默认按进程当前所使用的 CPU 百分比排序来显示进程top 命令可以完成的操作：            命令      miaos                  h      帮助              M      按内存使用情况排序              1      切换显示所有 CPU 使用情况 (系统有多个 CPU)              R      反向排序              u      然后输入用户名可以显示某用户的进程              r      改变进程优先级 (nice 值)              k      杀死进程 (kill 命令)      6.2.3 使用 System Monitor 列出进程GNOME 桌面的 GUI 工具6.3 管理后台和前台进程对于没有 GUI 的系统，只能使用 shell 完成所有操作。虽然 Bash shell 没有包含一个 GUI 来管理多个程序，但可以在后台和前台直接移动活动程序，这样就可以运行很多程序并选择目前想要处理的程序6.3.1 启动后台进程将命令放入后台：      在命令后添加一个 &amp;        使用 at 命令运行其他命令        对于运行中的进程使用 Ctrl+Z 停止，再输入 fg 带回前台或 bg 开始在后台运行    为避免后台输出干扰前台操作，可将其定向到空设备 2&gt;/dev/null可通过 jobs 命令查看后台运行的命令 (使用 -l 可查看 PID) 。在命令序号前 + 表示最近放到后台的作业，- 表示在最近放的后台作业之前放到后台的作业6.3.2 使用前台和后台命令如果想引用一个后台作业，通过 % 和作业编号 (jobs 命令的输出) ，此外还有如下方式      % — 引用最近放入后台的 (即编号后带有 + 的)        %string — 以 string 开头的作业 (必须明确，即匹配结果唯一)        %?string — 命令行任意位置包含 string (同样必须明确，即匹配结果唯一)        %-- — 引用在最近放的后台作业之前放到后台的作业 (即编号后带有 - 的)  使用 fg %1 以将编号为 1 的任务带到前台，使用 bg %5 以将停止的编号为 5 的命令在后台继续运行  对于 vi 命令放到后台前会自动停止，记得先保存文件再放入后台以防忘记6.4 杀死和改变进程可以向进程发送不同的信号来更改其行为，也可以更改进程的处理器优先级6.4.1 使用 kill 和 killall 命令杀死进程虽然这俩命令常用于终止一个运行中的进程，但实际上是向进程发送一些有效信号。信号通过数字或名称来表示            信号      数字      描述                  SIGHUP      1      重新读取配置文件              SIGIN      2      通过键盘中断              SIGQUIT      3      通过键盘退出              SIGABRT      6      调用 abort(3) 生成的中止信号              SIGKILL      9      杀死信号              SIGTERM      15      终止信号              SIGCONT      19，18，25      继续被停止的进程              SIGSTOP      17，19，23      停止进程      对于最后两个信号，第一个值适用于 Alpha 和 SPARC，中间的值适用于 x86，最后一个值适用于 MIPS 体系结构默认为 SIGTERM (15) 信号。虽然不同进程可以对不同信号予以响应，然而任何进程都不能阻止 SIGKILL (9) 和 SIGSTOP 信号  使用 kill 命令并根据 PID 向进程发送信息kill [信号] [PID]例如杀死进程 ID 为 2333 的进程：kill -9 2333 或者 kill -SIGKILL 2333  使用 killall 命令并根据名称向进程发送信号与 kill 命令类似，当要杀死许多同名命令很有用，但要防止改变有用的同名进程例如重启 gnome-shell：killall -1 gnome-shell6.4.2 使用 nice 和 renice 命令设置处理器优先级当 Linux 内核尝试决定哪些运行中的进程可以访问 CPU 时，其中一个需要考虑的因素就是进程上的 nice 值，范围 -20~19，默认为 0nice 值越低，优先级越高，只有 root 用户可以设置负值并将优先级调高 (值调低)，普通用户只能调低 (值调高)可以使用 nice 命令运行一个带有特定 nice 值的命令，也可以使用 renice 命令和 PID 更改已运行进程的 nice 值，例如nice -n +5 updatedb &amp; 在后台以 5 的优先级运行 updatedb 命令renice -n 3 2333 将 PID 为 2333 的进程的 nice 值改为 36.5 使用 cgroups 限制进程为一个进程所设置的 nice 值不能应用于子进程，也就是说，nice 无法对特定用户或应用程序可以使用的 Linux 系统资源总量进行限制可以使用 cgroups 命令将一个进程确定为一个任务 (task)，并从属于一个特定的控制组。可以在一个层次结构中设置任务，其中包含一个被称为守护进程 (daemon) 的任务 (为所有后台服务器进程设置了默认限制) 以及子任务，子任务设置像 httpd 或 vsftpd 上的特定限制当一个任务启动一个进程时，其子进程将继承父进程限制设置，限制内容包括存储、处理器调度、进程报告、CPU 分配、设备访问、内存使用情况等设置 cgroups 可能非常棘手，包括编辑配置文件创建 cgroups (/etc/cgconfig.conf) 或限制特定用户或组 (/etc/cgrules.conf) 。可以使用 cgreate 命令创建 cgroups，从而将这些组添加到 /sys/fs/cgroup 层次结构中。如果设置不正确，系统可能无法启动"
  },
  
  {
    "title": "Linux 学习 第五章 使用文本文件",
    "url": "/archives/78",
    "categories": "Linux",
    "tags": "读书笔记",
    "date": "2022-11-19 21:07:03 +0800",
    





    
    "snippet": "第五章 使用文本文件Linux 的大多数配置通过编辑纯文本文件完成。无论是修改 /etc 目录的文件配置本地服务，还是编辑 Ansible 目录文件配置主机的集合，纯文本文件仍然在这些任务中普遍使用5.1 使用 vim 和 vi 编辑文件vim 是 vi 的改良版本，两者使用差不多，但 vim 会有引导和代码高亮等，建议使用 vim事实上，在部分 Linux 发行版中，vi 是使用别名 vi...",
    "content": "第五章 使用文本文件Linux 的大多数配置通过编辑纯文本文件完成。无论是修改 /etc 目录的文件配置本地服务，还是编辑 Ansible 目录文件配置主机的集合，纯文本文件仍然在这些任务中普遍使用5.1 使用 vim 和 vi 编辑文件vim 是 vi 的改良版本，两者使用差不多，但 vim 会有引导和代码高亮等，建议使用 vim事实上，在部分 Linux 发行版中，vi 是使用别名 vim 来运行的，即输入 alias vi 输出为 alias vi = 'vim' ，但 root 用户一般不设置别名不过在 Linux 还有其他文本编辑器，例如 nano、gedit、jed、joe、kate、kedit、mcedit、nedit 等，其中纯文本的有 jed 和 joe5.1.1 开始使用 vivi 有三个模式，主要两种为 命令模式 和 输入模式 ，还有 ex 模式。默认进入文件为命令模式 (使用 vi file 命令进入后)命令模式意味着在更改文本前需要先输入一条命令 (一俩个字母，有时还需要可选的数字参数) ，告诉 vi 您想做什么注意：命令的大小写敏感  添加文本如果要进入 输入模式 ，可以输入一个 输入 命令字母            命令      描述                  a      添加命令。在光标右侧输入文本              A      在命令结束处添加。从当前行末尾开始输入文本              i      插入命令。在光标左侧输入文本              I      在命令开始前插入。从当前行开头开始输入文本              o      在命令之下打开。在当前行之下打开一个新行，并进入插入模式              O      在命令之上打开。在当前行之上插入一个新行，并进入插入模式      进入插入模式后，在屏幕底部会出现 --INSERT--完成文本输入后，按 Esc 键返回命令模式 (有时需要按两次 (反正按 Esc 就对了)  在文本中移动仅移动一个字符使用以下按键            按键      描述                  箭头键      上下左右              h, j, k, l      左，下，上，右              Backspace, Space      左，右      移动多个字符的命令            命令      描述                  w      将光标移动到下一个单词的开头 (用空格、制表符或标点符号分隔)              W      将光标移动到下一个单词的开头 (用空格或制表符分隔)              b      将光标移动到前一个单词的开头 (用空格、制表符或标点符号分隔)              B      将光标移动到前一个单词的开头 (用空格或制表符分隔)              0 (零)      将光标移到当前行的开头              $      将光标移到当前行的末尾              H      将光标移到屏幕左上角 (屏幕上第一行)              M      将光标移到屏幕中间行的第一个字符              L      将光标移到屏幕的左下角 (屏幕上的最后一行)        删除、复制和更改文本这些命令可以配合移动键 (箭头、PgUp、PgDn、字母和特殊键) 和数字来确切指出删除、复制或更改什么            命令      描述                  x      删除光标下的字符              X      直接删除光标之前的字符              d&lt;?&gt;      删除一些文本              c&lt;?&gt;      更改一些文本              y&lt;?&gt;      复制一些文本      上表每个命令后的 &lt;?&gt; 代表了可使用移到命令的位置，例如      dw — 删除当前光标之后的一个单词        db — 删除当前光标之前的一个单词        dd — 删除整个当前行        c$ — 更改当前字符开始到当前行末尾的字符并进入输入模式 (事实上就是删除后输入)        c0 — 更改从前一字符开始到当前行开头的字符并进入输入模式 (事实上就是删除后输入)        cl — 删除当前字符并进入输入模式        cc — 删除当前行并进入输入模式        yy — 将当前行复制到缓冲区        y) — 将光标右边的句子复制到缓冲区        y} — 将光标右边的段落复制到缓冲区  也可以使用数字对上述命令进行修改，例如      3dd — 从当前行开始，删除 3 行        3dw — 删除接下来的 3 个 单词        5cl — 更改接下来 5 个字符 (也就是删除后进入输入模式)        12j — 向下移动 12 行        5cw — 删除接下来 5 个单词并进入输入模式        4y) — 复制接下来的 4 个句子    粘贴 (放置) 文本将最新存储到缓冲区的文本放到文件中            命令      描述                  P      放到光标左边，若为一行，放到上一行              p      放到光标右边，若为一行，放到下一行        重复命令在删除、更改或粘贴文本后，通过 . 以重复行为。例如替换文本 Joe 为 Jim (cw) 后查找下一处按 . 以重复更改  推出 vi在命令模式下直接使用 ZZ 保存后退出，也可按 : 进入 ex 模式            命令      描述                  :w      保存当前文件，不退出              :wq      保存并退出，与 ZZ 相同              :q      退出，但仅未更改生效              :q!      强制退出，不保存更改        其他命令      u — 撤销更改        Ctrl+R — 恢复撤销 (重做) ，也就是撤销了先前的撤销操作        :!command – 在 :! 后跟一个 shell 命令，可直接运行，例如 :!date 查看当前日期。设置可以通过 :!bash 以启动一个新 shell，但建议进入前先保存，以防忘记返回 vi        Ctrl+g — 显示正在编辑的文件名，底部还有当前所在行、文件总行数、内容百分比以及光标所在列号  5.1.2 在文件中跳过如果文件较长，用此方法移动更好            命令      描述                  Ctrl+f      向前翻页，一次一页              Ctrl+b      向后翻页，一次一页              Ctrl+d      向前翻半页              Ctrl+u      向后翻半页              G      转到文件最后一行              nG      转到文件第 n 行 (用数字替换 n)      5.1.3 搜索文本通过 / 与 ? 向前或向后搜索文本，还可以使用元字符，例如      /hello* — 向前搜索 hello 开头的行        ?[pP]rint — 向后搜索单词 print 或 Print  在输入搜索后通过 n 或 N 可以在相同或相反方向载体搜索5.1.4 使用 ex 模式vi 编辑器最初基于 ex 编辑器，因此无法在全屏模式下工作，但可以在 ex 模式下使用命令找到并更改一行或多行的文本，例如在命令模式下使用 : 进入 ex 模式      :g/Local — 搜索单词 Local，并打印相关行，如果输出结果满屏将发送到 more 命令        :s/Local/Remote — 将当前行首次出现的单词 Local 替换为 Remote        :g/Local/s//Remote — 文件每一行首次 Local 替换为 Remote        :g/Local/s//Remote/g — 文件所有 Local 替换为 Remote        :g/Local/s//Remote/gp — 文件所有 Local 替换为 Remote，并打印每一行  5.1.5 了解更多使用 vimtutor 将在 vim 编辑器中打开一个教程5.2 查找文件为帮助找到系统中的文件，可使用一些命令      locate — 根据名称查找文件        find — 根据不同的属性查找文件        grep — 在文本文件内部搜索包含所搜索文本的行  5.2.1 使用 locate 命令根据名称查找文件大多数 Linux 系统每天会运行一次 updatedb 命令，收集 Linux 系统中文件名并存入数据库，使用 locate 命令可从该数据库中搜索文件位置。可通过 sudo updatedb 命令更新数据库。仅可通过 locate 命令查看允许用户访问的文件locate [str] ，或者使用 locate -i [str] 以忽略大小写。例如搜索包含 yexca 的目录并忽视 yexca 的大小写：locate -i yexca注：并不是所有的文件都在数据库，/etc/updated.conf 文件内容限制了被收集的文件5.2.2 使用 find 命令搜索文件find 命令是在文件系统中搜索文件的最佳命令，可以基于不同属性 (元数据) 查找，并且可以在找到文件后进行处理注：文件元数据包括所有者、组、时间戳、文件大小、权限以及存储在文件 inode 中的其他信息  find 与 locate 的区别  使用 find 查找将搜索文件系统，所以速度会比 locate 慢许多，不过可以实时查看系统中文件 (对于 locate 命令，如果文件过新未收录到数据库将无法被找到)。当然，使用 find 时要设置搜索起始点以限制搜索范围从而提高速度find 命运有一个特殊的选项 -ls ，可以列出搜索到文件的详细信息，类似 ls -l 命令的输出注：对于普通用户搜索文件因权限问题会有许多错误，可将错误输出定向到 /dev/null 以忽略，即在命令末尾添加 2&gt;/dev/null  根据文件名查找文件使用 -name 和 -iname (忽略大小写) 以输入想要搜索的文件名，也可使用文件匹配字符 (* 和 ?)，例如find /etc -iname '*passwd*'在 /etc 目录下搜索包含 passwd 单词并忽略大小写的文件 (如不指定目录 (/etc) 将搜索当前文件夹)可使用 -type 选项以指定输出仅文件 (-type f) 或仅目录 (-type d)  根据文件大小查找文件通过 -size 选项和以 + 或 - 开头的数字查找相应范围，例如 find /etc -size +10M 查找 /etc 目录下大于 10MB 的文件find /bigdata -size +500M -size -5G -exec du -sh {} \\查找 /bigdata 目录下 500MB ~ 5GB 之间的文化，并针对每个文件运行 du 命令以查看文件大小  根据用户查找文件通过 -user 或 -group 以针对特定用户或组查找，还可使用 -not 和 -orfind /home \\( -user yexca -or -user lemon \\) -ls查找 /home 目录下 yexca 和 lemon 所拥有的文件  根据权限查找文件使用 -perm 选项，根据数字或字母找到文件。如果数字前使用 - ，则三位都要匹配；如果使用 + ，任一数字匹配即可；若不加东西，那么所有数字必须完整、精确匹配 (因用户不同)如果 find -perm /002 则将找到对 “其他人” 启用了写入权限的文件，而不用管其他权限位如何设置  根据日期和时间查找文件time 选项 (-atime、-ctime 和 -mtime) 能基于自文件被访问、更改或者文件的元数据被更改以来所经历的天数进行搜索。而 min 选项 (-amin、-cmin 和 -mmin) 则是基于所经历的分钟数进行修改在上述俩选项的参数前加 - 表示从当前时间到所查询的时间单位前的时间，+ 表示所查询时间单位之前以及更久的时间，如果省略，则完全匹配  查看 10 分钟内被更改的内容find /etc -mmin -10  查看三天内权限更改find /bin /usr/bin -ctime -3  查看 300 多天未被访问的文件find /var/www -atime +300  在查找文件时使用 ‘not’ 和 ‘or’通过使用 -not 或 -or 选项可以更好地搜索  查找被 yexca 所有但不属于 yexca 组的文件find /home -user yexca -not -group yexca -ls  被 yexca 所有并且大于 1GB 的文件find /home -user yexca -and -size +1G -ls  查找文件和执行命令通过使用 -exec 选项，可以在每一个找到的文件执行命令而不必确认，或使用 -ok 以确认是否执行该命令。两者语法相同find [options] -exec command {} \\;find [options] -ok command {} \\;其中 {} 表示被找到的文件名，可多次使用。在命令末尾需要使用 \\; 。例如find /etc -iname passwd -exec echo \"I found {}\" \\;查找名为 passwd 的文件并在 echo 的输出中包含该名称注：若了解更多，使用 man find 命令5.2.3 使用 grep 命令在文件中搜索使用 grep 命令可以搜索包含某一文本 (搜索内容) 的文件。当搜索时，可以把包含文本的所有行打印，或只打印相关文件。grep 还可以搜索标准输出            选项      描述                  -i      忽略大小写              -v      搜索不包含指定文本的行              -r      递归搜索某目录的文件              -l      仅显示文件              –color      突出显示搜索文本 (默认为红色)        在 /etc/sysconfig 目录递归搜索文本 rootgrep -ri --color root /etc/sysconfig/  从标准输出中搜索包含 inet 的行ip addr show | grep inet"
  },
  
  {
    "title": "NovelAI 绘图 (WebUI)",
    "url": "/archives/77",
    "categories": "日常",
    "tags": "AI, Python",
    "date": "2022-10-30 16:23:07 +0800",
    





    
    "snippet": "使用 Windows11 部署，其他系统 (如 Linux ) 请参考：AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI空间占用程序：5.3GiB (不含模型)运行：5.5GiB 以上请确保 C 盘空间至少 6GiB 再运行，否则电脑可能黑屏卡死环境首先是网络环境，请确保连接上互联网      Git    官网：ht...",
    "content": "使用 Windows11 部署，其他系统 (如 Linux ) 请参考：AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI空间占用程序：5.3GiB (不含模型)运行：5.5GiB 以上请确保 C 盘空间至少 6GiB 再运行，否则电脑可能黑屏卡死环境首先是网络环境，请确保连接上互联网      Git    官网：https://git-scm.com/        Python 3.10.6 以上 (最新版本可能不稳定)    建议 3.10.8：https://www.python.org/downloads/release/python-3108/    勾选 Add python.exe to PATH        模型下载                  官方模型 (偏写实)                              通过磁力下载（请使用正规种子客户端）            magnet:?xt=urn:btih:3a4a612d75ed088ea542acac52f9f45987488d1c&amp;dn=sd-v1-4.ckpt&amp;tr=udp%3a%2f%2ftracker.openbittorrent.com%3a6969%2fannounce&amp;tr=udp%3a%2f%2ftracker.opentrackr.org%3a1337                                            其他下载方式            访问 AUTOMATIC1111/stable-diffusion-webui Wiki                                      Waifu 模型(二次元啦)        访问 hakurei/waifu-diffusion-v1-3 at main 选择下载                    其他        Stable Diffusion Models (cyberes.github.io)            克隆仓库选择一个合适的位置，右击选择 在终端中打开 ，然后输入以下命令git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git更新时可以进入该目录 (stable-diffusion-webui) 后使用 git pull 命令配置      将下载的模型放入 /models/Stable-diffusion 目录        配置 /webui-user.bat 文件在set VENV_DIR= 后任意输入字符串，然后保存退出        运行 /webui-user.bat 文件          下载文件过大 (6GiB 左右) ，可能会运行较长时间，期间无进度条提示（若感觉程序终止之类的，可通过网络带宽使用情况以判断是否正在下载）            如果您的显示卡是 GTX1660 或者算出来的图是黑色的    编辑 webui.bat ，在开头加入以下文本    set COMMANDLINE_ARGS=--precision full --no-half      其他详细了解：hua1995116/awesome-ai-painting: AI绘画资料合集（包含国内外可使用平台、使用教程、参数教程、部署教程、业界新闻等等） stable diffusion tutorial、disco diffusion tutorial、 AI Platform训练模型：NovelAI hypernetwork 自训练教程 - 知乎            [NovelAI软件获取 - novelai 资源站 咩小咩壁纸      NovelAI资源站](https://novelai.club/archives/js)      关键词例子NSFW, Prhololive, uruha_rushia, 1girl, bangs, bare shoulders, red eyes, blue dress, blue green hair, blue sleeves, blush, bow, breasts, chick, collarbone, detachedcollar, detached sleeves, double bun, eyebrows visible through hair, frills, hair orhament, medium hair, off-shoulder dress参考文章最火的AI绘画教程！免费开源，包教会 - 零度解说【心得】(NSFW) AI 色圖製作體驗 + 關鍵字 @場外休憩區 哈啦板 - 巴哈姆特"
  },
  
  {
    "title": "虚拟机中 Arch Linux 安装记录",
    "url": "/archives/76",
    "categories": "Linux",
    "tags": "",
    "date": "2022-10-02 13:39:26 +0800",
    





    
    "snippet": "引言使用虚拟机安装，软件为 Fedora 的 盒子安装前准备下载镜像从官方下载页面下载，推荐使用 BT 下载 (请使用正规 torrent 客户端，例如 qBittorrent)然后放到虚拟机里验证引导模式列出 efivars 目录ls /sys/firmware/efi/efivars如果正确显示目录并且没有报告错误，则系统以 UEFI 模式引导，如果目录不存在，则可能以 BIOS 模式引...",
    "content": "引言使用虚拟机安装，软件为 Fedora 的 盒子安装前准备下载镜像从官方下载页面下载，推荐使用 BT 下载 (请使用正规 torrent 客户端，例如 qBittorrent)然后放到虚拟机里验证引导模式列出 efivars 目录ls /sys/firmware/efi/efivars如果正确显示目录并且没有报告错误，则系统以 UEFI 模式引导，如果目录不存在，则可能以 BIOS 模式引导 (或 CSM 模式)这个虚拟机中使用 BIOS 模式连接到互联网默认开启网络接口与 DHCP 服务，无需配置更新系统时间开启与网络时间服务器 (NTP) 同步timedatectl set-ntp true可使用 timedatectl status 检查服务状态建立硬盘分区使用了传统的 fdisk 命令分区 (MBR 分区)，因为引导是 BIOS，采用官方的分区示例，仅做了两个分区 (swap 交换分区与其他)使用 fdisk -l 列出全部磁盘 (以 rom、loop 或 airoot 结尾的设备可以忽略)使用 fdisk /dev/设备名 开始分区            命令      描述                  n      新建分区              p      检查分区              t      改变分区类型              w      保存更改      指定分区大小使用 ++num+K/M/G/T/P ，若无后缀 (K/M/G/T/P) 则分配扇区格式化分区  创建交换分区mkswap /dev/交换空间分区  创建文件系统根据文件系统不同命令不同，例如 ext4 文件系统mkfs -t ext4 /dev/分区挂载分区将根分区挂载带 /mnt，若有多个分区，请务必先挂载根分区mount /dev/分区 /mnt启用交换空间swapon /dev/交换空间分区安装选择镜像文件 /etc/pacman.d/mirrorlist 定义了软件包从何处下载，在连接到互联网上后会自动更新，也可手动更改，我就不改了安装软件包使用 pacstrap 脚本，安装 base 软件包和 Linux 内核以及 vim，如果安装其他软件包，在下面命令后加上名字即可，当然也可以之后使用 pacman 安装pacstrap /mnt base linux vim配置系统Fstab/etc/fstab 文件描述系统启动时如何自动挂载分区，可以使用以下命令自动生成 (使用 -U 或 -L 选项设置 UUID 或卷标，使用 UUID 以确保系统引导不会出错)genfstab -U /mnt &gt;&gt; /mnt/etc/fstab检查自动配置是否正确cat /mnt/etc/fstabChrootChroot 至新安装的系统arch-chroot /mnt时区以上海时间为例ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime生成 /etc/adjtimehwclock --systohc此时可使用命令 date 查看时间是否正确本地化编辑 /etc/locale.gen ，取消 en_GB.UTF-8 的注释然后生成 locale 信息locale-gen创建 /etc/locale.conf 文件，编辑 LANG 变量，例如 LANG=en_GB.UTF-8网络配置创建 /etc/hostname 文件输入主机名因为虚拟机使用 DHCP，就不配置网络了Root 密码passwd安装引导程序一般安装 GRUB，我用的虚拟机为 BIOS+MBR，安装 grub 软件包pacman -S grub安装 grub (下属命令 /dev/设备，注意不是分区)grub-install --target=i386-pc /dev/设备生成配置文件grub-mkconfig -o /boot/grub/grub.cfg重启使用 exit 或 Ctrl+D 退出 chroot 环境使用 umount -R /mnt 卸载被挂载的分区重启 reboot参考资料Installation guide (简体中文) - ArchWiki"
  },
  
  {
    "title": "Linux 学习 第四章 在文件系统中移动",
    "url": "/archives/75",
    "categories": "Linux",
    "tags": "读书笔记",
    "date": "2022-09-25 20:35:02 +0800",
    





    
    "snippet": "第四章 在文件系统中移动Linux 文件系统存储了计算机上所有的信息            目录      描述                  /bin      包含常见的 Linux 用户命令，比如 ls、sort、date 和 chmod              /boot      包含可启动的 Linux 内核、最初的 RAM 盘和启动加载程序的配置文件 (GRUB)    ...",
    "content": "第四章 在文件系统中移动Linux 文件系统存储了计算机上所有的信息            目录      描述                  /bin      包含常见的 Linux 用户命令，比如 ls、sort、date 和 chmod              /boot      包含可启动的 Linux 内核、最初的 RAM 盘和启动加载程序的配置文件 (GRUB)              /dev      包含用来表示系统中设备访问点的文件。这些设备包括终端设备 (tty) 、硬盘驱动器 (hd 或 sd) 、RAM (ram) 以及 CD-ROM (cd*) 。用户可以直接通过这些设备文件访问相应的设备；然而，应用程序通常会对最终用户隐藏实际的设备名称              /etc      包含管理配置文件。其中大多数文件都是纯文本文件，只要用户拥有适当的权限，就可以使用任何文本编辑器编辑这些配置文件              /home      包含分配给每个带有登录账号的普通用户的目录 (root 用户是一个例外，使用 /root 作为主目录)              /media      为自动挂载设备 (特别是可移动介质) 提供了一个标准位置。如果介质有一个卷名，那么一般来说使用该卷名作为挂载点              /lib      包含 /bin 和 /sbin 目录中的应用程序启动系统所需的共享库              /mnt      在该目录被标准的 /media 目录取代之前，/mnt 目录是许多设备常见的挂载点。一些可启动的 Linux 系统仍使用该目录来挂载硬盘分区和远程文件系统。此外很多人也在使用该目录临时挂载那些不需要永久挂载的本地或远程文件系统              /misc      该目录有时用来根据请求自动挂载文件系统              /opt      用来存储附加应用程序软件的目录结构              /proc      包含关于系统资源的信息              /root      表示 root 用户的主目录。因安全原因，没有位于 /home              /sbin      包含管理命令和守护进程              /sys      包含用于调优块存储和管理 cgroups 的参数              /tmp      包含应用程序使用的临时文件              /usr      包含用户文档、游戏、图形文件 (X11) 、库 (lib) 以及其他不需要在启动过程中使用的命令和文件。/usr 目录中的文件在安装完毕就不可更改。理论上来讲，/usr 可以采用只读方式挂载              /var      包含不同应用程序所使用的数据目录。尤其可以在该目录中放置作为 FTP 服务器 (/var/ftp) 或 Web 服务器 (/var/www) 共享的文件。还包含所有的系统日至文件 (/var/log) 以及假脱机文件 (/var/spool，如 mail、cups 和 news) 。/var 目录所包含的目录和文件经常被修改。在服务器计算机上，通常会创建一个 /var 目录作为一个单独的文本系统，使用一个易于拓展的文件系统      4.1 使用基本的文件系统命令cd 、pwd 、mkdir 、rmdir 、ls 、touch4.2 使用元字符和运算符某些特殊字符被称为元字符或运算符4.2.1 使用文件匹配元字符            元字符      描述                  *      匹配任何数量的字符              ?      匹配任何一个字符              […]      匹配括号之间的任一字符，可以包括一个连字符分隔的字母或数字范围      例如 ls [a-g]* 列举以字母 a 到字母 g 开头的文件或目录4.2.2 使用文件重定向元字符            元字符      描述                  &lt;      将文件的内容定向到命令。命令的默认行为，可省略，例如使用less bigfile 等同于 less &lt; bigfile              &gt;      将命令的标准输出定向到一个文件。如果文件存在将被重写 (覆盖)              2&gt;      将标准错误 (错误消息) 定向到文件              &amp;&gt;      将标准输出和标准错误都定向到文件              »      将命令的输出定向到一个文件，并将该输出添加到现有文件的末尾      例如以下命令man chmod | col -b &gt; /tmp/chmod设置了手册页的格式 (使用 man 命令) ，删除了额外的退格键 (col -b) 以及将输出发送到文件 /tmp/chmod (如果文件存在，则删除之前的 /tmp/chmod 文件)echo \"Hello World!\" &gt;&gt; ~/hello将文本 Hello World! 添加到 ~/hello重定向的另一种类型被称为 here text (或者 here document) ，例如ed /etc/resolv.conf &lt;&lt; resenditanameserver 100.100.100.100.wqresendit通过 ed 文本编辑器向 /etc/resolv.conf 文件 (root 用户运行的脚本) 执行俩 resendit 之间的内容 (示例为添加 DNS 服务器的 IP 地址)4.2.3 使用括号拓展字符通过使用大括号 {} 可以跨文件名、目录名或者命令中的其他参数扩展一组字符，例如touch memo{1,2,3,4,5}将创建 memo1~memo5 共 5 个文件touch {John,Bill,Sally}-{Breakfast,Lunch,Dinner}将创建 9 个文件touch {a..f}{1..5}将创建 a1~f5 共 30 个文件4.3 列出文件和目录一般 ls 命令被设置别名为 ls --color=auto ，可通过下面命令查看别名alias ls使用 ls -la 命令可以查看详细信息 (-l) 和所有文件 (-a)            列      文件      目录                  1      权限      权限              2      链接到该项目的数量      链接到该项目的数量              3      文件所有者      目录所有者              4      文件所属组      目录所属组              5      文件的字节大小      包含该目录信息的文件的大小，非目录包含文件大小              6      最近一次修改的日期和时间      最近一次修改的日期和时间              7      文件名      目录名      注：      时间和日期列的格式可以更改，根据 LANG 变量        有时可执行文件权限为 s (-rwsr-sr-x) ，表示应用可被任何用户访问，但运行进程的所有权为应用程序的用户/组，而不是启动该命令的用户        如果目录权限末尾是 t (drwxrwxr-t) ，则表示为该目录设置了一个粘滞位。表明目录的所有者允许其他用户添加文件，但阻止删除其他人添加的文件        通过为某一目录分配一个 Set GID，该目录中所创建的任何文件都被分配到与目录组相同的组。如果在一个目录上看到的是一个大写 S 或 T 而不是执行位，则意味着分别设置了 Set GID 或粘滞位，而出于某些原因执行位没有开启        如果权限末尾是加号 (-rw-rw-r-+) ，则说明在文件上设置了扩展属性，如 ACL 或 SELinux。末尾的点表示在文件中设置了 SELinux  通过 cd ~yexca 可访问 yexca 的主目录，cd - 以返回之前的工作目录 ($OLDPWD 指向的目录) ，而cd . 指向当前工作目录 ($PWD)ls 命令：-t 以最新修改时间顺序显示文件；-F 在目录后添加 / ，可执行文件后添加 * ，符号链接旁显示 @；--hide=yexca 隐藏显示 yexca 这个文件或目录；-S 按文件大小列出文件；-d 显示该目录的信息而非目录所包含的文件和目录4.4 了解文件权限和所有权对于 ls -l 命令第一列第一位为文件类型            字母      类型                  -      文件              d      目录              l      符号链接              b      块设备              c      字符设备              s      套接字              p      命名的管道      后九位为权限，前三位为用户 (u) 的，中三位为所在组 (g) 的，后三位为其他人 (o) 的 (连起来就是 ugo，即尤吉欧)对于文件和目录，权限位含义略有不同            权限      文件      目录                  Read      查看文件内容      查看目录所包含的文件和子目录              Write      更改文件内容，重命名或删除文件      向目录添加文件或子目录。删除目录中的文件或子目录              Execute      将文件作为一个程序运行      将目录更改为当前目录，搜索目录或执行该目录中一个程序，访问目录中文件的文件元数据 (文件大小、时间戳等)      可通过 ls -ld 命令查看任何文件或目录的权限  在 Fedora 和 Red Hat Enterprise Linux 中，当添加了一个新用户时，默认情况下该用户被分配到一个同名的组中，这种分配组的方法被称为用户专用组方案4.4.1 使用命令 chmod (数字) 更改权限r = 4；w = 2；x = 1chmod -R 755 ~/myfile更改 ~/myfile 下所有文件和目录 (-R) 和该目录的权限为 755 (rwxr-xr-x)4.4.2 使用 chmod (字母) 更改权限chmod ug+rx fileschmod -R o-x ~/myfile4.4.3 使用 umask 设置默认的文件权限普通用户创建文件默认权限为 rw-rw-r–，目录为 rwxrwxr-x。对于 root 用户分别为 rw-r–r– 和 rwxr-xr-x。这些默认值由 umask 值确定，输入该命令即可查看值，例如 0002若暂时忽略第一个 0 (前导零) ，那么 umask 值被视为对文件完全开放权限 (666) 或者对目录完全开放权限 (777) 。umask 值 002 生成对目录权限 775，文件为 644。默认情况下普通文件的执行权限被关闭      如果临时更改 umask 值，直接 umask [权限] ，将权限值替换 [权限] ，例如 umask 000 然后创建的文件和目录权限分别为 -rw-rw-rw- 和 drwxrwxrwx        如果永久更改需要向主目录 .bashrc 文件结尾处添加一条 umask 命令  4.4.4 更改文件所有权仅 root 用户可更改文件所有权chown user:group /etc/file将 /etc/file 改为 user 所有和 group 组，可使用 -R 递归更改或者之更改所属用户 chown yexca /etc/file4.5 移动、复制和删除文件mv、cp、rm、rmdirmv 命令通过添加 -i 或设置别名防止移动时重写已有文件，或使用 -b 则若有同名文件会先备份旧文件后移动新文件cp 命令使用 -a 将保持原来的日期/时间戳使用 -f 以强制应用更改 (例如 rm -rf /*)"
  },
  
  {
    "title": "Fedora 桌面折腾",
    "url": "/archives/74",
    "categories": "折腾记录",
    "tags": "Fedora",
    "date": "2022-09-18 11:10:58 +0800",
    





    
    "snippet": "引言应该是最近的最后一次折腾了，不过启用很多插件后开机后要很久才显示桌面，之后要禁用一些不常用的主题通过阅读书籍得知 GNOME 的主题网站，然后去逛了下，打开第一个主题就深深吸引了我链接主题：Fluent round gtk themeGithub：vinceliuice/Fluent-gtk-theme: Fluent design gtk theme for linux desktop...",
    "content": "引言应该是最近的最后一次折腾了，不过启用很多插件后开机后要很久才显示桌面，之后要禁用一些不常用的主题通过阅读书籍得知 GNOME 的主题网站，然后去逛了下，打开第一个主题就深深吸引了我链接主题：Fluent round gtk themeGithub：vinceliuice/Fluent-gtk-theme: Fluent design gtk theme for linux desktops安装通过 Github 的 README 得知透明版的需要插件 Blur Me，但我当时看的时候该插件不适配我的 GNOME 版本 (写文章时查看也没适配了) ，当时没装透明版本，但我忘了怎么就找到了一个支持的：Blur my Shell (这透明是真好看！！！)  通过 Git 克隆仓库git clone https://github.com/vinceliuice/Fluent-gtk-theme.git  运行脚本./install.sh可以添加选项自定义，具体效果预览还是看 README 吧-d, --dest DIR          Specify destination directory (Default: /usr/share/themes)-n, --name NAME         Specify theme name (Default: Fluent)-t, --theme VARIANT     Specify theme color variant(s) [default|purple|pink|red|orange|yellow|green|grey|all] (Default: blue)-c, --color VARIANT     Specify color variant(s) [standard|light|dark] (Default: All variants)-s, --size VARIANT      Specify size variant [standard|compact] (Default: All variants)-i, --icon VARIANT      Specify icon variant(s) for shell panel                        [default|apple|simple|gnome|ubuntu|arch|manjaro|fedora|debian|void|opensuse|popos|mxlinux|zorin]                        (Default: Windows icon)--tweaks                Specify versions for tweaks [solid|float|round|blur|noborder|square]                        solid:    no transparency version                        float:    floating panel                        round:    rounded windows                        blur:     blur version for 'Blur-Me'                        noborder: windows and menu with no border                        square:   square windows button-h, --help              Show help图标主题有一个配套的图标，这不得整上链接Github：vinceliuice/Fluent-icon-theme: Fluent icon theme for linux desktops安装和主题差不多，先克隆仓库git clone https://github.com/vinceliuice/Fluent-icon-theme.git然后运行脚本./install.sh当然也可以通过选项自定义，具体还是参考 README 吧Dock 栏使用插件：Dash to Dock for COSMIC安装主题时预览的 Dock 栏不知道怎么装，但我找到了这个插件，在设置里调整一下也有透明效果音乐播放器 Rhythmbox自带的音乐播放器用起来还行，但是没有单曲循环功能就有亿点不方便Github：fossfreedom/alternative-toolbar: Modern, minimal and music-focused interface for Rhythmbox安装安装也挺简单，以下为 Fedora 安装先到 Releases 下载压缩包，然后配置环境sudo dnf install intltool git gnome-pkg-tools gobject-introspection glib2-devel pkg-config python3-gobject python3然后解压并进入目录依次执行以下命令./configure --prefix=/usrmakesudo make install卸载到安装文件夹执行命令sudo make uninstall桌面背景想着能不能把 wallpaper engine 的视频作为桌面便去搜索了相关资料视频桌面这玩意貌似不能在双显示屏情况下自动适配屏幕以及每次循环都会闪一下，弃用安装环境  mplayer首先启用 rpmfusion 库sudo dnf install https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-32.noarch.rpm然后使用 dnf 安装sudo dnf install mplayer  xwinwrap这软件只有 ubuntu 安装包，不过实际上直接解压也可以运行这个程序源码位置：Githubdeb 下载：xwinwrap_0.3.2git20171223_amd64.deb提取文件后复制到 /usr/local/bin 然后赋予执行权限即可命令如果是单显示器xwinwrap -ni -o 1 -fdt -fs -s -st -sp -b -nf -- mplayer -framedrop -nosound -loop 0 -wid WID -quiet ~/Pictures/bg.mp4如果是双显示器，下述命令显示在右边的显示器上xwinwrap -g 1920x1080+1920+0 -fdt -ni -b -nf -- mplayer -framedrop -nosound -loop 0 -wid WID -quiet ~/Pictures/bg.mp4具体命令选项可以 xwinwrap --help 或者看参考文章第二篇的相关部分按时自动换壁纸虽然是可以换了，不过不仅要格式匹配还要命名，添加还得改文件，有点麻烦，弃用创建壁纸轮换范围比如创建 ~/.backgrounds/pic.xml ，内容如下，根据情况替换&lt;background&gt;    &lt;starttime&gt;        &lt;year&gt;2022&lt;/year&gt;        &lt;month&gt;9&lt;/month&gt;        &lt;day&gt;17&lt;/day&gt;        &lt;hour&gt;1&lt;/hour&gt;        &lt;minute&gt;00&lt;/minute&gt;        &lt;second&gt;00&lt;/second&gt;    &lt;/starttime&gt;    &lt;static&gt;        &lt;duration&gt;4000.0&lt;/duration&gt;        &lt;file&gt;~/.backgrounds/pic/00001.jpg&lt;/file&gt;    &lt;/static&gt;    &lt;transition type=\"overlay\"&gt;        &lt;duration&gt;847.0&lt;/duration&gt;        &lt;from&gt;~/.backgrounds/pic/00001.jpg&lt;/from&gt;        &lt;to&gt;~/.backgrounds/pic/00050.jpg&lt;/to&gt;    &lt;/transition&gt;    &lt;static&gt;        &lt;duration&gt;4000.0&lt;/duration&gt;        &lt;file&gt;~/.backgrounds/pic/00050.jpg&lt;/file&gt;    &lt;/static&gt;&lt;/background&gt;static 指定某一张壁纸展示的时间 (秒) 和文件位置transition 指定轮换范围以及过渡时间创建配置文件比如创建 ~/.backgrounds/pic-timed.xml&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE wallpapers SYSTEM \"gnome-wp-list.dtd\"&gt;&lt;!-- /usr/share/gnome-background-properties --&gt;&lt;wallpapers&gt;  &lt;wallpaper deleted=\"false\"&gt;    &lt;name&gt;Default Background&lt;/name&gt;    &lt;filename&gt;~/.backgrounds/pic.xml&lt;/filename&gt;    &lt;options&gt;zoom&lt;/options&gt;    &lt;shade_type&gt;solid&lt;/shade_type&gt;    &lt;pcolor&gt;#3465a4&lt;/pcolor&gt;    &lt;scolor&gt;#000000&lt;/scolor&gt;  &lt;/wallpaper&gt;&lt;/wallpapers&gt;然后将该文件复制或者链接到 /usr/share/gnome-background-properties/ 就可以在 设置 - 背景 看到了或者尝试重启 gnome ( alt+F2 后输入 r )转换图片格式安装 ImageMagick 后使用命令convert before.jpg after.png随机换壁纸很方便实用，除了每次都得手动运行 (不过或许可以创建为应用然后开机启动吧)创建脚本文件vi ran_wallpaper.sh输入以下内容，注意修改相关路径#!/bin/bashwallpaper_path=\"~/wallpaper\" # 壁纸路径sleep_time=1  # 更换间隔 单位秒find $wallpaper_path -name '*.*' | cat &gt; /tmp/list # 获取图片列表img_range_max=`cat /tmp/list | wc -l` # 获取图片数量，用来设定随机范围while truedon=$((RANDOM%$img_range_max+1))  # 获取随机数img_path=`awk NR==$n /tmp/list`  # 获取该壁纸的完整路径gsettings set org.gnome.desktop.background picture-uri file://$img_path  # 更换壁纸命令sleep $sleep_timedone运行赋予运行权限chmod +x ran_wallpaper.sh后台运行setsid ./ran_wallpaper.sh警告千万不要把这个脚本放进初始化守护进程服务！！！关闭查找进程ps -ef |grep ran_wallpaper第一列：用户名，第二列：PID，第三列：父级PID，最后一列：命令名称或路径关闭进程sudo kill -9 PID桌面图标其实我个人而言不是太需要，用 Win 时桌面也几乎干干净净的显示图标使用插件：Gtk4 Desktop Icons NG (DING)尽管这个插件不支持在多显示器上显示图标，但透明的背景真的很喜欢如果多显示器支持还是这个插件吧：Desktop Icons NG (DING)不使用插件参考：Remove desktop support (#158) · Issues · GNOME / Files · GitLab创建图标新建并写入 .desktop 文件，例如[Desktop Entry]Name=Grey Hack    # 显示的名称Comment=Play this game on Steam    # 鼠标指示的提示语 (貌似没什么用)Exec=steam steam://rungameid/605230    # 可执行程序路径 (在 Bash 下的启动方式)Icon=steam_icon_605230    # 图标的路径/定义Terminal=false    # 是否在终端运行Type=Application    # 应用类型Categories=Game;    # 分类其他插件  左上 活动 变图标Activities Icons  左上显示任务图标App Icons Taskbar  音量处显示应用音量Application Volume Mixer  剪贴板记录Clipman  左上文件系统Files Menu  左上应用列表Frippery Applications Menu  自定义 GNOME ShellJust Perfection  右上切换代理Proxy Switcher  下拉应用quake-mode  显示桌面Show Desktop Applet  切换声卡Sound Input &amp; Output Device Chooser  托盘图标 (Tray Icons) 放右上Tray Icons: Reloaded参考文章Fedora 视频桌面 - 一个曾经的小码农…Video Livestream Wallpaper For Your GNOME, Xfce Or bspwm Desktop - Linux Uprising Blog常用的GNOME Shell 扩展 - pipci - 博客园Linux 命令行处理图片（图片格式转换、缩放、旋转等）_打工人小飞的博客-CSDN博客Linux切换壁纸,Linux 随机换壁纸_毛社长的博客-CSDN博客在linux后台运行脚本命令和程序的方法大全_豆豆技术派的博客-CSDN博客「GNOME 3」- 桌面图标（显示、Ubuntu 20.10、隐藏） - K4NZ BLOGFedora:Gnome创建桌面图标，以Eclipse和IDEA为例"
  },
  
  {
    "title": "个人内网折腾",
    "url": "/archives/73",
    "categories": "折腾记录",
    "tags": "DLsite, Docker",
    "date": "2022-09-16 15:00:01 +0800",
    





    
    "snippet": "引言人嘛，有了比较好的就会追求更好的，欲望无穷无尽。本想整 NAS，奈何经济实力不够，于是通过四个项目在自己电脑整了入口、动画、漫画以及音声库，那么书接上回，继续折腾成品展示全部使用 Docker 部署，理论上应该只要 Docker 支持的平台就能复现      调整了域名为 link.start.icu，本没有 .icu，可浏览器不能解析，只能加上 (不过莫名更好了吧)        手机...",
    "content": "引言人嘛，有了比较好的就会追求更好的，欲望无穷无尽。本想整 NAS，奈何经济实力不够，于是通过四个项目在自己电脑整了入口、动画、漫画以及音声库，那么书接上回，继续折腾成品展示全部使用 Docker 部署，理论上应该只要 Docker 支持的平台就能复现      调整了域名为 link.start.icu，本没有 .icu，可浏览器不能解析，只能加上 (不过莫名更好了吧)        手机访问图片显示中间的 (有亿点不太理想)        有时间把这玩意部署到服务器上搞个导航吧 (不过标题不能直接改有点麻烦，不想整 JS)  注：使用 Docker Desktop 部署，所以就没有部署啦，可看上回的部署，过程差不多登录 Docker Hub貌似安装 Docker Hub 使用 docker pull 要先登录首先到官网注册账号：Docker Hub然后先需要初始化，执行命令gpg --generate-key输入相关信息后注意输出的 pub 下一行的一串字符串，复制并替换为下述命令的 [pub]pass init [pub]然后在 Docker Desktop 登录动画 - JellyfinDocker Hub：jellyfin/jellyfin官网：Jellyfin: The Free Software Media Systemdocker pull jellyfin/jellyfin不过封面图片方面不是太理想，个人不是 NAS，懒得弄了可参考：利用 Jellyfin + Bangumi 打造更舒适的动画媒体库 - 初之音漫画 - KomgaDocker Hub：gotson/komga官网：Komgadocker pull gotson/komga注：漫画过多扫描时可能会导致电脑很卡音声 - kikoeru-expressDocker Hub：muveex/kikoeru-expressGithub：kikoeru-project/kikoeru-express我下载的是 0.6.2 版本 (话说这玩意和某网站很像嘛)docker pull muveex/kikoeru-express:v0.6.2本来看到文章想用 PLEX 的，但必须登录使用搞得有点不想用了，但界面看起来很好看，忍了。装完后发现要加自己的媒体库居然还要安装它的闭源软件，这玩意可以访问文件系统几乎所有文件 (但访问不了我挂载的) ，卸载了，可能我搞 NAS 才会再次使用吧引导 - HeimdallDocker Hub：linuxserver/heimdall/官网：Heimdall Application Dashboarddocker pull linuxserver/heimdall另在参考文章第二篇有提到统一认证，不过我个人不是太需要就没整 (主要是看着就很复杂)后话从此次折腾来看，可能并不需要为 NAS 的系统买单，硬件买电脑配件装个主机，软件装个 Linux 系统，通过各种开源项目想必应该也可以体验不错命令行操作不来可以装一些轻量的 GUI，例如 Xface、JWM 之类的参考文章谈谈如何使用docker，搭建一台“群晖”_NAS存储_什么值得买NAS也能用上【统一认证】_NAS存储_什么值得买使用Plex &amp; Docker搭建自己的媒体服务器 - RIN’S HOME利用 Jellyfin + Bangumi 打造更舒适的动画媒体库 - 初之音"
  },
  
  {
    "title": "WordPress 数据库禁用插件",
    "url": "/archives/72",
    "categories": "网站建设",
    "tags": "WordPress",
    "date": "2022-09-15 22:17:02 +0800",
    





    
    "snippet": "引言启用某插件后台 502 了进入数据库      选择进入 wp_options 表        找到 active_plugins 条目，一般在第二页        编辑此项目的 option_value 行  删除不要的插件注意：删除前先备份！！！      找到不需要的插件的名字    删除从 i 开始到 ;，例如 i:1;s:23:\"elementor/elementor.php...",
    "content": "引言启用某插件后台 502 了进入数据库      选择进入 wp_options 表        找到 active_plugins 条目，一般在第二页        编辑此项目的 option_value 行  删除不要的插件注意：删除前先备份！！！      找到不需要的插件的名字    删除从 i 开始到 ;，例如 i:1;s:23:\"elementor/elementor.php\";        更改序号，也就是 i, 后的数字        更改总数，也就是最开头 a: 后的数字  参考文章禁用数据库中的一个WordPress插件 - WordPress - GoDaddy 帮助 SG"
  },
  
  {
    "title": "Fedora 安装 Komga 折腾记录",
    "url": "/archives/71",
    "categories": "折腾记录",
    "tags": "Docker",
    "date": "2022-09-14 18:47:16 +0800",
    





    
    "snippet": "引言为了在内网更方便得看漫画IP 设置路由器为 OpenWRT 系统路由器设置在 网络- IP/MAC 绑定 将电脑绑定一个固定的 IPFedora 设置因为我设置的 IP 与自动分配的不一致 (有线连接) ，固需要手动修改在 网络-设置 的 身份 加上 MAC 地址，IPv4 改为 手动，地址依次为 IP、255.255.255.255、路由器 IP，DNS 加上 路由器 IP，未取消勾选...",
    "content": "引言为了在内网更方便得看漫画IP 设置路由器为 OpenWRT 系统路由器设置在 网络- IP/MAC 绑定 将电脑绑定一个固定的 IPFedora 设置因为我设置的 IP 与自动分配的不一致 (有线连接) ，固需要手动修改在 网络-设置 的 身份 加上 MAC 地址，IPv4 改为 手动，地址依次为 IP、255.255.255.255、路由器 IP，DNS 加上 路由器 IP，未取消勾选自动域名劫持尽管可以通过 IP 直接访问，但是有一个域名会更加好记吧在路由器 网络-主机名 的 主机名 处填入域名，IP 地址 处填入电脑的 IP安装 Docker安装了有 GUI 的 Docker Desktop设置仓库dnf -y install dnf-plugins-coresudo dnf config-manager \\    --add-repo \\    https://download.docker.com/linux/fedora/docker-ce.repo下载 RPM 包在 官网 Download 处 下载下载完成后直接双击安装安装 KomgaDocker 设置  文件共享设置在 Docker Desktop 的 设置-Resources-File sharing 添加漫画路径注：如果共享的目录在下次启动不存在 (未挂载) ，docker 将无法正常启动  网络设置不清楚是否非必须，在 设置-Resources-Network 设置为了自己的网段命令行安装直接在 shell 敲入docker run \\  --name=komga \\  --user 1000:1000 \\  -p 2333:8080 \\  -v /home/yexca/komga/config:/config \\  -v /home/yexca/komga/data:/data \\  --restart unless-stopped \\  gotson/komga:latest  -p前一个为本机映射端口，后一个为容器  -v文件映射，将本机的目录 (/home/yexca/komga/config) 映射到容器的 (/config)注：无法映射本机的隐藏文件 (以 . 开头的文件)GUI 安装在上一步做完后 Docker Desktop 的 Imags 会多出一个 gotson/komga，点击 run，然后配置      第一行：名字        Ports：映射到本机的端口，比如 80，这样就可以直接域名访问了        Volumes：路径映射        Environment variables：环境变量，此处用不到  检测是否运行使用命令查看docker ps -a防火墙配置打开端口firewall-cmd --zone=public --add-port=80/tcp加载配置firewall-cmd --reload查看端口打开状态firewall-cmd --zone=public --query-port=80/tcp可能需要添加服务firewall-cmd --add-service=http实在不能开就用 GUI 吧 (一开始就用会更快吧)sudo yum install firewall-config参考文章Install Docker Desktop on Fedora - Docker Documentation【Docker】Error response from daemon: invalid mount config for type “bind”: bind source path does not exist - QiitaRun with Docker - Komga简约但绝不简单的Komga-老苏的blogfedora 28 , firewalld 防火墙控制，firewall-cmd 管理防火墙规则 - xuyaowen - 博客园Fedora防火墙配置 - 上官飞鸿 - 博客园原神自动签到(Linux服务器Docker) - yexca’BlogFedora 打开8080端口_chunqi zhi的博客-CSDN博客"
  },
  
  {
    "title": "SSH 公钥登录",
    "url": "/archives/70",
    "categories": "Linux",
    "tags": "",
    "date": "2022-09-12 19:24:25 +0800",
    





    
    "snippet": "引言每次连接机子都要输入密码属实有点麻烦 (因为我忘了OneClick如果自己的电脑没有公钥需要先生成，一般在 ~/.ssh/id_rsa.pubssh-keygen然后在自己的电脑上运行下个命令ssh-copy-id username@RemoteIP其中 username 替换为要登录的账户，RemoteIP 替换为要登录的 IP 地址等待提示输入密码然后直接 SSH 连接就可以登录上去...",
    "content": "引言每次连接机子都要输入密码属实有点麻烦 (因为我忘了OneClick如果自己的电脑没有公钥需要先生成，一般在 ~/.ssh/id_rsa.pubssh-keygen然后在自己的电脑上运行下个命令ssh-copy-id username@RemoteIP其中 username 替换为要登录的账户，RemoteIP 替换为要登录的 IP 地址等待提示输入密码然后直接 SSH 连接就可以登录上去啦ssh username@RemoteIP非常的方便！写入文件如果需要把别人的公钥写入或忘记密码可能使用这方法编辑配置文件 (可能需要提前更改文件权限) ~/.ssh/authorized_keys 加入公钥，一行一个，编辑完保存即可 (如果更改了文件权限别忘记改回 600)其实这时候已经可以免密登录了，不过可能还需要更改配置文件编辑文件 /etc/ssh/sshd_configPasswordAuthentication yes　　　　　　# 口令登录RSAAuthentication yes　　　　　　　　　# RSA认证PubkeyAuthentication yes　　　　　　　# 公钥登录 如果需要同时使用公钥与密码验证登录更改上述配置文件AuthenticationMethods publickey,password重启 SSHD 服务sudo service sshd restart参考文章SSH 公钥登录 - starnight_cyber - 博客园"
  },
  
  {
    "title": "Linux学习 第三章 使用 shell",
    "url": "/archives/69",
    "categories": "Linux",
    "tags": "读书笔记",
    "date": "2022-09-12 15:04:10 +0800",
    





    
    "snippet": "第三章 使用 shell本章介绍的 Linux shell 称为 Bash shell，其全称为 Bourne Again shell。还有其他的 shell，例如在 BSD UNIX 用户中流行的 C shell (csh) ，以及在 UNIX System V 用户中非常流行的 Korn shel (ksh) ，Ubuntu 默认启动 Dash shell (速度比 Bash快) ，还有...",
    "content": "第三章 使用 shell本章介绍的 Linux shell 称为 Bash shell，其全称为 Bourne Again shell。还有其他的 shell，例如在 BSD UNIX 用户中流行的 C shell (csh) ，以及在 UNIX System V 用户中非常流行的 Korn shel (ksh) ，Ubuntu 默认启动 Dash shell (速度比 Bash快) ，还有 Tcsh shell (一种改进的 C shell) 和 Ash shell (与 Bourne shell 非常相似)3.1 shell 和 Terminal 窗口  使用 Terminal 窗口通过运行的 GUI，可以打开一个终端仿真程序 (有时也称为 Terminal 窗口) ，从而启动一个 shell大部分系统通过 Ctrl+Shift+T 快捷键打开，Fedora 可在程序中寻找，或者按 alt+F2 后输入 gnome-terminal  使用虚拟控制台大多数有 GUI 的 Linux 系统在启动时通常会运行多个虚拟控制台，虚拟控制台除了可以打开 GUI 之外，还可以打开多个 shell 会话通过 Ctrl+Shift+F1~F6 可切换虚拟控制台。以 Fedora 为例，tty1 为 gdm (登录屏幕) ，tty2 为第一个桌面， tty3 为第二个桌面 (纯文本) ，以此类推  命令提示符对于普通用户来说，默认的提示符是一个简单的美元符号$对于 root 用户来说，默认的提示符是一个英镑符号 (有时也称为 number sign 或 hash tag)#生动形象得说明了美国本源在英国3.2 选择 shell使用 who 命令即可显示当前登录用户名，登录的虚拟控制台以及登录的时间使用 grep username /etc/passwd 命令，在输出的最后可看到默认使用的 shell可以通过输入命令以切换 shell，例如 ksh、tcsh、csh、sh、dash 或其他 shell (假设已经安装了这些 shell)  学习 Bash shell 不仅是因为它是大多数安装中默认的 shell，也是因为它是大多数 Linux 认证考试中所使用的 shell3.3 运行命令虽然只需要通过输入命令名称就可以运行许多命令，但更常见的做法是在命令之后输入 more，从而改变其行为。在命令之后输入的字符和单词成为选项和参数3.3.1 了解命令语法  大多数命令都有一个或多个用来改变命令行为的选项一般选项由单个字母构成，并在前面添加一个连字符 - ，然而为了每次使用多个选项，也可以将多个但字母选项组合在一起，或者在每个选项前面都使用一个连字符一些命令的选项由一个完整的单词组成，一般需要在单词前使用双连字符 -- 。例如，为了使用 help 这个选项，需要输入 --help ，如果是 -help 将被解释为 -h 、-e 、-l 、-p 这四个选项。尽管有些命令不遵守双连字符约定，但大多数命令还是要在单词选项前使用双连字符  此外，大多数命令还可在输入某些选项后或者整个命令行结尾处接受参数参数是一个额外的信息块，比如文件名、目录、用户名、设备或其他用来告诉命令如何运行的信息。通常，在命令行中可以使用任意数量的参数，只要数量不超过单个命令行所允许的总字母数即可有时，一个参数与一个选项相关联，此时参数必须跟在选项之后。如果使用的是单字母选项，那么参数通常在一个空格后。而对于全单词选项，参数跟在一个等号 = 之后例如tar -cvf backup.tar /home/yexca选项的含义是创建 (c) 一个名为 backup.tar 的文件 (f) ，其中包含 /home/yexca 目录的全部文件，并且在备份文件创建完毕 (v) 后显示详细信息。因为 backup.tar 是 f 选项的一个参数，所以 backup.tar 必须跟在选项之后ls --hide=Desktop–hide 选项告诉 ls 命令不要显示名为 Desktop 的文件或目录，注意选项与参数之间没有空格  还可以尝试其他的命令uname 命令显示正在运行的系统类型，添加了 -a 选项后还可以查看主机名及内核版本当登录到一个 Linux 系统时，Linux 会认定您具有特定的身份，其中包括用户名、组名、用户 ID 和组 ID。此外，Linux 还会跟踪登录会话，从而了解登录的时间、空闲的时间以及登录的地点等。可通过 id 命令查看身份相关信息  启用了 SELinux (Security Enhanced Linux) 的 Linux 发行版本都在 id 输出的末尾显示了额外信息，例如  context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023  SELinux 提供了一种可以紧紧锁定 Linux 系统安全性的方法通过 who -uH 可添加关于空闲时间和进程 ID 信息 (u) ，以及要求打印标头 (H)空闲 (IDLE) 表示没有任何命令输入的情况下 shell 保持打开状态的时间长度。进程号 (PID) 表示用户登录 shell 的进程 ID。而备注 (COMMENT) 则表示用户用来进行登录操作的远程计算机名称 (前提是用户使用了网络上的另一台计算机进行登录) ，或者本地 X Display 的名称 (前提是用户正在使用一个 Terminal 窗口) ，比如 :0.03.3.2 查找命令为了找到所输入的命令，shell 在所谓的路径中进行查找，对于不在路径中的命令，可通过输入命令位置的完整标识进行运行通过 echo $PATH 以查看 shell 的环境变量 PATH参考：Linux 下 bin 目录 - yexca‘Blog与其他一些操作系统不同的是，默认情况下，在搜索路径之前，Linux 并不会为了查找可执行文件检查当前目录，而是马上开始搜索路径，只有在可执行文件位于 PATH 环境变量或者给定了可执行文件的绝对地址或相对地址时，才会运行当前目录的可执行文件并不是所有的命令都位于 PATH 变量的目录中，一些命令内置于 shell，通过创建用来定义任何命令的别名以及选项，可以重写另外一些命令。下面是 shell 检查输入命令的顺序      别名。由 alias 命令设置的名称，可输入此命令以查看创建的别名        shell 保留字。shell 保留了一些单词用作特殊用途        函数。一组能够在当前 shell 中共同运行的命令        内置命令。内置于 shell 中的命令，在文件系统中没有命令的表现形式，例如 cd、echo、exit、pwd、history (查看以前运行的命令列表)、fg (将一个后台运行的命令带入前台) 、set (设置 shell 选项) 和 type (显示命令的位置)        文件系统命令。存储在计算机文件系统中的命令 ( 这些命令由 PATH 变量值表示)  为了知道命令的出处，可以使用 type 或者 which 命令，通过使用 type -a 可显示命令的所有已知位置如果一些命令不在 PATH 变量中，可使用 locate 命令尝试查找该命令，通过使用 locate 命令可以访问系统中任何可访问的部分locate 命令会对整个文件系统进行查找，而不仅仅是在包含了命令的目录中查找，如果没有找到最近添加的文件，可以 root 用户身份运行 updatedb 以更新 locate 数据库3.4 使用命令历史记录重复执行命令重复执行那些冗长、复杂且易于输错的命令将可以避免很多问题的出现3.4.1 命令行编辑默认情况下，Bash shell 使用基于 Emacs 文本编辑器的命令行编辑。如果更喜欢使用 vi，可以将 set -o vi 添加到主目录的 .bashrc 文件中  用来导航命令行的按键            按键      全称      含义                  Ctrl+F      向前一个字符      前进一个字符              Ctrl+B      向后一个字符      后退一个字符              Alt+F      向前一个单词      前进一个单词              Alt+B      向后一个单词      后退一个单词              Ctrl+A      命令行开头      转到当前命令行的开头              Ctrl+E      命令行结尾      转到当前命令行的结尾              Ctrl+L      清除屏幕      清除屏幕，并使光标停留在屏幕顶部        用来编辑命令行的按键            按键      全称      含义                  Ctrl+D      删除当前字符      删除当前字符              Backspace      删除前一个字符      删除前一个字符              Ctrl+T      调换字符      交换当前字符和前一个字符的位置              Alt+T      调换单词      交换当前单词和前一个单词的位置              Alt+U      大写单词      将当前单词改为大写              Alt+L      小写单词      将当前单词改为小写              Alt+C      首字母大写单词      把光标当前位置单词的头一个字母变为大写              Ctrl+V      插入特殊字符      添加一个特殊字符，例如添加 Tab        用来剪切和粘贴命令行中文本的按键            按键      全称      含义                  Ctrl+K      剪切到行末      剪切光标后面的所有字符              Ctrl+U      剪切到行首      剪切光标后面的所有字符              Ctrl+W      剪切前一个单词      剪切位于当前光标之后的一个单词              Alt+D      剪切后一个单词      剪切位于当前光标之前的一个单词              Ctrl+Y      粘贴当前文本      粘贴最近剪切的文本              Alt+Y      粘贴早期文本      转回到早期剪切的文本并粘贴              Ctrl+C      删除整行      删除整个命令行      3.4.2 命令行补齐为了减少按键，Bash shell 提供了多种不同的方法来补齐部分输入值。为了尝试补齐一个值，需要输入前几个字符并单击 Tab 键。下面是可以通过 Bash shell 部分输入的值：      命令、别名或函数。如果所输入的文本以常规字符开头，shell 将尝试使用命令、别名或者函数名来补齐该文本        变量。如果所输入的文本以美元符号 $ 开头，那么 shell 将使用来自当前 shell 的一个变量来补齐文本        用户名。如果所输入的文本以波浪号 ~ 开头，shell 将使用一个用户名补齐文本。因此，~username 表示指定用户的主目录        主机名。如果所输入的文本以 at 符号 @ 开头，shell 将使用来自 /etc/hosts 文件中的一个主机名补齐文本    如果想要添加来自其他文件的主机名，只需要将 HOSTFILE 变量设置为该文件名，但该文件是与 /etc/hosts 相同的格式如果所输入的字符串可以产生多种补齐结果，此时可以通过双击 TAB 键列出所有可能的结果3.4.3 命令行重复执行在输入完一行命令后，该命令行会保存到 shell 的历史命令列表中通过 history 命令查看历史命令列表，或者添加数字参数以显示指定数量的最新命令通过使用感叹号 ! 以重复执行这些命令，此种方法将直接执行，没有再次确认的机会      !n — 运行命令编号。例如 !255 将运行第 255 个命令        !! — 运行前一个命令        !?string? — 运行包含字符串的命令  除了直接运行 history 外，还可重复执行特定命令并进行编辑            按键      功能      描述                  箭头键或Ctrl+P 与 Ctrl+N      步骤      遍历历史命令列表的每一个命令行，直到找到所需的命令行              Ctrl+R      反向增量搜索      按下后可输入一个搜索字符串，完成反向搜索。当输入字符串时，会出现可以运行或编辑的相匹配的命令行              Ctrl+S      向前增量搜索      与上一个类似，不过是向前搜索。并不是所有情况都可用              Alt+P      反向搜索      按下后可输入一个搜索字符串，完成反向搜索。输入字符串并单击 Enter 键后可看到该字符串的最新命令行              Alt+N      向前搜索      与上一个类似，不过是向前搜索。并不是所有情况都可用      还可使用 fc 命令以使用历史命令列表。输入 fc 后跟着一个历史命令行编号或一个范围 (例如 fc 233 255) ，将在文本编辑器中打开这些命令 (默认为 vi) ，关闭编辑器后命令将 (逐个) 运行关闭 shell 后，历史命令列表将保存到主目录的 .bash_history 文件中，默认最多保存1000条  如果不想保存历史命令列表，就不要正常退出 shell，可通过 kill -9 PID 关闭 shell 会话以不保存历史命令  将变量 HISTFILE 设置为 /dev/null 或保持 HISTSIZE 为空都是没用的，只要 shell 正常退出，就会永久保存 shell 历史3.5 连接和拓展命令shell 真正强大的功能在于能将命令的输入和输出重定向到其他命令或文件中，反之亦然为了将命令串在一起，shell 使用了元字符 (metacharacter) 。元字符是对 shell 有特殊含义的输入字符，用于连接请求或拓展请求元字符包括管道字符 | 、与号 &amp; 、分号 ; 、右括号 ) 、左括号 ( 、小于号 &lt; 和大于号 &gt;3.5.1 命令之间的管道管道字符 | 将一个命令的输出连接到另一个命令的输入，例如cat /etc/passwd | sort | less该命令列出 /etc/passwd 文件内容。输出到 sort 命令以对内容排序，最后发送到 less 以显示输出3.5.2 连续命令使用分号 ; 将多个命令隔开可在同一命令行输入多条命令以执行连续的命令，例如date ; troff -me VertLargeDocument | lpr ; date对一个很大的文档格式化，并显示格式化所需的时间3.5.3 后台命令一些命令可能需要花费很长时间才能完成，可使用与号 &amp; 让命令在后台运行，例如troff -me VertLargeDocument | lpr &amp;在进程结束之前不要关闭 shell 或杀死该进程，否则进程将终止3.5.4 拓展命令通过命令替换，可以使一条命令的标准输出变为另一条命令的一个参数命令替换的两种形式是 $(command) 和 command (注意是反引号)两种形式中的命令可以包括选项、元字符和参数，例如vi $(find /home | grep xyzzy)在 vi 命令运行之前完成了命令替换。首先 find 命令从 /home 目录寻找所有文件于目录，然后将输出连接到 grep 命令，将文件名中不包含 xyzzy 的过滤掉，最后使用 vi 打开所有文件进行编辑 (每次打开一个文件)注意：不要从根文件系统开始使用 grep，否则将匹配并尝试编辑几千个文件3.5.5 扩展算术表达式有时可能需要将算术结果传递给一条命令。通过 S[expression] 或者 S(expression) ，例如echo \"I am $[2022-1957] years old\"输出为 I am 65 years oldecho \"There are S(ls | wc -w) files in this directory\"该命令列出当前目录内容 (ls) 并运行了单词计数命令，计算出找到的文件数量 (wc -w) ，然后输出3.5.6 扩展变量使用美元符号 $ 对 shell 中用来存储信息的变量进行拓展。当在命令行中扩展一个环境变量时，所打印的是变量的值，而不是变量名，例如ls -l $BASH打印 bash 命令的长列表 -rwxr-xr-x. 1 root root 1390064  1月 20  2022 /usr/bin/bash3.6 使用 shell 变量shell 本身使用变量存储了对用户的 shell 会话非常有用的信息。如果想要查看当前 shell 设置的所有变量，可以使用 set 命令其中，本地变量的一个子集被称为环境变量，对任何通过当前 shell 打开的新 shell 都是可用的。可以使用 env 命令查看环境变量除了所设置的变量之外，系统文件也会设置一些用来存储相关信息的变量，比如配置文件、邮箱以及路径目录的位置。此外，这些变量还可以存储关于 shell 提示符、历史命令列表的大小以及操作系统类型的相关值。如果想引用这些变量的值，需要在变量之前添加一个美元符号 $当启动一个 shell 时，许多环境变量已经被设置了，下表为一些既可以在使用 Bash shell 时设置，又可以为了使用不同功能而设置的变量            变量      描述                  BASH      包含了 Bash 命令的完整路径。其值通常为 /bin/bash              BASH_VERSION      表示当前 Bash 命令版本的一个数字              EUID      表示当前用户有效的用户 ID 号。当启动 shell 时，根据 /etc/passwd 文件中的用户项进行赋值              FCEDIT      fc 命令用来编辑 history 命令的文本编辑器，默认为 vi              HISTFILE      历史命令文件的位置，通常位于 $HOME/bash_history              HISTFILESIZE      可以存储的历史命令条目的数量。当达到该数量时，最早的命令将被丢弃，默认为 1000              HISTCMD      返回历史命令列表中当前命令的数量              HOME      主目录              HOSTTYPE      描述了 Linux 系统正在运行的计算机系统结构。对于 Intel 兼容的 PC，其值为 i386、i486 或 i386-Linux 类似的值。而对于 AMD 64 位计算机，其值为 x86_64              MAIL      邮箱文件的位置，通常为 /var/spool/mail/$USER              OLDPWD      修改当前工作目录之前的工作目录              OSTYPE      用来识别当前操作系统。对于 Fedora，值为 Linux 或 Linux-gnu              PATH      值为冒号 : 分隔的目录列表，主要用来查找需要输入的命令              PPID      当前 shell 的命令的进程 ID              PROMPT_COMMAND      可以将该变量设置为一个命令名，以便在每次 shell 提示符显示之前运行该命令              PS1      设置 shell 提示符的值。由时命令需要额外的提示符，可以使用变量 PS2、PS3 等进行设置              PWD      表示当前目录              RANDOM      生成一个 0~99999 的随机数              SECONDS      自 shell 启动后的秒数              SHLVL      与当前 shell 会话相关联的 shell 级别数。当登录到 shell 时，值为 1，每执行一次 Bash 命令后该级别数将递增 (例如使用 su 命令或输入 bash)              TMOUT      可以为该变量设置一个数字，表示 shell 可以空闲的秒数。在秒数到达后，shell 将会退出 (注销用户)      3.6.1 创建和使用别名使用 alias 命令可以列出所有别名以及创建别名alias p = 'pwd ; ls -CF'运行 p 命令，将运行 pwd 命令后运行 ls -CF 以列的形式列出该目录的内容如果想删除，可使用 unalias 命令3.6.2 退出 shell输入 exit 或者按 Ctrl+D3.7 创建自己的 shell  环境可以通过调整 shell 以帮助更有效地工作3.7.1 配置 shellshell 的行为方式由多个配置文件所支持            文件      描述                  /etc/profile      为每个用户设置了用户环境信息，当首次登录时执行该文件。该文件还从 /etc/profile.d 目录的配置文件中收集相关的 shell 设置。除了为诸如用户邮箱位置以及历史文件大小的信息设置环境变量，还提供了路径值              /etc/bashrc      每次打开一个 Bash shell 时都会执行该文件，可通过每个用户的 ~/.bashrc 文件中的信息重写该文件。设置了默认的提示符，同时还可添加一个或多个别名              ~/.bash_profile      用来被每个用户用来输入 shell 具体用法的信息，只有当用户登录才会执行该文件。默认情况下，它设置一些环境变量并执行用户的 .bashrc 文件。该文件是添加环境变量的绝佳位置              ~/.bashrc      包含了特定于 Bash shell 的信息，当进行登录以及每次打开一个新 Bash shell 都会读取该文件。该文件是添加别名的好地方              ~/.bash_logout      每次注销时执行该文件，默认会清除屏幕      如果想更改 /etc/profile 或 /etc/bashrc 文件，则必须是 root 用户。一般创建 /etc/profile.d/custom.sh 文件来添加系统范围的设置，而不是直接编辑这些文件  nano 编辑器较为简单的文本编辑器，Ctrl+O 保存文件，Ctrl+X 退出文件3.7.2 设置提示符提示符由一组字符组成，每当 shell 准备接收命令时都会显示这组字符。PS1 环境变量设置了提示符所包含的内容，如果需要额外的输入u，可以使用 PS2、PS3 以及 PS4 的值            特殊字符      描述                  \\!      显示当前命令历史记录编号，包括为用户名存储的所有以前的命令              \\#      显示当前命令的命令编号，仅包括用于获取 shell 的命令              \\$      根据用户类型的不同，显示用户提示符 $ 或 root 提示符 #              \\W      仅显示当前工作的基名              \\[      出现在非打印字符序列之前。可用来向提示符添加终端控制序列，比如改变颜色、添加闪烁效果或使字符变粗 (所使用的终端决定了最终可用的序列)              \\]      紧跟在非打印字符序列之后              \\\\      显示一个反斜杠              \\d      显示当前日期的星期数、月份以及日子              \\h      显示正在运行 shell 的计算机的主机名              \\n      换行符              \\nnn      显示替换 nnn 的八进制数所表示的字符              \\s      显示当前 shell 的名称              \\t      以小时、分钟、秒的格式打印当前时间              \\u      打印当前用户名              \\w      显示当前工作目录的完整路径      如果仅临时修改，例如 export PS1=\"[\\t\\w]\\$\"如果永久修改，需要向 ~/.bashrc 添加 PS1 值阅读更多：Bash Prompt HOWTO3.7.3 添加环境变量有时可能需要向 .bashrc 文件添加一些环境变量      TMOUT — 设置在 Bash 自动退出之前 shell 可以处于非活跃状态多长时间        PATH — 设置了对所使用命令进行搜索的目录。例如为了添加目录 /home/yexca/bin，可添加以下代码    PATH=$PATH: /home/yexca/bin ; export PATH    该示例首先将所有当前的路径目录 ($PATH) 读取到新 PATH 变量中，然后添加 ~/bin 目录，最后导出新的 PATH 变量    切勿将 . 添加到 PATH 变量，可能存在安全风险      WHATEVER — 可以创建自己的环境变量，为工作提供快捷方式。为这些变量选择一个未被使用的任何名称，并赋予一个有用的值。例如    MYWORKDIR=/home/yexca/work ; export MYWORKDIR    可通过输入 cd $MYWORKDIR 使设置的目录成为当前目录  3.8 获取关于命令的信息一些命令内置于 shell 中，例如 help | less 以浏览帮助信息，或者 help command 以查看某命令的帮助信息在命令中使用 --help 选项或 -h 选项以查看命令提供的帮助信息还有 info 和 man command 命令学习某一特定命令手册页是获取命令以及 Linux 系统中其他基本组件相关信息的最常用方法手册页有 8 个章节            节数      节名称      描述                  1      用户命令      可以由普通用户通过 shell 运行的命令              2      系统调用      某一应用程序中用来调用系统内核的编程函数              3      C 库函数      为特定编程库提供接口的编程函数              4      设备和特殊文件      表示硬件设备或软件设备的文件系统节点              5      文件格式和约定      文件类型或特定的配置文件              6      游戏      系统中可玩的游戏              7      杂项      对相关主题的 (如协议、文件系统) 概述              8      系统管理工具和守护进程      需要 root 或其他管理特权的命令      通过 man -k 可搜索手册页数据库。若无搜索结果可能是未初始化，使用 root 身份运行 mandb 以初始化数据库通过例如 man 5 passwd 以显示第 5 节内容浏览时通过 Page Down 和 Page UP 以翻页，或使用 Enter 与箭头键以移动一行。如果想要搜索，使用正斜杠 / 然后输入要搜索的内容，通过 n 重复向前搜索，N 以重复向后搜索。输入 q 以退出"
  },
  
  {
    "title": "Linux下载youtube视频",
    "url": "/archives/68",
    "categories": "软件配置",
    "tags": "Youtube",
    "date": "2022-09-10 19:29:58 +0800",
    





    
    "snippet": "引言既然都有Win命令行了，那怎么能没有Linux呢Windows的文章：命令行下载YouTube视频下载yt-dlp建议配置好Python环境，然后到Releases · yt-dlp/yt-dlp · GitHub下载yt-dlp，如果不想配置Python就下载yt-dlp_linux下载完成后赋予执行权限放在/usr/local/bin/下下载ffmpeg参考官网Download FF...",
    "content": "引言既然都有Win命令行了，那怎么能没有Linux呢Windows的文章：命令行下载YouTube视频下载yt-dlp建议配置好Python环境，然后到Releases · yt-dlp/yt-dlp · GitHub下载yt-dlp，如果不想配置Python就下载yt-dlp_linux下载完成后赋予执行权限放在/usr/local/bin/下下载ffmpeg参考官网Download FFmpegFedora下使用以下命令sudo dnf install ffmpeg配置文件切换配置目录cd ~/.config创建文件夹并进入mkdir yt-dlpcd yt-dlp创建配置文件vi config我的配置文件如下-f bv+ba/b -o ~/Videos/%(uploader)s/%(upload_date)s%(title)s%(id)s.%(ext)s --continue --merge-output-format mp4解释一下-f bv+ba/b # 最高画质和音频-o # 输出文件夹配置/%(uploader)s/ # 按频道名创建文件夹%(upload_date)s # 上传时间%(title)s # 视频标题%(id)s # 视频id.%(ext)s # 视频拓展名--continue # 断点续传--merge-output-format mp4 # 混合为mp4视频参考文章ffmpeg批量转换视频格式 话说自己的文章有必要放链接吗"
  },
  
  {
    "title": "萌百黑幕在 Argon 主题 WordPress 实现",
    "url": "/archives/67",
    "categories": "网站建设",
    "tags": "WordPress",
    "date": "2022-09-05 21:51:23 +0800",
    





    
    "snippet": "引言这个黑幕很好玩啊，非常好玩啊，可惜首页无法渲染出来，而且Markdown编写渲染也难使用编写文章时选择作为HTML编辑，插入以下语句&lt;span class=\"heimu\" title=\"黑幕弹框里的字\"&gt;需要隐藏的文字&lt;/span&gt;插入CSS本是想着实现首页也有黑幕，但实际测试发现首页不会渲染为什么不渲染啊啊啊啊啊啊啊！！！！！！！进入后台设置，找到页脚设置，输入...",
    "content": "引言这个黑幕很好玩啊，非常好玩啊，可惜首页无法渲染出来，而且Markdown编写渲染也难使用编写文章时选择作为HTML编辑，插入以下语句&lt;span class=\"heimu\" title=\"黑幕弹框里的字\"&gt;需要隐藏的文字&lt;/span&gt;插入CSS本是想着实现首页也有黑幕，但实际测试发现首页不会渲染为什么不渲染啊啊啊啊啊啊啊！！！！！！！进入后台设置，找到页脚设置，输入以下代码，或者在WP的自定义CSS处插入，不过需要去掉标签&lt;style&gt;.heimu, .heimu a, a .heimu, .heimu a.new {  background-color: #252525;  color: #252525;  text-shadow: none;}.heimu:hover, .heimu:active,.heimu:hover .heimu, .heimu:active .heimu {  color: white !important;}.heimu:hover a, a:hover .heimu,.heimu:active a, a:active .heimu {  color: lightblue !important;}.heimu:hover .new, .heimu .new:hover, .new:hover .heimu,.heimu:active .new, .heimu .new:active, .new:active .heimu {  color: #BA0000 !important;}&lt;/style&gt;注：因Argon不会渲染注释，所以我不把以下内容放入代码中：/*阅读更多：https://zh.moegirl.org/MediaWiki:Mobile.css 本文引自萌娘百科(https://zh.moegirl.org)，文字内容默认使用《知识共享 署名-非商业性使用-相同方式共享 3.0》协议。*/参考文章Re：萌娘百科上的黑幕实现 – Vanilla_chan – 博客园萌百黑幕CSS代码-Hiyoung’blog"
  },
  
  {
    "title": "记录 OpenWRT 通过深澜网络认证折腾",
    "url": "/archives/66",
    "categories": "折腾记录",
    "tags": "OpenWRT",
    "date": "2022-09-05 21:24:23 +0800",
    





    
    "snippet": "引言记录我使用OpenWRT路由器连接学校网的折腾过程，虽然最后的结果挺 emm？但在这个过程中还是了解到不少东西起始通过在浏览器搜索openwrt通过深澜认证得到恩山无线论坛帖子回复下的一个开源项目：coffeehat/BIT-srun-login-script，通过项目知道了有支持多平台（包括openwrt）的golang版本，于是开始折腾这是项目作者的文章：深澜校园网登录的分析与pyt...",
    "content": "引言记录我使用OpenWRT路由器连接学校网的折腾过程，虽然最后的结果挺 emm？但在这个过程中还是了解到不少东西起始通过在浏览器搜索openwrt通过深澜认证得到恩山无线论坛帖子回复下的一个开源项目：coffeehat/BIT-srun-login-script，通过项目知道了有支持多平台（包括openwrt）的golang版本，于是开始折腾这是项目作者的文章：深澜校园网登录的分析与python实现-北京理工大学版折腾前对于OpenWRT版本未提供编译后的版本，即IPK文件，又因为我水平不行看不懂README便请教同学得知为Linux的指令，但在实际操作后得知此命令为编译Linux内核，便放弃在实体机做开始使用虚拟机搞参考：Building a custom kernel/zh-cn - Fedora Project Wiki开始折腾另朋友发了configuration - How to fix make error “No rule to make target ‘menuconfig’” when building a kernel for Beagleboard? - Unix &amp; Linux Stack Exchange，于是我便照着此帖子回答尝试创建虚拟机因为我使用的Fedora自带虚拟机软件盒子，首先尝试装CentOS8，因为我的镜像文件放到了移动硬盘中，便直接挂载，选择。结果提示创建失败，然后我尝试了CentOS7，失败，然后Ubuntun，失败接连失败，要不是我之前用这软件创建过Win10我都快怀疑是不是软件不行了，打开错误日至，果然看不懂，不过我注意到路径有中文，于是把路径改为英文，再次尝试，失败然后第二天我在想既然是编辑内核，要不使用kali吧，于是把U盘中kali镜像复制到电脑，虽然最后安装失败但成功运行了，难道要把系统放本地才行吗于是我把CentOS7的镜像拷贝到~/Documents/下，安装成功。因想着只是编译IPK便只有root用户连接网络本以为在Linux下创建Linux虚拟机可以直接共享网络的，于是我直接输入命令wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.19.6.tar.xz，结果就是无法找到IP地址，使用命令ifconfig发现无IP参考文章在虚拟机中设置静态IP（centos为例）使虚拟机连上网络，不过在最后文件修改只需要将ONBOOT后的值改为yes然后加俩DNS就行安装git连上网后我先装了个git，使用yum install git即可，然后配置姓名与邮箱git config --global user.name \"Name\"git config --global user.email \"email@example.com\"传输文件继续使用wget下载Linux内核，尝试了三四次，几乎都是在50%左右下载失败而且速度很慢注：使用wget -c URL可实现断点续传然后就是盒子这个软件貌似支持直接拖拽传输，于是我在我的电脑下载好后直接托过去，失败，文件没有被传输过去，考虑到传输后的文件在~/Downloads/下，我使用的是root账户，于是我参考Linux添加用户和管理员用户创建了一个用户（差点把最后一步删除用户也执行了使用命令su username切换用户，创建文件夹~/Downloads/，再次拖入还是失败尝试使用盒子的共享功能将电脑的~/Public共享，但我怎么操作也不能在虚拟机里看到想必这软件只适配了RHEL和Fedora吧SSH传输然后我想到了通过SSH传输（因为我输入ftp发现没这个命令，懒得装了本地开启SSH连接，然后通过scp命令以使用SSH传输文件scp username@servername:/path/filename ~/Downloads/首先是确定IP，在虚拟机中输入命令ip route得知IP为10.0.2.2然后使用scp命令传输解压文件使用tar命令解压文件tar -xzvf filename.tar.xzemm，非gzip压缩文件，那我不知道怎么解压啊SSH传输还是使用SSH传输吧，在scp命令加上-r即可传输文件夹开始尝试按照步骤将解压后的文件放到/usr/src/下，把/boot下的config放到/usr/src/linux-5.19.6/.config，结果无论是把配置文件放到.config/下还是放到.config都无法运行make menuconfig命令总结折腾失败，下次再来不过在我编写此文章时注意到原帖尝试直接在OpenWRT运行Python，有时间尝试一下再次尝试然后我咨询了一位过了认证校园网的朋友(虽然他是普通路由器)，他将路由器的MAC地址改为自己电脑的，结果插上网线认证页面会自动转发到电脑，然后认证后就有网了，不过是锐捷网页认证然后考虑到深澜使用的是Portal认证也就是Web页面认证，既然是Web那想必就是使用HTTP了，我是否可以通过编辑HTTP报文的方式通过认证呢？那么Linux有命令可以发送HTTP报文吗，我搜了一下，发现curl与wget命令可以模拟get和post请求于是我打开Fiddler开始抓包，企图还原验证过程才怪，我用路由器连接上学校网，电脑插上网线连上路由器，输入认证页面IP，认证完成，路由器有网了Linux命令模拟Http的get或post请求虽然没用到，不过既然看到了那就记录一下吧  GET请求  curl## 如果这里的URL指向的是一个文件可以直接下载到本地curl URL ## 显示全部信息curl -i URL ## 只显示头部信息curl -l URL ## 显示get请求全过程解析curl -v URL   wgetwget URL  POST请求  curl## 通过-d参数，把访问的参数放在里面curl -d \"param1=value1&amp;param2=value2\" \"URL\"curl -d'param1=value1&amp;param2=value2' -X POST URLcurl -d 'param1=value1' -d 'param2=value2' -X POST  URL  wget## 通过--post-data参数实现wget --post-data 'user=name&amp;passwd=passwd' URL再次总结有时候不能把某件事想的太复杂，往往很简单的事只思考而没实践就否认这种可能性是错误的，这次就是我一开始就把最后再次尝试部分否决才闹了这么一大圈（要不是流量卡的不行我才不会去试写到这时我想到了两句名言      学而不思则罔，思而不学则殆        实践得真知  所以有些时候还是应该大胆去尝试，不要因为过多的思考而限制了自己！参考文章求助深澜校园网Portal认证应该怎么刷固件？-小米无线路由器以及小米无线相关的设备-恩山无线论坛configuration - How to fix make error “No rule to make target ‘menuconfig’” when building a kernel for Beagleboard? - Unix &amp; Linux Stack Exchange在虚拟机中设置静态IP（centos为例） yexca’Blog安装Git - 廖雪峰的官方网站Linux添加用户和管理员用户 - yexca’Bloglinux 系统下如何进行用户之间的切换_M李丽的博客-CSDN博客_linux切换系统使用ssh传输文件 - 思否Linux tar 命令-菜鸟教程Portal认证原理-曹世宏的博客Linux命令发送Http的get或post请求(curl和wget两种方法)_cyl937的博客-CSDN博客"
  },
  
  {
    "title": "ffmpeg批量转换视频格式",
    "url": "/archives/65",
    "categories": "技术工具",
    "tags": "FFmpeg",
    "date": "2022-09-05 16:41:38 +0800",
    





    
    "snippet": "引言因为接触了YouTube-dl，下载频道的所有内容非常好用，但是下载下来是webm格式兼容性不是太好，于是查看了使用ffmpeg转换格式的命令配置文件后来发现改下配置文件就行，在文件后加上--merge-output-format mp4放下我的配置文件-o 'C:/Users/yexca/Downloads/Video/%(uploader)s/%(upload_date)s%(tit...",
    "content": "引言因为接触了YouTube-dl，下载频道的所有内容非常好用，但是下载下来是webm格式兼容性不是太好，于是查看了使用ffmpeg转换格式的命令配置文件后来发现改下配置文件就行，在文件后加上--merge-output-format mp4放下我的配置文件-o 'C:/Users/yexca/Downloads/Video/%(uploader)s/%(upload_date)s%(title)s%(id)s.%(ext)s' --merge-output-format mp4单个命令使用下述命令即可快速转码ffmpeg -i before.webm after.mp4但一个一个转码属实是太慢了，于是想到了使用批处理批处理新建记事本，输入以下代码for %%a in (*.webm) do ffmpeg -i \"%%~a\" -vcodec copy -f mp4 \"%%~na.mp4\"其中(*.webm)为原始文件类型 “%%~na.mp4″为想要生成的文件类型然后保存并命名为run.bat后放到相应文件夹运行即可但这样每次想转不同的文件还得编辑下，不大实用啊（dos然后我就看了一点bat文件的东西，简单写了下面的程序(需要使用GB2312编码才可以正常在命令行输出中文)echo off:0echo 请输入数字选择操作echo 1.转码echo 2.删除echo 3.退出set /p choice=请选择goto %choice%:1set /p before=请输入转码前文件格式set /p after=请输入转码后文件格式echo 开始转码%before%到%after%for %%a in (*.%before%) do ffmpeg -i \"%%~a\" -vcodec copy -f %after% \"%%~na.%after%\"echo 转码完成goto 0:2set /p delet=请输入需要删除的文件格式echo 开始删除%delet%del *.%delet%del %delet%echo 删除完成goto 0:3exit放到相应文件夹下用就好了参考文章youtube-dl 的一些实用技巧 · eisen blog给新手的 20 多个 FFmpeg 命令示例 - 知乎FDM挂了，youtube-dl鬼慢，烤肉man的末日到了！中AnnMilne的评论用bat命令运行ffmpeg进行批量转码-五仁的记录Bat命令学习 - 阳光雨露&amp; - 博客园bat set命令详解_python資深小白的博客-CSDN博客"
  },
  
  {
    "title": "HTTP 学习",
    "url": "/archives/64",
    "categories": "计算机网络",
    "tags": "HTTP, 读书笔记",
    "date": "2022-09-05 16:03:36 +0800",
    





    
    "snippet": "引言这是在我阅读了肖佳老师的书《HTTP抓包实战》后对HTTP相关内容的总结，主要还是报文相关(记录：阅读此书与写出此文章耗时5天)HTTP协议报文的结构HTTP报文分2个：一个是HTTP请求报文，一个是HTTP响应报文HTTP请求报文(Request)HTTP请求报文分为3个部分，第一部分叫起始行(Request line)，第二部分叫首部(Request Header)，第三部分叫主体(...",
    "content": "引言这是在我阅读了肖佳老师的书《HTTP抓包实战》后对HTTP相关内容的总结，主要还是报文相关(记录：阅读此书与写出此文章耗时5天)HTTP协议报文的结构HTTP报文分2个：一个是HTTP请求报文，一个是HTTP响应报文HTTP请求报文(Request)HTTP请求报文分为3个部分，第一部分叫起始行(Request line)，第二部分叫首部(Request Header)，第三部分叫主体(Body)      第一行中有Method(请求方法)、URI和协议版本。例如GET https://yexca.xyz/ HTTP/2        第二部分是Header(首部)        第三部分是Body(主体)  注意：Header首部和Body主体之间有一个空行HTTP响应报文(Responese)HTTP响应报文与请求报文的结构基本一样，也分为3个部分，第一部分叫响应行(Response line)，第二部分叫响应首部(Response Header)，第三部分是0主体(Body)      第一行有协议版本、状态码和状态码消息。例如HTTP/2 200        第二部分是Header(首部)        第三部分是Body(主体)  注意：Header首部和Body主体之间有一个空行HTTP协议请求方法和状态码URL格式URL的全称为Uniform Reasource Locator，中文译名为统一资源定位符，用于完整地描述Internet上某一处资源的地址URL的基本格式如下：schema://host[:port#]/path/.../[?query-string][#anchor]            属性      描述                  schema(协议)      指定底层使用的协议(例如：http，https，ftp)              host(域名)      HTTP服务器的IP地址或者域名              port#(端口)      HTTP服务器的默认端口是80,这种情况下端口号可以省略。如果使用了别的端口，则必须指明              path(资源的路径)      访问资源的路径              query-string(参数)      发送给HTTP服务器的数据              anchor(锚)      锚，页面内部超链接      HTTP请求方法            号      方法      描述                  1      GET      请求指定的页面信息并返回实体主体              2      HEAD      类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头              3      POST      向指定资源提交数据进行处理请求(例如提交表单或者上传文件)，数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或对已有资源的修改              4      PUT      从客户端向服务器传送的数据取代指定文档的内容              5      DELETE      请求服务器删除指定的页面      GET与POST的区别      GET提交的数据会放在URL之后，以?分隔URL和传输数据(即query-string，键值对方式)，参数之间以&amp;相连    而POST方法是把提交的数据放在HTTP包的Body中        GET提交的数据大小有限制(因为浏览器对URL的长度有限制)    而POST方法提交的数据大小没有限制        GET方式需要使用Request.QueryString来取得变量的值    而POST方法通过Request.Form来获取变量的值  HTTP状态码HTTP状态码存在于HTTP的响应报文中，其作用是Web服务器用来告诉客户端发生了什么事HTTP状态码被分为5大类，随着协议的发展，HTTP规范中会定义更多的状态码吧            状态码      已定义范围      分类                  1XX      100～101      信息提示，表示请求已被成功接收，继续处理              2XX      200～206      成功，表示请求已被成功接收、理解、接受              3XX      300～305      重定向，要完成请求，必须进行进一步的处理              4XX      400～415      客户端错误，请求有语法错误或请求无法实现              5XX      500～505      服务器错误，服务器未能实现合法的请求      常见状态码            名称      释义                  200      OK：服务器成功处理了请求              301/302      Moved Permanently(重定向)：请求的URL已移走。Response中应该包含一个Location URL，说明资源现在所处的位置              304      Not Modified(未修改)：客户端的缓存资源是最新的，需要客户端使用缓存              404      Not Found：未找到资源              401      禁止访问              501      Internal Server Error：服务器遇到一个错误，使其无法对请求提供服务      206(Partial Content，部分内容)206状态码代表服务器已经成功处理了部分GET请求(只有发送GET方法的HTTP请求，Web服务器才可能返回206)应用比如说使用下载工具实现断点续传或者在线视频播放都是使用206状态码来实现例如现在打开视频网站的一个视频，对于视频所在的URL      浏览器会发送一个GET请求，Header中包含Range: bytes=5303296-5336063，意思就是请求得到5303296-5336063之间的数据        Web服务器返回一个206的HTTP响应。Header中包含Content-Range: bytes 5303296-5336063/12129376，表明这次返回的内容范围  301与302(Moved Permanently，重定向)在得到301或302响应后，浏览器会再次请求位于Location中返回新的URL状态码301和302在语法上是一模一样的，都是在HTTP响应的Location中返回新的URL区别在于：      301表示旧地址已经被永久移除了，这个资源不可访问了，搜索引擎会把权重算到新地址    例如：防止用户输错域名或更换域名        302表示旧地址的资源还在，仍然可以访问，这个重定向只是临时地从旧地址跳转到新地址，搜索引擎会把权重算到新地址    例如：未登录状态下访问需要登陆才能访问的页面  304(Not Modified，未修改)状态码304表示上次的文档已经被缓存了，还可以继续使用400(Bad Request)状态码400表示客户端请求有语法错误，发送的HTTP请求中的数据有错误，例如表单有错误或者Cookie有错误，不能被度武器所理解401(Unauthorized)状态码401是指为授权错误。有些网页采用的是HTTP基本认证(Basic Authentication)，需要在HTTP请求Header中带上Authentication，否则服务器会返回状态码401404(Not Found)该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求但不想说明理由时使用例如BV1AB4y1D7Ft这个视频仅在登录并且收藏的情况下才可见，否则将返回404403(Forbidden)状态码403表示Web客户端发送的请求被Web服务器拒绝了。如果服务器想说明为什么拒绝请求，可以在Body中描述原因。但这个状态码通常表示服务器不想说明拒绝原因500(Internal Server Error)状态码500代表服务器内部错误。出现错误的原因有很多，比如代码的错误、数据库连接语句出错、程序内部抛出异常、空指针错误等503(Server Unavailable)状态码503表示服务器暂时不可用。由于服务器维护或者过载，服务器目前无法处理请求这个状况是临时的，并且将在一段时间以后恢复了解全部状态码访问：HTTP 状态码-菜鸟教程HTTP协议HeaderHeader的语法格式是“key: value”，一行一个。每一个Header都有特殊的作用Cache相关的HeaderHTTP请求与HTTP响应都有很多用于缓存的Header。HTTP缓存是指当Web请求抵达缓存时，如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中获取该文件CookieCookie是一种HTTP Cache，是HTTP中非常重要的内容。它由key=value的形式组成，比如ip_country=CN浏览器把Cookie通过HTTP请求中的“Cookie: header”发送给Web服务器，Web服务器通过HTTP响应中的“Set-Cookie: header”把Cookie发送给浏览器AcceptAccept表示浏览器客户端可以接受的媒体类型。例如Accept: text/html代表可以接受服务器返回html通配符*代表任意类型，例如Accept: text/html,*/*;q=0.8代表浏览器可以处理所有的类型。一般浏览器客户端给Web服务器发送的都是类似这个Accept-EncodingAccept-Encoding跟压缩有关，浏览器发送HTTP请求告诉Web服务器浏览器支持的压缩形式，例如Accept-Encoding: gzip, deflateAccept-LanguageAccept-Language作用是声明自己接受的语言。注意语言与字符集的区别，中文是语言，中文有多种字符集，例如GB2312、GBK等。例如Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2User-AgentUser-Agent的作用是浏览器用来告诉服务器，客户端使用的操作系统及版本、CPU类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等例如User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0代表64位Linux系统，Firefox是103.0版本如果想要模拟各种不同的客户端，只要修改User-Agent，就可以伪装成各种客户端RefererReferer主要用来让服务器判断来源页面，即用户是从哪个页面来的，网站通常用其统计用户来源，也可以用作放盗链等Connection从HTTP/1.1起，系统默认都开启了Connection: Keep-Alive，保持连接特性。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件(如Apache)中设定这个时间HostHost的作用是指定被请求的主机和端口号，如果是80端口号会被自动隐藏HTTP协议中的缓存缓存无处不在，有浏览器端的缓存、服务器端的缓存、代理服务器的缓存，还有ASP.NET页面的缓存、对象缓存、数据库缓存等等HTTP中具有缓存功能的是浏览器缓存和代理服务器缓存HTTP缓存是指当Web请求抵达缓存时，如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档缓存的优点：减少了冗余的数据传输，节省了传输时间；减少了服务器的负担，大大提高了网站的性能；加快了客户端加载网页的速度等如何判断缓存新鲜度Web服务器通过以下两种方式来判断浏览器缓存是否最新      浏览器把缓存文件的最后修改时间通过Header的If-Modified-Since告诉Web服务器。浏览器收到HTTP请求后，在Header中将文件最后修改世界Last-Modified与请求报文的If-Modified-Since相比较。若相同则说明文件是最新的，则发送状态吗304(Not Modified)给浏览器客户端；若不同则发送状态码200把最新文件发送给浏览器客户端        浏览器把缓存文件的ETag通过Header的If-None-Match告诉Web服务器  与缓存有关的Header  HTTP请求报文Header            名称      释义                  Cache-Control: max-age=0      以秒为单位              If-Modified-Since: Tue, 28 Jun 2022 00:50:56 GMT      缓存文件的最后修改时间              If-None-Match: “1771e0c387823da5329c20a76bece83c”      缓存文件的ETag值              Cache-Control: no-cache      不使用缓存              Pragma: no-cache      不使用缓存        HTTP响应报文Header            名称      释义                  Cache-Control: public      响应被缓存，并且可以被多用户访问使用              Cache-Control: private      响应只能作为私有缓存，特定用户使用              Cache-Control: no-cache      提醒浏览器要从服务器提取文档进行验证              Cache-Control: no-store      绝对禁止缓存(用于机密、敏感文件)              Cache-Control: max-age=60      60s后缓存过期(相对时间)              Date: Thu, 01 Sep 2022 21:56:36 GMT      当前响应发送的时间              Expires: Thu, 01 Sep 2022 21:57:37 GMT      缓存过期的时间(绝对时间)              Last-Modified: Tue, 28 Jun 2022 00:50:56 GMT      服务端文件的最后修改时间              Etag: “1771e0c387823da5329c20a76bece83c”      服务器文件的ETag值      注：浏览器总是优先使用cache-control，如果没有时才考虑ExpiresETagETag是Entity Tag(实体标签)的缩写，是根据实体内容生成的一段hash字符串(类似于MD5或者SHA1之后的结果)，可以表示文件的状态。当资源发生改变时，ETag也随之发生改变使用ETag主要是为了解决一些Last-Modified无法解决的问题，比如说某些服务器不能精确得到文件的最后修改时间、一些文件最后修改时间改变了但是内容不变、某些文件修改特别频繁甚至达到了以秒为单位以下等注：Last-Modified只能精确到秒浏览器不使用缓存使用Ctrl+Shift+R快捷键强制刷新浏览器，可以让浏览器不使用缓存，即浏览器的HTTP请求报文的Header中带有Cache-Control: no-cache，明确告诉Web服务器不使用缓存注：Pragma: no-cache与Cache-Control: no-cache作用相同，只是Pragma: no-cache是HTTP/1.0定义的，保留为了兼容性直接使用缓存，不经过服务器验证使用Ctrl+R快捷键刷新浏览器，浏览器会去Web服务器验证缓存如果在地址栏直接输入地址并访问，浏览器会“直接使用有效的缓存”，不会发送HTTP请求去服务器验证缓存，这种情况叫作缓存命中公有缓存与私有缓存公有缓存Cache-Control: public可以由多个用户共享访问，而私有缓存Cache-Control: private只能单个用户访问使用HTTP协议压缩和URL EncodeHTTP压缩是指Web服务器和浏览器之间压缩传输文本内容的方法。HTTP采用通用的压缩算法，比如用gzip来压缩HTML、JavaScript、CSS文件HTTP内容编码与压缩的区别在HTTP协议中，可以对Body部分进行编码，如可以采用gzip这样的编码，从而达到压缩的目地；也可以使用其他编码方式把内容搅乱或加密，以此来防止未被授权的第三方看到文档的内容。所以HTTP压缩其实就是HTTP内容编码的一种HTTP压缩的过程      浏览器发送HTTP请求Header中带Accept-Encoding: gzip,deflate告诉服务器浏览器支持gzip压缩        Web服务器接到HTTP请求后，先生成原始的HTTP响应，包含原始的Content-Type与Content-Length；然后通过gzip对HTTP响应的Body进行编码，并在编码后Header中的Content-Type与Content-Length替换为压缩后的大小，以及加上编码方式Content-Encoding: gzip；再把HTTP响应发送给浏览器        浏览器接到HTTP响应后，根据Content-Encoding: gzip来对HTTP响应进行解码，获取到原始HTTP响应后显示出网页  注：HTTP请求也是可以编码的，但是浏览器一般不会对HTTP请求编码内容编码类型HTTP定义了一些标准的内容编码类型，并允许用扩展的形式添加更多的编码在Header中的Content-Encoding就是使用这些标准化的代号来说明编码时使用的算法            编码      描述                  gzip      表明实体采用GNU zip编码              compress      表明实体采用UNIX的文件压缩程序              deflate      表明实体是用zlib的格式压缩的              identity      表明没有对实体进行编码。当Header中没有Content-Encoding时，默认为此情况      gzip、compress以及deflate编码都是无损压缩算法，用于减少传输报文的大小，不会导致信息缺失。其中gzip通常效率最高，使用最为广泛深入理解Cookie机制HTTP协议是无状态的，对于浏览器的每一次请求，服务器都会独立处理，不与之前或之后的请求发生关联。即使是同一个浏览器发送了3个请求，服务器也会独立处理这3个请求，服务器并不知道这3个请求是来自同一个浏览器会话机制与Cookie机制服务器需要识别浏览器请求，就必须弄清楚浏览器的请求状态。既然HTTP协议是无状态的，那就让服务器和浏览器共同维护一个状态，这就是会话机制      浏览器第一次请求服务器时，服务器创建一个会话，并将会话ID作为响应的一部分发送给浏览器        浏览器存储会话ID，并在后续请求中带上会话ID        服务器取得请求中的会话ID就知道是不是同一个用户了  这样后续请求与第一次请求就产生了关联，而Cookie机制就是一种会话机制服务器在内存中保存会话对象，浏览器可以使用Cookie机制保存会话IDCookie是什么Cookie是浏览器用来存储少量数据的一种机制，数据以key=value形式存储，多个Cookie之间以分号;分隔，浏览器发送HTTP请求时自动附带Cookie信息Cookie最主要的作用是用来做用户认证，还可以用于保存用户的一些其他信息。也可以用于互联网精准广告定向技术，例如用户浏览了某些商品，就可以用Cookie记录下来，然后进行大数据深度分析，实现广告精准投放鉴于此项，目前欧洲的一些国家已经对Cookie立法，并规定必须经过用户的允许才可以保存用户的CookieCookie的属性根据网站不同，Cookie有所不同  Expires表示Cookie失效的时间，如果不指定则在关闭浏览器或页面时被浏览器删除  Path表示Cookie所属的路径，asp.net默认为/也就是根目录假设在同一个服务器上的目录如下：/test/、/test/cd/、/test/dd，Cookie1的Path在/test/，Cookie2的在/test/cd/，那么/test/下的所有页面都可以访问到Cookie1，而/test/dd/的自页面不能访问Cookie2.因为Cookie只能让其Path路径下的页面访问  HttpOnly这是个关乎安全方面的属性，将一个Cookie设置为HttpOnly后，通过JavaScript脚本将无法读取到Cookie信息，这能有效防止用XSS发起攻击一般来说，跟登录相关的Cookie必须设置为HttpOnlyCookie的分类与位置            类别      描述                  会话Cookie      临时的Cookie，记录了用户访问站点时的设置与偏好(例如访问本站时的Cookie)，关闭浏览器后将被删除              持久Cookie      存储在硬盘上，有过期时间。不管退出浏览器还是重启计算机都存在      网站的自动登录就是储存持久Cookie，在用户再次访问相同网站时会先在硬盘中查找相关Cookie然后放到HTTP请求报文中发送给服务器那么持久Cookie存在计算机那里呢？不同浏览器会在各自的独立空间存放Cookie，互不干扰例如Linux下Firefox的Cookie位置：~/.mozilla/firefox/xxxxxxxx.default-release/cookies.sqliteHTTP基本认证HTTP协议是无状态的，浏览器和Web服务器之间可以通过Cookie来识别身份。那么一些桌面应用程序是如何跟Web服务器之间识别身份呢？一些网站和Web服务使用的是HTTP基本认证。有些桌面应用程序u也通过HTTP协议跟Web服务器交互，桌面应用程序一般不使用Cookie，而是把用户名+冒号+密码用Base64编码放在HTTP请求Header中的Authorization发送给服务端，这种方式叫HTTP基本认证(Basic Authentication)在基本认证中，Web服务器可以拒绝一个事物，要求客户端提供有效的用户名和密码，服务器会返回401状态码来初始化认证质询，并用WWW-Authenticate响应首部指定要访问的安全域。浏览器收到质询时，会打开一个对话框请求用户输入用户名和密码，然后将用户名和密码用Base64编码，再用Authorization请求首部发送给服务器一般家用路由器就是使用基本认证，RESTful API就经常使用基本认证，使用命令curl -u username:password URI即可完成基本认证HTTP基本认证的缺点      HTTP协议是无状态的，同一个客户端对服务器的每个请求都需要认证        Base64编码是可逆的，非常容易破解，所以基本认证相当于以明文的方式传输用户名和密码。所以基本认证一定要用HTTPS加密传输，稍微安全一点        使用基本认证登录后，除非关闭浏览器或清除历史记录，否则无法登出。而Cookie机制的话，网站可以提供登出方式以使Cookie失效        无法防止重放攻击  摘要认证摘要认证是针对基本认证存在的诸多问题而进行改良的方案。摘要认证是另一种HTTP认证协议，它试图修复基本认证的严重缺陷，进行如下改进      通过传递用户名、密码等计算出来的摘要来解决以明文方式在网络上发送密码的问题        通过服务器产生随机数nonce的方式防止恶意用户捕获并重放认证的握手过程        通过客户端产生随机数cnonce的方式支持客户端对服务器的认证        通过对内容也加入摘要计算的方式，可以有选择地防止对报文内容的篡改  参考文章《图解HTTP》读后总结及浅谈 - yexca‘BlogHTTP 状态码-菜鸟教程IE/Firefox/Chrome等浏览器保存Cookie的位置 - 脚本小娃子 - 博客园“登录“还是“登陆“？ - 知乎重放攻击 - 维基百科，自由的百科全书通俗易懂：到底什么是 REST API？表现层状态转换 - 维基百科，自由的百科全书"
  },
  
  {
    "title": "Fedora安装java8(Oracle JDK)",
    "url": "/archives/63",
    "categories": "软件配置",
    "tags": "Fedora, Java",
    "date": "2022-09-02 17:37:51 +0800",
    





    
    "snippet": "引言尽管 Fedora 系统自带 java 环境，不过是 OpenJDK 。有时候还是需要使用 Oracle 的下载            进入官网下载：[Java Downloads      Oracle](https://www.oracle.com/java/technologies/downloads/) (下载需要登陆)      找到 java8-Linux ，下载 x64 C...",
    "content": "引言尽管 Fedora 系统自带 java 环境，不过是 OpenJDK 。有时候还是需要使用 Oracle 的下载            进入官网下载：[Java Downloads      Oracle](https://www.oracle.com/java/technologies/downloads/) (下载需要登陆)      找到 java8-Linux ，下载 x64 Compressed Archive (64位的压缩包版本)本文章写时文件名为 jdk-8u341-linux-x64.tar.gz移到相应目录  首先创建一个 java的 目录，在 /usr/local 中sudo mkdir -p /usr/local/java  复制文件到此目录假设下载的文件在 ~/Downloads ，进入下载目录cd Downloads然后复制到上述目录sudo cp -r jdk-8u341-linux-x64.tar.gz /usr/local/java解压缩安装文件  切换到 java 目录cd /usr/local/java  解压缩安装文件sudo tar xvzf jdk-8u341-linux-x64.tar.gz配置$PATH  在 /etc/profile 末尾添加以下内容JAVA_HOME=/usr/local/java/jdk1.8.0_341PATH=$PATH:$HOME/bin:$JAVA_HOME/binexport JAVA_HOMEexport PATH更新可用 java 版本列表  直接运行以下命令sudo update-alternatives --install \"/usr/bin/java\" \"java\" \"/usr/local/java/jdk1.8.0_341/bin/java\" 1sudo update-alternatives --install \"/usr/bin/javac\" \"javac\" \"/usr/local/java/jdk1.8.0_341/bin/javac\" 1sudo update-alternatives --install \"/usr/bin/javaws.itweb\" \"javaws.itweb\" \"/usr/local/java/jdk1.8.0_341/bin/javaws.itweb\" 1生效配置文件  首先重新加载系统范围的 PATH 文件source /etc/profile  重启系统reboot切换 java 版本可以运行命令查看 java 版本java -version  使用以下指令切换sudo alternatives --config java当前使用的 java 版本前会有+，找到相应版本，输入数字选择即可参考文章如何在Fedora{OpenJDK 和 Oracle JDK}上安装Java？"
  },
  
  {
    "title": "Aria2+AriaNG配置使用",
    "url": "/archives/62",
    "categories": "软件配置",
    "tags": "Aria2",
    "date": "2022-09-01 23:06:38 +0800",
    





    
    "snippet": "Aria2是Linux下的一个下载工具,这里介绍Windows下的安装与配置,官方Aria2没有GUI界面所以配合AriaNG直接在Web界面进行操作.AriaNg 是一个让 aria2 更容易使用的现代 Web 前端. AriaNg 使用纯 html &amp; javascript 开发, 所以其不需要任何编译器或运行环境.下载Aria2+AriaNG最新安装包首先先在官网下载安装包  ...",
    "content": "Aria2是Linux下的一个下载工具,这里介绍Windows下的安装与配置,官方Aria2没有GUI界面所以配合AriaNG直接在Web界面进行操作.AriaNg 是一个让 aria2 更容易使用的现代 Web 前端. AriaNg 使用纯 html &amp; javascript 开发, 所以其不需要任何编译器或运行环境.下载Aria2+AriaNG最新安装包首先先在官网下载安装包  Aria2的Github地址– Aria2官方文档  AriaNG的Github地址– AriaNG官方文档Aria2选择对应的操作系统下载压缩包即可,AriaNG解压后放在Aria2文件夹即可AriaNg 现在提供三种版本, 标准版、单文件版和 AriaNg Native.  标准版适合在 Web 服务器中部署, 提供资源缓存和按需加载的功能.  单文件版适合本地使用, 您下载后只要在浏览器中打开唯一的 html 文件即可.  AriaNg Native 同样适合本地使用, 并且不需要使用浏览器.添加配置文件将文件解压至该目录下后，你需要再新创 4 个空文件(可以先建一个空 txt 文件然后修改后缀名)：  Aria2.log （日志文件）  aria2.session （用于记录下载历史，以便断点续传）  aria2.conf （配置文件）  HideRun.vbs （隐藏 cmd 窗口运行用到的）修改配置文件  打开刚才创建的 aria2.conf 空文件，将以下内容填入（用记事本打开即可）## '#'开头为注释内容, 选项都有相应的注释说明, 根据需要修改 #### 被注释的选项填写的是默认值, 建议在需要修改时再取消注释  #### 文件保存相关 ### 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置dir=E:\\Aria2Download# 日志文件的保存路径log=D:\\aria2-1.36.0-win-64bit-build1\\Aria2.log# 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M#disk-cache=32M# 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc# 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc# falloc和trunc则需要文件系统和内核支持# NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项#file-allocation=none# 断点续传continue=true## 下载连接相关 ### 最大同时下载任务数, 运行时可修改, 默认:5#max-concurrent-downloads=5# 同一服务器连接数, 添加时可指定, 默认:1max-connection-per-server=5# 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M# 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载min-split-size=10M# 单个任务最大线程数, 添加时可指定, 默认:5#split=5# 整体下载速度限制, 运行时可修改, 默认:0#max-overall-download-limit=0# 单个任务下载速度限制, 默认:0#max-download-limit=0# 整体上传速度限制, 运行时可修改, 默认:0#max-overall-upload-limit=0# 单个任务上传速度限制, 默认:0#max-upload-limit=0# 禁用IPv6, 默认:false#disable-ipv6=true# 连接超时时间, 默认:60#timeout=60# 最大重试次数, 设置为0表示不限制重试次数, 默认:5#max-tries=5# 设置重试等待的秒数, 默认:0#retry-wait=0## 进度保存相关 ### 从会话文件中读取下载任务input-file=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session# 在Aria2退出时保存`错误/未完成`的下载任务到会话文件save-session=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session# 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0#save-session-interval=60## RPC相关设置 ### 启用RPC, 默认:falseenable-rpc=true# 允许所有来源, 默认:falserpc-allow-origin-all=true# 允许非外部访问, 默认:falserpc-listen-all=true# 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同#event-poll=select# RPC监听端口, 端口被占用时可以修改, 默认:6800#rpc-listen-port=6800# 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项#rpc-secret=&lt;TOKEN&gt;# 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-user=&lt;USER&gt;# 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-passwd=&lt;PASSWD&gt;# 是否启用 RPC 服务的 SSL/TLS 加密,# 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接#rpc-secure=true# 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,# 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥#rpc-certificate=/path/to/certificate.pem# 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件#rpc-private-key=/path/to/certificate.key## BT/PT下载相关 ### 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true#follow-torrent=true# BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999listen-port=51413# 单个种子最大连接数, 默认:55#bt-max-peers=55# 打开DHT功能, PT需要禁用, 默认:trueenable-dht=false# 打开IPv6 DHT功能, PT需要禁用#enable-dht6=false# DHT网络监听端口, 默认:6881-6999#dht-listen-port=6881-6999# 本地节点查找, PT需要禁用, 默认:false#bt-enable-lpd=false# 种子交换, PT需要禁用, 默认:trueenable-peer-exchange=false# 每个种子限速, 对少种的PT很有用, 默认:50K#bt-request-peer-speed-limit=50K# 客户端伪装, PT需要peer-id-prefix=-TR2770-user-agent=Transmission/2.77# 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0seed-ratio=0.7# 强制保存会话, 即使任务已经完成, 默认:false# 较新的版本开启后会在任务完成后依然保留.aria2文件#force-save=false# BT校验相关, 默认:true#bt-hash-check-seed=true# 继续之前的BT任务时, 无需再次校验, 默认:falsebt-seed-unverified=true# 保存磁力链接元数据为种子文件(.torrent文件), 默认:falsebt-save-metadata=true注意:你需要将下面四行的内容修改为你自己的对应文件位置：# 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置dir=E:\\Aria2Download# 日志文件的保存路径log=D:\\aria2-1.36.0-win-64bit-build1\\Aria2.log# 从会话文件中读取下载任务input-file=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session# 在Aria2退出时保存`错误/未完成`的下载任务到会话文件save-session=D:\\aria2-1.36.0-win-64bit-build1\\aria2.session最后两行的内容是保存下载历史的，如果有时 Aria2 不能启动的话，清空里面的内容就可以了。  修改 HideRun.vbs 文件打开HideRun.vbs文件,向其中添加CreateObject(\"WScript.Shell\").Run \"aria2c.exe --conf-path=aria2.conf\",0接下来点击运行 HideRun.vbs 文件，（注意一定是 HideRun.vbs 文件而不是那个可执行文件！！），如果没有报错的话可以直接跳过下面这段：注意一下，这里也可以在文件前添加具体的文件目录前缀，但是前缀的文件目录中一定不要有空格例如:CreateObject(\"WScript.Shell\").Run \"C:\\Users\\he ne\\Downloads\\aria2c.exe --conf-path=aria2.conf\",0但是由于 he ne 这一文件夹里面包含空格，就导致了系统不识别，类似的常见错位位置还多见于：D:Program Files (x86)，这里也是存在空格的，解决方式就是将这一前缀去除即可（但需要该 vbs 文件位于该 aria2 文件夹下）  打开index.html打开里面的 index.html 文件，如果显示 “已连接”，则表明搭建成功  添加开机自启创建 HideRun.vbs 文件的快捷方式，放入 windows 的开机自启目录即可：在运行窗口中输入：shell:startup这里便会打开自启目录文件夹，然后将该快捷方式拖入即可参考文章:Aria2+AriaNG 配置指南（Win10 篇）AriaNG文档"
  },
  
  {
    "title": "Fiddler抓包HTTPS",
    "url": "/archives/61",
    "categories": "软件配置",
    "tags": "HTTP",
    "date": "2022-09-01 08:17:32 +0800",
    





    
    "snippet": "引言默认情况下Fiddler仅抓包HTTP，需要设置后才能捕获HTTPS。现在大部分网站都是使用HTTPS或者HSTS，所以开启HTTPS抓包是很必要的Fiddler设置在设置-HTTPS中勾选Capture HTTPS traffic即可，下一个Ignore server certificate errors(unsafe)也可勾选，不过可能不安全吧，然后保存浏览器设置在勾选抓取HTTPS...",
    "content": "引言默认情况下Fiddler仅抓包HTTP，需要设置后才能捕获HTTPS。现在大部分网站都是使用HTTPS或者HSTS，所以开启HTTPS抓包是很必要的Fiddler设置在设置-HTTPS中勾选Capture HTTPS traffic即可，下一个Ignore server certificate errors(unsafe)也可勾选，不过可能不安全吧，然后保存浏览器设置在勾选抓取HTTPS后使用浏览器可能会出现证书错误，即提示连接不安全或不是私密连接之类的，此时需要导入相关证书，以Firefox为例首先下载Fiddler证书，在上一部设置处有Export root cerificate to Desktop，点击即可将证书导出至桌面(~/Desktop/)处然后进入Firefox的设置，在隐私与安全-证书处查看证书，然后导入刚刚下载的证书，将弹窗的信任什么什么全勾选导入完成后就可以正常访问了，Fiddler也可以正常抓取HTTPS请求与响应了"
  },
  
  {
    "title": "Linux 下 bin 目录",
    "url": "/archives/60",
    "categories": "Linux",
    "tags": "",
    "date": "2022-08-31 00:27:09 +0800",
    





    
    "snippet": "引言事实上命令文件放在哪都可自行决定，也就是自己想放哪就放哪，这些目录不过是约定，不过遵守约定会更好啦，毕竟没有人会想要自己的电脑一团糟吧，尤其是Linux优先级Linux下的这些bin目录都是存放命令的，如果不同的目录下有相同名称的可执行程序，将通过优先级决定先运行哪个目录的二进制文件，可以通过使用命令echo $PATH查看环境变量以确定命令执行的优先级，比如我的系统输出如下：[yexc...",
    "content": "引言事实上命令文件放在哪都可自行决定，也就是自己想放哪就放哪，这些目录不过是约定，不过遵守约定会更好啦，毕竟没有人会想要自己的电脑一团糟吧，尤其是Linux优先级Linux下的这些bin目录都是存放命令的，如果不同的目录下有相同名称的可执行程序，将通过优先级决定先运行哪个目录的二进制文件，可以通过使用命令echo $PATH查看环境变量以确定命令执行的优先级，比如我的系统输出如下：[yexca@yexca-PC ~]$ echo $PATH/home/yexca/.local/bin:/home/yexca/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin从前到后以:分隔，越靠前优先级越高/bin系统的一些指令。bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等/usr/bin系统预装的可执行程序，会随着系统升级而改变后期安装的一些软件的运行脚本。主要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb、wget等/usr/local/bin给用户放置自己的可执行程序的地方，推荐放在这里，不会被系统升级而覆盖同名文件/sbin一般是指超级用户指令。主要放置一些系统管理的必备程式例如:cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等/usr/sbin放置一些用户安装的系统管理的必备程式例如:dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等参考文章Linux /usr/bin与/usr/local/bin区别_学亮编程手记的博客-CSDN博客/bin,/sbin,/usr/sbin,/usr/bin 目录之简单区别_IT农夫的博客-CSDN博客"
  },
  
  {
    "title": "Fedora安装后",
    "url": "/archives/59",
    "categories": "Linux",
    "tags": "Fedora",
    "date": "2022-08-24 12:13:30 +0800",
    





    
    "snippet": "引言个人安装Fedora后装的一些东西修改终端快捷键打开设置-键盘，在最下方查看及自定义快捷键自定义快捷键名称：Shell终端命令：gnome-terminal快捷键：自定更新系统sudo dnf update修改截图快捷键还是习惯Win的快捷键上述截图处交互式截图改为Win+Shift+SUser目录修改为英文中文目录及其不易使用终端操作先将语言改为英文export LANG=en_US然...",
    "content": "引言个人安装Fedora后装的一些东西修改终端快捷键打开设置-键盘，在最下方查看及自定义快捷键自定义快捷键名称：Shell终端命令：gnome-terminal快捷键：自定更新系统sudo dnf update修改截图快捷键还是习惯Win的快捷键上述截图处交互式截图改为Win+Shift+SUser目录修改为英文中文目录及其不易使用终端操作先将语言改为英文export LANG=en_US然后更新用户目录xdg-user-dirs-gtk-update这个时候，会提示是否要将用户目录下的文件夹改为英文，选择是然后再将系统语言刷到中文export LANG=zh_CN.UTF-8再执行更新用户目录命令xdg-user-dirs-gtk-update再次输入上面的命令会提示是否改为中文，选择否，并选择不再提醒即可VsCode配置环境sudo rpm --import https://packages.microsoft.com/keys/microsoft.ascsudo sh -c 'echo -e \"[code]\\nname=Visual Studio Code\\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\" &gt; /etc/yum.repos.d/vscode.repo'刷新缓存dnf check-update使用dnf安装sudo dnf install code或者使用yumyum check-updatesudo yum install codeEdge浏览器从Windows转来还不是特习惯火狐，再加上多端同步 （不过最安全的还是IE浏览器）            [下载 Microsoft Edge Web 浏览器      Microsoft](https://www.microsoft.com/zh-cn/edge)      下载.rpmMarkText全平台支持的Markdown编辑器GitHub - marktext/marktext: 📝A simple and elegant markdown editor, available for Linux, macOS and Windows.7-zip安装yum install -y p7zip p7zip-plugins压缩7z a after.7z before解压7z x after.7zFeedReaderRSS阅读器，我是在Fedora自带的软件搜索下载的Telegram记得放到/opt/Telegram下再执行Telegram Messenger网易云音乐安装配置flatpaksudo dnf install flatpakflatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo安装netease.CloudMusicflatpak install flathub com.netease.CloudMusic运行/点击图标运行flatpak run com.netease.CloudMusic卸载flatpak uninstall com.netease.CloudMusicNvidia驱动安装安装sudo dnf install akmod-nvidia可选sudo dnf install xorg-x11-drv-nvidia-cuda安装完成后重启reboot如果重启显示 Nvidia kernel module missing falling back to Nouveau      首先确保禁用BIOS中的secure boot        Check the version of akmods package installed by running rpm -qa akmods        Run sudo akmods --force &amp;&amp; sudo dracut --force to build the kernel modules    此处参考：Fedora 34 NVIDIA kernel module missing. Falling back to nouveau - #4，来自 vk2bea - Ask Fedora如果上述不行，请尝试使用下述方法      卸载与Nvidia相关的全部东西sudo dnf remove \\*nvidia\\*        安装驱动sudo dnf install akmod-nvidia    此处参考：Nvidia kernel module missing falling back to Nouveau (Fedora 36 PR) : Fedora桌面优化对于我的笔记本来说默认字体有亿点小sudo dnf install gnome-tweak-tool安装完成后在工具里会有优化这个软件QQ/Icalingua++这个QQ for Linux不会有人用吧，不会吧登陆和其他第三方一样报异常就离谱Icalingua++第三方：GitHub - Icalingua-plus-plus/Icalingua-plus-plus: A client for QQ and more.gnome拓展不知道干什么，但感觉会有用的样子安装主机连接器sudo dnf install chrome-gnome-shell gnome-extensions-app访问Latest extensions in GNOME Shell Extensions安装speedtest依次输入以下命令curl -s https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.rpm.sh | sudo bashsudo yum install speedtestFedora已安装git，gcc，gdb，python，OpenSDK javaLibreOffice参考文章修改 Fedora 下 user 目录为英文 – 腾讯云开发者社区-腾讯云CentOS Fedora 利用p7zip压缩、解压文件_hkNaruto的博客-CSDN博客Running Visual Studio Code on Linuxfedora-netease-fedora网易云音乐安装脚本。该脚本用于在Fedora上一键安装网易云音乐，测试于FedoraKDE30。Howto/NVIDIA - RPM Fusion安装Fedora 36后# 需要做的8件事桌面应用-如何使用 GNOME Shell 扩展Howto/Secure Boot - RPM FusionSPEEDTEST CLI: Internet connection measurement for developers"
  },
  
  {
    "title": "Github 拒绝访问Connection refused",
    "url": "/archives/58",
    "categories": "日常",
    "tags": "Github",
    "date": "2022-08-15 02:44:47 +0800",
    





    
    "snippet": "引言今日使用Git推送提示fatal: unable to access 'https://github.com/yexca-VRChat/yexca-VRChat.github.io.git/': Failed to connect to 127.0.0.1 port 1081 after 2074 ms: Connection refused，重启电脑也没用，遂寻找解决方法（为什么不让爷...",
    "content": "引言今日使用Git推送提示fatal: unable to access 'https://github.com/yexca-VRChat/yexca-VRChat.github.io.git/': Failed to connect to 127.0.0.1 port 1081 after 2074 ms: Connection refused，重启电脑也没用，遂寻找解决方法（为什么不让爷访问自己的仓库）解决过程经查阅相关资料得知与代理有关，可我代理是放路由器啊于是我连接到另一个普通路由器再次推送还是同样问题然后尝试了设置Git的代理也是无果git config --global --unset http.proxygit config --global --unset https.proxy最后想到我WinXray貌似好像大概开过吧，然后打开一看，果然开着pac，关闭后再次推送成功参考文章fatal: unable to access ‘https://github.com/fmoraless/e-commerce.git/’: Failed to connect to 127.0.0.1 port 56832: Connection refuse · Issue #11981 · desktop/desktop解决git下载出现：Failed to connect to 127.0.0.1 port 1080: Connection refused拒绝连接错误_点亮～黑夜的博客-CSDN博客git 报错:解决拒接接入问题_Huang_milk的博客-CSDN博客"
  },
  
  {
    "title": "搭建Git服务端及同步到指定目录",
    "url": "/archives/57",
    "categories": "技术工具",
    "tags": "Git",
    "date": "2022-08-13 10:28:50 +0800",
    





    
    "snippet": "引言使用Git可以更好的和朋友一起管理代码，也便于同步代码。由于我比较喜欢静态网站，因此使用Git同步网页文件很是实用安装Git登录ROOT账户，依次输入以下命令yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install git创建用户创建一个Git用户组和用户...",
    "content": "引言使用Git可以更好的和朋友一起管理代码，也便于同步代码。由于我比较喜欢静态网站，因此使用Git同步网页文件很是实用安装Git登录ROOT账户，依次输入以下命令yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install git创建用户创建一个Git用户组和用户，用于运行Git服务groupadd gituseradd git -g git公钥获取此部分为自己电脑的公钥，以Widows为例在%UserProfile%/.ssh/目录下id_rsa.pub文件存储如若没有此文件，打开cmd运行ssh-keygen命令会自动生成导入公钥将待导入的公钥导入/home/git/.ssh/authorized_keys文件里，一行一个。若没有该文件，则创建一个cd /home/git/mkdir .sshchmod 755 .sshtouch .ssh/authorized_keyschmod 644 .ssh/authorized_keys然后使用vi或vim命令将公钥导入，使用参考：vim文本编辑初始化Git仓库选定一个目录作为Git仓库，假设为/home/gitrepo/repo.gitcd /homemkdir gitrepochown git:git gitrepocd gitrepogit init --bare repo.git以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：chown -R git:git runoob.git克隆仓库git clone git@您的IP:仓库目录// 例如git clone git@127.0.0.1:/home/gitrepo/repo.git同步目录自动同步功能用到的是Git的钩子(hook)功能进入仓库目录/home/gitrepo/repo.gitcd /home/gitrepo/repo.gitcd hooks创建并编辑文件post-receivevi post-receive在该文件写入以下内容#!/bin/shgit --work-tree=同步到的目录 --git-dir=仓库位置 checkout -f例如#!/bin/shgit --work-tree=/home/www/hexo --git-dir=/home/gitrepo/repo.git checkout -f然后设置该文件读写权限chmod +x post-receive改变repo.git目录的拥有者为git用户chown -R git:git /home/gitrepo/repo.git更新代码如果你可以确定什么都没有改过只是更新本地代码，直接使用git pull正规流程// 查看本地分支文件信息，确保更新时不产生冲突git status// 若文件有修改，可以还原到最初状态; 若文件需要更新到服务器上，应该先merge到服务器，再更新到本地git checkout – [file name]// 查看当前分支情况git branch// 若分支为本地分支，则需切换到服务器的远程分支git checkout remote branchgit pull其他命令git branch // 看看分支git checkout aaa // 切换分支aaagit branck aaa // 创建aaa分支git chechout -b aaa // 本地创建 aaa分支，同时切换到aaa分支。只有提交的时候才会在服务端上创建一个分支禁用git用户的shell登录权限出于安全考虑，我们要让 git 用户不能通过 shell 登录。可以编辑/etc/passwd来实现vi /etc/passwd将git:x:1004:1004::/home/git:/bin/bash改为git:x:1004:1004::/home/git:/usr/bin/git-shell这样 git 用户可以通过 ssh 正常使用 git，但是无法登录 sehll参考文章Linux chown 命令-菜鸟教程Git 服务器搭建-菜鸟教程Git - 生成 SSH 公钥SSH key的介绍与在Git中的使用 - 简书Git - 在服务器上搭建 Gitgit 更新代码到本地_ftToday的博客-CSDN博客如何在服务器上搭建hexo博客-阿里云开发者社区Linux权限详解（chmod、600、644、700、711、755、777、4755、6755、7755）_林20的博客-CSDN博客详细解析Linux /etc/passwd文件 - Jtianlin - 博客园"
  },
  
  {
    "title": "博客视频外链引用",
    "url": "/archives/56",
    "categories": "网站建设",
    "tags": "Youtube",
    "date": "2022-08-12 00:11:17 +0800",
    





    
    "snippet": "现在主流流媒体网站都支持外链嵌入代码，但是B站(什么时候倒闭?)现在(2022/8/11)自带的外链引用默认为360P，且不能调节清晰度，非常的恶心，与Youtube相比高下立判，下面重点介绍一下B站的引用外链的参数和方法:Bilibili外链引用参数key具体视频演示Bilibili外链引用原版引用链接：&lt;pre class=\"language-html\" data-info=\"HT...",
    "content": "现在主流流媒体网站都支持外链嵌入代码，但是B站(什么时候倒闭?)现在(2022/8/11)自带的外链引用默认为360P，且不能调节清晰度，非常的恶心，与Youtube相比高下立判，下面重点介绍一下B站的引用外链的参数和方法:Bilibili外链引用参数key具体视频演示Bilibili外链引用原版引用链接：&lt;pre class=\"language-html\" data-info=\"HTML\" data-role=\"codeBlock\"&gt;&lt;span class=\"token tag\"&gt;&lt;span class=\"token tag\"&gt;&lt;span class=\"token punctuation\"&gt;&lt;&lt;/span&gt;iframe&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;src&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;//player.bilibili.com/player.html?aid=80433022&amp;bvid=BV1GJ411x7h7&amp;cid=137649199&amp;page=1&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;scrolling&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;no&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;border&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;0&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;frameborder&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;no&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;framespacing&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;0&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;allowfullscreen&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;true&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token tag\"&gt;&lt;span class=\"token tag\"&gt;&lt;span class=\"token punctuation\"&gt;&lt;/&lt;/span&gt;iframe&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;&gt;&lt;/span&gt;&lt;/span&gt;修改后引用链接：&lt;pre class=\"language-html\" data-info=\"HTML\" data-role=\"codeBlock\"&gt;&lt;span class=\"token tag\"&gt;&lt;span class=\"token tag\"&gt;&lt;span class=\"token punctuation\"&gt;&lt;&lt;/span&gt;iframe&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;src&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;//player.bilibili.com/player.html?aid=80433022&amp;bvid=BV1GJ411x7h7&amp;cid=137649199&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=1&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;scrolling&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;no&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;border&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;0&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;frameborder&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;no&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;framespacing&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;0&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;allowfullscreen&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;true&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token tag\"&gt;&lt;span class=\"token tag\"&gt;&lt;span class=\"token punctuation\"&gt;&lt;/&lt;/span&gt;iframe&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;&gt;&lt;/span&gt;&lt;/span&gt;哔哩哔哩外链key说明：            key      说明                  aid      之前 B 站使用的 AV 号              bvid      目前的 BV 号              page      第几个视频, 起始下标为 1 (默认值也是为 1)就是 B 站视频, 选集里的, 第几个视频              as_wide      是否宽屏 【1: 宽屏, 0: 小屏】              high_quality      是否高清 【1: 高清(最高1080p) / 0: 最低视频质量(默认)】              danmaku      是否开启弹幕 【1: 开启(默认), 0: 关闭】              vd_source=XXX&amp;t=XXX      可加精准空降地址      YouTube外链引用使用默认的YouTube外链即可,更高级功能可自己去官方教程学习&lt;pre class=\"language-html\" data-info=\"HTML\" data-role=\"codeBlock\"&gt;&lt;span class=\"token tag\"&gt;&lt;span class=\"token tag\"&gt;&lt;span class=\"token punctuation\"&gt;&lt;&lt;/span&gt;iframe&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;width&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;560&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;height&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;315&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;src&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;https://www.youtube.com/embed/OgcCOwj7wNY&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;title&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;YouTube video player&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;frameborder&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;0&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;allow&lt;/span&gt;&lt;span class=\"token attr-value\"&gt;&lt;span class=\"token punctuation attr-equals\"&gt;=&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&lt;span class=\"token punctuation\"&gt;\"&lt;/span&gt;&lt;/span&gt; &lt;span class=\"token attr-name\"&gt;allowfullscreen&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\"token tag\"&gt;&lt;span class=\"token tag\"&gt;&lt;span class=\"token punctuation\"&gt;&lt;/&lt;/span&gt;iframe&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;&gt;&lt;/span&gt;&lt;/span&gt;视频演示YoutubeBilibili(修改前) Bilibili(修改后) 参考资料: Sanarous博客和谷歌外链API教程"
  },
  
  {
    "title": "RSS",
    "url": "/archives/55",
    "categories": "日常",
    "tags": "",
    "date": "2022-08-09 16:08:14 +0800",
    





    
    "snippet": "引言最早接触RSS还是逛神社的时候，但当我知道有这么个东西的时候RSS就几乎凋零，不过还有类似于RSSHub之类的还在继续为之奋斗，不过RSSHub时常因网络问题无法连接，慢慢的放弃了。随着发现的博客越来越多，为了能够及时获取更新以及记录自己阅读过以及未阅读的文章，我再次使用RSSRSS简介RSS 的全称是 Really Simple Syndication（简易信息聚合），它是一种消息来源...",
    "content": "引言最早接触RSS还是逛神社的时候，但当我知道有这么个东西的时候RSS就几乎凋零，不过还有类似于RSSHub之类的还在继续为之奋斗，不过RSSHub时常因网络问题无法连接，慢慢的放弃了。随着发现的博客越来越多，为了能够及时获取更新以及记录自己阅读过以及未阅读的文章，我再次使用RSSRSS简介RSS 的全称是 Really Simple Syndication（简易信息聚合），它是一种消息来源的格式规范，网站可以按照这种格式规范提供文章的标题、摘要、全文等信息给订阅用户，用户可以通过订阅不同网站 RSS 链接的方式将不同的信息源进行聚合，在一个工具里阅读这些内容换句话说，与当前主流媒体推荐内容使我们被动获取信息不同，RSS是主动寻找知识的过程，需要我们主动发掘信息源，而且只会显示自己订阅信息源的内容为什么使用RSS拿起手机，打开信息类APP，首页就是推荐，再加上永远刷不到底部的设计和基于大数据的喜好推荐，很容易就将一天的时间陷入这些观点单一，毫无营养的内容。我不喜欢这种时间消逝的感觉，虽然学习之余需要放松刷刷，但我始终坚持放松应该要由自己掌控，不应被这种被动式接受，所以使用RSS也是我对信息茧房的一种抵抗吧往小了说，可能是为了标记自己未阅读的文章，获取自己关注的博客的文章，也为了不错过大佬的文章吧往大了说，在现如今推荐算法不断升级，不断精确的情况下，信息茧房愈加严重，慢慢得失去了主动获取信息的能力从而导致自己视野受限，甚至于失去学习能力如何使用首先需要RSS阅读器，我选择QuiteRSS，开源软件然后需要RSS订阅源，这个需要自行寻找啦，如果网站不提供可以到RSSHub寻找是否有发布相关订阅源(请保持网络环境正常)如何查找RSS订阅源：如何查找要与Feedzy RSS Feeds一起使用的RSS Feed URL比如说本站的RSS订阅源：https://yexca.xyz/index.php/feed/检测是否为订阅源：Feed Validator for Atom and RSS复制订阅源，打开软件，创建新消息源即可后记唉，本来想着描述的挺好的，但真正写的时候我发现我无法使用语言来表达自己所要抒发的情感，不是无法使用语言表达，只是可能我深受各种网络信息毒害，可能，，已经不会写文章了吧。。。写之前想了很多，但真到写的时候却完全不知道怎么表达，就这样吧！参考文章/推荐阅读求问神社的rss是啥啊高效获取信息，你需要这份 RSS 入门指南 - 腾讯云开发者社区RSS - 维基百科RSS凋零——主动获取信息到推送时代什麼是RSS？"
  },
  
  {
    "title": "记录Grey Hack第一个任务(获取密码)",
    "url": "/archives/54",
    "categories": "日常",
    "tags": "Game",
    "date": "2022-08-03 22:41:06 +0800",
    





    
    "snippet": "引言昨日游玩接取第一个任务的记录，由于是复述，部分细节可能与实际情况不同接取任务在通过某神秘人的考验后获得HackShop的网站，接到第一个任务任务内容为”The client wants the login credentials of the user Daronane. The remote ip of the victim is 54.44.37.52. It’s important...",
    "content": "引言昨日游玩接取第一个任务的记录，由于是复述，部分细节可能与实际情况不同接取任务在通过某神秘人的考验后获得HackShop的网站，接到第一个任务任务内容为”The client wants the login credentials of the user Daronane. The remote ip of the victim is 54.44.37.52. It’s important that you access the correct machine behind the public ip. The victim’s ip LAN is 172.16.6.7”任务分析任务要求为Daronane的登录凭证，受害者公网IP为54.44.37.52，局域网IP为172.16.6.7初步试探通过Grey Hack 单人模式游戏攻略（1）-MapleGe文章方法尝试首先使用whois命令获得管理员邮箱地址为Eggett@sabmi.net，向该邮箱发送Login issue邮件获取Daronane的密码为pierra尝试使用SSH连接54.44.37.52，输入命令ssh Daronane@pierra 54.44.37.52发现连接失败，错误信息为incorrect user/password我怀疑是我输入错误(毕竟手打的账号密码)，然后尝试了几次，甚至复制粘贴也是账号或密码错误便停止尝试我使用浏览器访问该IP，自然是没什么线索，只有一行文字Metlifegroup. Everything you need for your tech company与一个图片(貌似是树莓派)，猜测该网站可能是一个论坛，而受害者Daronane为该论坛用户？汉化游戏想到在访问HackShop时弹出的Exploits的教程中有部分我没看懂，于是寻找该游戏汉化，打开创意工坊，果然找到了该游戏汉化[简体中文](simplified Chinese)，订阅后重启游戏发现界面没汉化找到创意工坊下载地址，steam文件夹\\steamapps\\workshop\\content\\605230\\2825584160，通过阅读README.md文件得知需要将该文件夹下内容放至C:\\Users\\%UserName%\\AppData\\LocalLow\\Loading Home\\Grey Hack\\文件夹下事实上只需要将custom_lang.json放入上述文件夹即可重新进入游戏，在左侧的language选择Chinese即可汉化阅读手册阅读汉化后手册的Exploits部分（发现和没汉化差不多），还是不大理解这个东西是干什么的继续探寻继续搜寻相关攻略，可一无所获，直到看到文章Grey Hack: 一个比较简单的任务 - 哔哩哔哩文章中脚本小子一词使我了解到这个Exploits相当于现实中的攻击脚本错误探索到HackShop下载工具scanlib与scanrouter尝试命令scanlib 54.44.37.52，提示Missing metaxploit，看不懂使用命令nmap 54.44.37.52，得知该服务器开放俩端口，分别为22和80，分别提供SSH与HTTP服务使用命令scanrouter得知该服务器有Kernel_router.so:V1.0.0，然后寻找相关脚本，找到一脚本描述为Get access to a shell，没有要求我将该脚本下载到/home/yexca/hacktool，然后在终端进入该文件夹并输入命令KernelRouterAccess 54.44.37.52，错误提示Can't find metaxploit library in the /lib path or the current folder注：开始时没重命名，后来重命名为KernelRouterAccess，以该名称为例写此文章，该文章其他脚本均为后续重命名，与商店中原名称不同从错误来看是缺失文件，看到/lib莫非是对方服务器没有相应文件不能识别所以不能进入吗？再次思索考虑到通过nmap命令得知这个服务器开放22和80端口，又上述猜测受害者为该论坛用户，于是到HackShop寻找http脚本，找到一个脚本描述为Grant access to the file /etc/passwd and decipher its contents，要求为Minimum number of 1 users registered in the computer，也就是至少一名用户，该网站为论坛，估计应该不会直接使用root账号进行开发吧，而且估计是多用户开发下载脚本后输入命令HttpPasswd 54.44.37.52 80，和使用上一个脚本一样提示Can't find metaxploit library in the /lib path or the current folder我并没有惊讶，因为通过scanrouter命令扫描只有Kernel_router.so:V1.0.0，没有libhttp.so之类的事实上我选择HTTP脚本，也是由于上述文章提到其实只要完成任务就行，不需要远程连接，你在本地执行脚本也不会留下痕迹然后我想着那继续尝试SSH吧，便进入HackShop寻找相应脚本找到一个脚本描述为Take advantage of a vulnerability in the ssh service to inject a new password to a registered user，要求为Any user logged in the computer，也就是有用户登陆过，考虑到开发该网站一定需要登录，所以该要求应该可以达到下载脚本后输入命令SSHPasswd 54.44.37.52 22，还是提示Can't find metaxploit library in the /lib path or the current folder这**怎么玩？？？贵服务器的/lib是啥都没有？难道我要每个种类的脚本都试一遍来确定/lib有什么吗？？？？那我岂不是得破产啊进入正轨于是我借助搜索引擎寻找攻略，发现没有再次回想之前看到错误条件Can't find metaxploit library in the /lib path or the current folder，我只看到了前面的/lib以及看不懂的metaxploit，仔细查看后面有一个or the current folder，这个当前文件夹是指什么呢？难道是我电脑上该脚本所处的文件夹，那我为了进攻岂不是要把相应的镜像像libssh.so之类的都下载一遍？打开黑市，并没有像libssh.so之类的镜像，联想到该游戏有命令apt-get，在现实Linux中可以下载相关程序，于是游戏中输入命令apt-get search ssh，果不其然有一个libssh.so，使用命令apt-get install libssh.so安装SSH安装完成后输入命令SSHPasswd 54.44.37.52 22，结果还是提示Can't find metaxploit library in the /lib path or the current folder我真是服了！！！再次打开HackShop，我把Tools下的每个商品都看了一遍，其中metaxploit.so引起我的注意，这不就是报错信息中的那个metaxploit嘛！再结合错误信息中的current folder，是不是报错因为缺少这玩意啊下载至脚本所在文件夹(/home/yexca/hacktool)，考虑到scanrouter命令只扫到Kernel_router.so，尝试运行KernelRouterAccess 54.44.37.52，果然，获得了进入权限！获取权限获得进入权限后想着先去删日志，输入命令FileExplorer.exe，访问/var/system.log，提示Permission denied，权限不足，然后发现这脚本获得的是访客权限，那我找密码文件吧，访问/etc/passwd，还是提示Permission denied(事实上我几乎把该计算机的文件都看了一遍)啊这，那我买这脚本有屁用啊！因为SSH脚本是更改密码，风险较高，所以我使用HTTP脚本获取密码。输入命令HttpPasswd 54.44.37.52 80，结果提示can't read /etc/passwd. Permission denied，看到获取的权限是guest，我**最后还是使用SSH脚本，输入命令SSHPasswd 54.44.37.52 22，输入新密码114514，成功修改了Farraze的密码输入命令ssh Farraze@114514 54.44.37.52，成功进入受害者机器，输入命令cat /etc/passwd，成功获取root的密码加密后信息再本地新建一个文件(touch mima.txt)，将root密码信息拷如，然后解密decipher mima.txt，成功获得root的密码为44444(这密码可还行)输入命令exit断开连接，接着输入ssh root@44444 54.44.37.52，成功以root权限登入进入机器进入后第一件事删除日志，然后该机器的用户有Ralancl和Farraze，没有受害者Daronane，果然是论坛用户吗，可我将这台机子翻了一遍也没找到相关东西(顺便把这俩的钱转我账户上啦~)回想任务内容，提到了IP172.16.6.7输入命令ping 172.16.6.7，显示Ping successful，使用自己的电脑无法Ping通(废话了属于是，内网的机子怎么Ping通)输入命令nmap 172.16.6.7查看开放端口，提示command not found，命令未找到啊这，那我只好将我计算机的命令文件放到该计算机的/bin目录下了复制过去后再次输入命令nmap 172.16.6.7，可以看到开放了3306端口，服务为employees，这是啥玩意？通过搜索引擎得知3306端口一般为数据库端口，也就是说需要使用sql的脚本获得密码进入HackShop，搜索相关脚本，找到一个脚本描述为Take advantage of a vulnerability in the sql service to inject a new password to a registered user，要求为Any user logged in the computer，也就是有用户登陆过，数据库的创建必然要有用户登录过啊下载后输入命令SqlChangePasswd 172.16.6.7 3306，提示Connection refused. Address unreachable，访问拒绝，确实，数据库肯定是白名单的啦将脚本与metaxploit.so放到受害者机器/root目录下，再次输入命令，修改密码为114514，修改用户为Osquel那么现在问题来了，我修改密码然后呢？这服务器只开放了3306端口，我也进不去啊 XD好吧，再次进入HackShop，搜索相关脚本，找到一个脚本描述为Prints the contents of the file /etc/passwd，要求为Any user logged in the computer，也就是有用户登陆过，和刚刚脚本要求一样将脚本放到受害者机器/root目录下，输入命令SqlPrintPasswd 172.16.6.7 3306，得到该机子所以用户的密码，其中有受害者Daronane的复制到自己的电脑并解密后得到密码为：pierra？？？我将此密码发送给客户，得到了肯定的答复？？？我**精彩！ (来自于YouTuber黑镖客的梗)后记一开始就通过邮件获得了密码，然后我一阵折腾再次获得了密码（属实是给我整无语了）收入为200，但我买脚本花费远大于200（总体还是挺亏的），不过脚本可以重复使用，而且探索的过程也是很有趣哒！这游戏的攻略可以说几乎没有啊，如果您是寻找相关攻略，希望该文章可以有所帮助"
  },
  
  {
    "title": "使用Git上传文件至Github",
    "url": "/archives/53",
    "categories": "技术工具",
    "tags": "Git, Github",
    "date": "2022-08-03 12:49:27 +0800",
    





    
    "snippet": "最近经常要使用Github保存我学习过程中的代码，发现无法直接上传文件夹，遂在网上查了一下使用Git上传，所以写个博文记录一下Github端操作1. 复制仓库地址本地端操作1. 在本地新建一个空文件夹我这里已经clone完成2. 在文件夹内呼出Git Bash框3. Clone远程仓库&lt;pre class=\"language-bash\" data-info=\"bash\" data-ro...",
    "content": "最近经常要使用Github保存我学习过程中的代码，发现无法直接上传文件夹，遂在网上查了一下使用Git上传，所以写个博文记录一下Github端操作1. 复制仓库地址本地端操作1. 在本地新建一个空文件夹我这里已经clone完成2. 在文件夹内呼出Git Bash框3. Clone远程仓库&lt;pre class=\"language-bash\" data-info=\"bash\" data-role=\"codeBlock\"&gt;&lt;span class=\"token function\"&gt;git&lt;/span&gt; clone + 你的仓库地址&lt;span class=\"token function\"&gt;git&lt;/span&gt; clone https://github.com/hiyoung3937/study_code.git  //示例4. 直接将需要上传的文件拖入即可5. 上传&lt;pre class=\"language-bash\" data-info=\"bash\" data-role=\"codeBlock\"&gt;&lt;span class=\"token builtin class-name\"&gt;cd&lt;/span&gt;  study_code.git   //根据自己的远程仓库名输入&lt;span class=\"token function\"&gt;git&lt;/span&gt; init&lt;span class=\"token function\"&gt;git&lt;/span&gt; &lt;span class=\"token function\"&gt;add&lt;/span&gt; &lt;span class=\"token builtin class-name\"&gt;.&lt;/span&gt;&lt;span class=\"token function\"&gt;git&lt;/span&gt; commit -m “你的提交信息”&lt;span class=\"token function\"&gt;git&lt;/span&gt; push命令说明            clone + 仓库地址      克隆你的仓库至本地                  cd + 你的远程仓库名      进入到远程仓库内(根据自己的仓库名输入)              git init      初始化Git              git add .      将工作区的文件添加到暂存区（”.”是当前目录下的所有文件，也可只输入文件夹名称）              git commit -m “你的提交信息”      将暂存区的文件添加到本地仓库              git push      提交到远程仓库（可能需要你输入帐号和密码）      "
  },
  
  {
    "title": "命令行下载YouTube视频",
    "url": "/archives/52",
    "categories": "软件配置",
    "tags": "Youtube",
    "date": "2022-07-25 12:52:27 +0800",
    





    
    "snippet": "引言哪个男孩不想使用命令行运行一些东西装逼呢。之前有所了解youtube-dl，但看着过于复杂没去使用，今日尝试使用发现甚是好用啊！环境安装Python3.7+直接到Python官网下载安装即可，安装时勾选Add Python x.x to PATH安装yt-dlpyt-dlp基于youtube-dl修改，实测下载速度较快下载进入releases下载yt-dlp.exe配置将下载的文件放入一...",
    "content": "引言哪个男孩不想使用命令行运行一些东西装逼呢。之前有所了解youtube-dl，但看着过于复杂没去使用，今日尝试使用发现甚是好用啊！环境安装Python3.7+直接到Python官网下载安装即可，安装时勾选Add Python x.x to PATH安装yt-dlpyt-dlp基于youtube-dl修改，实测下载速度较快下载进入releases下载yt-dlp.exe配置将下载的文件放入一固定位置，打开我的电脑的属性，进入高级系统设置-环境变量-系统变量，选中Path，点击编辑，新窗口点击新建，将yt-dlp.exe文件所在路径输入然后连点三个确定将所有窗口关闭测试按下Win+R输入cmd，回车在cmd中输入yt-dlp，若出现Usage: yt-dlp [OPTIONS] URL [URL...]则代表配置成功更新cmd中输入yt-dlp -U即可下载视频直接在cmd中输入yt-dlp+空格+YouTube视频链接即可开始下载默认下载是720P，保存位置在C:/Users/%UserName%/修改下载保存位置在C:\\Users\\%UserName%\\AppData\\Roaming新建一个文件夹并命名为yt-dlp，然后进入新建的文件夹内，新建文件config.txt在文件内输入以下代码-o 'C:/Users/%UserName%/Downloads/Video/%(title)s.%(ext)s'其中C:/Users/%UserName%/Downloads/Video/为下载目录，%(title)s.%(ext)s为保存文件名形式，此处为视频标题.视频拓展名下载1080P因为1080P及以上视频是音视频分离的，所以需要先下载ffmpegffmpeg进入官网，左下角选择系统类型，然后选择下载我选择的是Releases · BtbN/FFmpeg-Builds，下载ffmpeg-n5.0-latest-win64-gpl-5.0.zip然后放到一个固定文件夹并将bin文件目录放到系统变量里测试打开cmd，输入ffmpeg -version，若出现版本号则配置成功查询命令输入yt-dlp -D [URL]即可查看当前视频的全部形式(仅查询，不下载)下载命令输入yt-dlp -f [ID] [URL]以下载指定形式视频，可以使用[ID]+[ID]组合以下载视频和音频，即yt-dlp -f [ID]+[ID] [URL]，下载完成后会自动合并注：下载最高画质与音频：-f \"bv+ba/b\"调用aria2在下载命令后加入--external-downloader aria2c --external-downloader-args \"-x 16  -k 1M\"即可下载字幕outube-dl --write-sub [url]\t//这样会下载一个vtt格式的英文字幕和mkv格式的1080p视频下来youtube-dl --write-sub --skip-download [url] //下载单独的vtt字幕文件,而不会下载视频youtube-dl --write-sub --all-subs [url] //下载所有语言的字幕(如果有的话)youtube-dl --write-auto-sub [url] //下载自动生成的字幕(YouTube only)下载视频列表youtube-dl -f [format code] [palylist_url] //这种方式可以下载制定清晰度的mp4视频youtube-dl [playlist_url] //下载视频列表,这种方式下载的视频可能是mkv格式或者webm格式youtube-dl -cit [playlist_url] //下载视频列表,这种方式下载的视频可能是mkv格式或者webm格式youtube-dl --yes-playlist [url] //当链接为视频列表,则下载该列表视频,跟上面的一样,可能是mkv或者webm格式可视化Releases · jely2002/youtube-dl-gui参考文章yt-dlp的Github页面【备份】youtube-dl使用介绍 - 简书 一文搞懂Windows系统【目录变量】的相关知识_黑就黑到底的博客-CSDN博客_username变量"
  },
  
  {
    "title": "VS Code更换字体",
    "url": "/archives/51",
    "categories": "软件配置",
    "tags": "VS Code",
    "date": "2022-07-13 17:47:57 +0800",
    





    
    "snippet": "引言近日网上冲浪时发现一觉得还不错的字体，便寻找更换字体方法。但实际使用下来没那么惊艳方式一左下管理-设置(或者快捷键CTRL+,)进入设置界面，找到Editor:Font Family将默认的 Consolas, 'Courier New', monospace 改为要更换的字体即可方式二Ctrl + Shift + P -&gt; 输入 settings.json -&gt; 选择 Pr...",
    "content": "引言近日网上冲浪时发现一觉得还不错的字体，便寻找更换字体方法。但实际使用下来没那么惊艳方式一左下管理-设置(或者快捷键CTRL+,)进入设置界面，找到Editor:Font Family将默认的 Consolas, 'Courier New', monospace 改为要更换的字体即可方式二Ctrl + Shift + P -&gt; 输入 settings.json -&gt; 选择 Preferences:Open Settings(JSON) 打开 settings.json 文件，然后将 \"editor.fontFamily\": \"要更改的字体\"加入到 {} 中保存即可中英文字体分开我们可以看到 VS Code 的默认字体有三个，以 , 分隔：Consolas, 'Courier New', monospace，要对中英文设置不同的字体，只需要将第一个和第二个分别设置一个英文字体和一个中文字体（英文字体, 中文字体）即可，例如SF NS Mono, '楷体'"
  },
  
  {
    "title": "Windows网络地址(FTP地址)取消快速访问",
    "url": "/archives/50",
    "categories": "日常",
    "tags": "Windows",
    "date": "2022-06-27 13:31:58 +0800",
    





    
    "snippet": "好像并没有解决方法，不过可以把快速访问中自己添加的全删除(恢复默认)定位至“C:\\Users\\用户名\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\AutomaticDestinations”，将此文件夹目录下的文件进行备份后全部删除参考文章ftp地址不能从快速访问中删除,其他的文件夹可以 – Microsoft Community",
    "content": "好像并没有解决方法，不过可以把快速访问中自己添加的全删除(恢复默认)定位至“C:\\Users\\用户名\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\AutomaticDestinations”，将此文件夹目录下的文件进行备份后全部删除参考文章ftp地址不能从快速访问中删除,其他的文件夹可以 – Microsoft Community"
  },
  
  {
    "title": "OpenWRT中继WIFI",
    "url": "/archives/49",
    "categories": "日常",
    "tags": "OpenWRT",
    "date": "2022-06-23 14:50:21 +0800",
    





    
    "snippet": "引言今日尝试了一下之前试过的无线中继，发现已经不会了，果然做一项东西还是要写个文章记录一下比较好啊本文中，将OpenWRT路由器连接的WIFI称为上级路由，OpenWRT路由器称为路由器前提确保路由器与上层路由的LAN口地址(即进入路由器后台的地址)不可与上级路由一致，如一致将无法上网修改路由器LAN口地址进入路由器后台的网络-接口，点击LAN的修改，改变其IPv4地址即可例如上级路由后台地...",
    "content": "引言今日尝试了一下之前试过的无线中继，发现已经不会了，果然做一项东西还是要写个文章记录一下比较好啊本文中，将OpenWRT路由器连接的WIFI称为上级路由，OpenWRT路由器称为路由器前提确保路由器与上层路由的LAN口地址(即进入路由器后台的地址)不可与上级路由一致，如一致将无法上网修改路由器LAN口地址进入路由器后台的网络-接口，点击LAN的修改，改变其IPv4地址即可例如上级路由后台地址为192.168.1.1，路由器可改为192.168.5.1修改完并保存&amp;应用后在浏览器输入修改后的地址访问路由器后台路由器连接WIFI进入网络-无线，点击扫描，找到要连接的WIFI，点击加入网络，输入网络名称与密码，点击提交，然后点击保存&amp;应用即可路由器开WIFI如果路由器有2.4G和5G双频段，可以选择与上一步不同频段创建WIFI，这样兼容性最好 （如果另一个频段已经有一个WIFI，可能已经能用啦）如果只有单频段，则在相同频段新建一个，必须要新建，可能不会成功，毕竟有些路由器不支持单网卡同时入和出开WIFI和普通流程一样，在网络-无线处添加，输入SSID(即WIFI名称)和密码然后保存&amp;应用即可参考文章OpenWrt进阶教程之无线中继配置指南 - 爱一枝梅"
  },
  
  {
    "title": "使用PS自动化脚本批量处理图片",
    "url": "/archives/48",
    "categories": "日常",
    "tags": "PhotoShop",
    "date": "2022-06-10 00:54:44 +0800",
    





    
    "snippet": "使用PS自动化脚本批量处理图片  点击菜单栏的 窗口-&gt;动作（快捷键alt+F9)  再选项卡底部点击新建文件夹（新建组），取名为修改图片大小（可以自己重命名）  再点击旁边的创建新动作，我们可以看到底部原点变为红色   点击文件、打开，打开我们要处理的其中一张图片，修改图片大小，再点击确定，然后另存为，取个名字，存储。（不要使用导出，否则无法录入动作导致陷入死循环）  点击文件、自动...",
    "content": "使用PS自动化脚本批量处理图片  点击菜单栏的 窗口-&gt;动作（快捷键alt+F9)  再选项卡底部点击新建文件夹（新建组），取名为修改图片大小（可以自己重命名）  再点击旁边的创建新动作，我们可以看到底部原点变为红色   点击文件、打开，打开我们要处理的其中一张图片，修改图片大小，再点击确定，然后另存为，取个名字，存储。（不要使用导出，否则无法录入动作导致陷入死循环）  点击文件、自动、批处理  设置          播放处选择组和动作      源 选择需要修改的图片文件地址      目标 选择修改后的图片保存地址      勾选 “覆盖动作中的’打开’命令” 和 “覆盖动作中的‘存储为’命令”       内容部分参考自互联网"
  },
  
  {
    "title": "原神自动签到(Linux服务器Docker)",
    "url": "/archives/47",
    "categories": "日常",
    "tags": "Docker, miHoYo",
    "date": "2022-06-09 13:33:42 +0800",
    





    
    "snippet": "引言由于腾讯云函数从六月开始收费，于是便弃用改在自己的服务器上搭建既然六月收费为什么现在才写文章呢？因为可能还有三个月的免费试用我米游社的Cookie过期更换，故记录工具&amp;原教程原神签到小助手 每日福利不用愁 - 银弹博客 (yindan.me)由于原文介绍了多种使用方法，自己的阅读体验不是太好，故写此文腾讯云函数处理请将腾讯云函数冻结已确保不会收取费用当然，如果没什么其他需求可直接...",
    "content": "引言由于腾讯云函数从六月开始收费，于是便弃用改在自己的服务器上搭建既然六月收费为什么现在才写文章呢？因为可能还有三个月的免费试用我米游社的Cookie过期更换，故记录工具&amp;原教程原神签到小助手 每日福利不用愁 - 银弹博客 (yindan.me)由于原文介绍了多种使用方法，自己的阅读体验不是太好，故写此文腾讯云函数处理请将腾讯云函数冻结已确保不会收取费用当然，如果没什么其他需求可直接注销账号，但注销账号需要手持身份证照片，请注意前提服务器可以连接上米忽悠的服务器https://mihoyo.com可在SSH命令行窗口输入ping mihoyo.com测试是否可以连接我的一个服务器就连接不上，只好换一个，唉Docker安装可以直接使用一键脚本进行安装，实测Debian10和CentOS7正常安装(请使用root账户)安装命令如下：curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun也可以使用国内 daocloud 一键安装命令：curl -sSL https://get.daocloud.io/docker | sh脚本安装使用以下命令即可docker pull yindan/genshinhelperCentOS错误我使用CentOS安装时出现错误Can't Connect to Docker Daemon请确保使用root账户，然后输入以下命令systemctl start docker简易使用Cookie获取获取米游社Cookie请参考：原神树脂查看/推送 – yexca’Blog注意：Cookie 应包含account_id和cookie_token两个字段多账号在不同Cookie中间加#即可，例如Cookie1#Cookie2#Cookie3简易配置docker run -d --name=genshinhelper \\-e COOKIE_MIHOYOBBS=\"&lt;COOKIE_MIHOYOBBS&gt;\" \\--restart always \\yindan/genshinhelper:latest将自己的Cookie替换上述命令的&lt;COOKIE_MIHOYOBBS&gt;即可重新配置/更新Cookie重新配置好像需要卸载再重装，然后再进行配置或者使用配置文件只需替换Cookie就可以了吧(没用过，Cookie有效期很长的)常用命令# 查看Docker所有的容器docker ps -a# 查看日志docker logs -f genshinhelper --tail 100# 重启docker restart genshinhelper# 更新docker pull yindan/genshinhelperdocker rm -f genshinhelper# 之后依据基本使用或高级使用重新部署# 卸载docker rm -f genshinhelperdocker image rm genshinhelper配置文件示例配置文件      Github: config.json    Telegram: https://t.me/genshinhelperupdates/5  可下载示例文件修改安装假设配置文件位于服务器的 /etc/genshin/config.json，使用以下命令已映射配置docker run -d --name=genshinhelper \\-v /etc/genshin:/app/genshincheckinhelper/config \\--restart always \\yindan/genshinhelper:latest配置配置文件可以只留下需要的参数，把非必须的参数删除，例如只需要Cookie则配置文件除了保持完整也可以写成：{  \"COOKIE_MIHOYOBBS\": \"&lt;COOKIE_MIHOYOBBS&gt;\",}配置文件新增RANDOM_SLEEP_SECS_RANGE：随机延迟休眠秒数范围，单位：秒。设置成”0-0”为取消延迟。CHECK_IN_TIME：每日签到时间。该时间和运行环境的时间有关，和时区无关。如果是docker，可以用TZ=Asia/Shanghai设置时区。CHECK_RESIN_SECS：原神原粹树脂检测间隔时间，单位：秒。COOKIE_RESIN_TIMER：需要开启原粹树脂检测账号的cookie。SHOPTOKEN：微信积分商城的token，通过抓包获取。ONEPUSH：推送配置。notifier为推送名字，params为所需参数。详见后文。OnePush推送参数一览推送名称 / notifier: bark参数大全 / params:{‘required’: [‘key’], ‘optional’: [‘title’, ‘content’, ‘sound’, ‘isarchive’, ‘icon’, ‘group’, ‘url’, ‘copy’, ‘autocopy’]}推送名称 / notifier: custom参数大全 / params:{‘required’: [‘url’], ‘optional’: [‘method’, ‘datatype’, ‘data’]}推送名称 / notifier: dingtalk参数大全 / params:{‘required’: [‘token’], ‘optional’: [‘title’, ‘content’, ‘secret’, ‘markdown’]}推送名称 / notifier: discord参数大全 / params:{‘required’: [‘webhook’], ‘optional’: [‘title’, ‘content’, ‘username’, ‘avatar_url’, ‘color’]}推送名称 / notifier: pushplus参数大全 / params:{‘required’: [‘token’, ‘content’], ‘optional’: [‘title’, ‘topic’, ‘markdown’]}推送名称 / notifier: qmsg参数大全 / params:{‘required’: [‘key’], ‘optional’: [‘title’, ‘content’, ‘mode’, ‘qq’]}推送名称 / notifier: serverchan参数大全 / params:{‘required’: [‘sckey’, ‘title’], ‘optional’: [‘content’]}推送名称 / notifier: serverchanturbo参数大全 / params:{‘required’: [‘sctkey’, ‘title’], ‘optional’: [‘content’, ‘channel’, ‘openid’]}推送名称 / notifier: telegram参数大全 / params:{‘required’: [‘token’, ‘userid’], ‘optional’: [‘title’, ‘content’, ‘api_url’]}推送名称 / notifier: wechatworkapp参数大全 / params:{‘required’: [‘corpid’, ‘corpsecret’, ‘agentid’], ‘optional’: [‘title’, ‘content’, ‘touser’, ‘markdown’]}推送名称 / notifier: wechatworkbot参数大全 / params:{‘required’: [‘key’], ‘optional’: [‘title’, ‘content’, ‘markdown’]}例子telegramONEPUSH={“notifier”:”telegram”,”params”:{“markdown”:false,”token”:”xxxx”,”userid”:”xxx”}}discordONEPUSH={“notifier”:”discord”,”params”:{“markdown”:true,”webhook”:”https://discord.com/api/webhooks/xxxxxx”}}docker 配置文件映射目录为：/etc/genshin:/app/genshincheckinhelper/config所有变量Variable NameRequiredDefaultDescriptionLANGUAGE❌en项目语言。目前支持中文(zh)和英文(en)。MAX_SLEEP_SECS❌300最大休眠秒数。自v1.5.0添加了运行前随机延迟，设置此参数可自定义延迟，秒数应该＞10RUN_ENV❌prod运行环境。设置为任意非默认值即可跳过随机延迟。COOKIE_MIHOYOBBS❌ Cookie from miHoYo bbs. https://bbs.mihoyo.com/ys/COOKIE_BH3❌ 和 COOKIE_MIHOYOBBS 一样COOKIE_MIYOUBI❌ Cookie from miHoYo bbs. https://bbs.mihoyo.com/ys/COOKIE_HOYOLAB❌ Cookie from HoYoLAB community. https://webstatic-sea.mihoyo.com/ys/event/signin-sea/index.html?act_id=e202102251931481&amp;lang=en-usCOOKIE_WEIBO❌ Parameters from Sina Weibo intl. app.   aid=xxx; gsid=xxx; s=xxx; from=xxxCOOKIE_KA❌ Cookie from https://m.weibo.cnBARK_KEY❌ iOS Bark app's IP or device code. For example: https://api.day.app/xxxxxxBARK_SOUND❌healthnotificationiOS Bark app's notification sound. Default: healthnotificationCOOL_PUSH_SKEY❌ SKEY for Cool Push. https://cp.xuthus.cc/COOL_PUSH_MODE❌sendPush method for Cool Push. Choose from send(私聊),group(群组),wx(微信). Default: sendCRON_SIGNIN❌0 6   *Docker custom runtimeCUSTOM_NOTIFIER❌ Custom notifier configurationDD_BOT_TOKEN❌ 钉钉机器人WebHook地址中access_token后的字段.DD_BOT_SECRET❌ 钉钉加签密钥.在机器人安全设置页面,加签一栏下面显示的以SEC开头的字符串.DISCORD_WEBHOOK❌ Webhook of Discord.IGOT_KEY❌ KEY for iGot. For example: https://push.hellyw.com/xxxxxxPUSH_PLUS_TOKEN❌一对一推送pushplus 一对一推送或一对多推送的token.不配置push_plus_user则默认为一对一推送. https://www.pushplus.plus/doc/PUSH_PLUS_USER❌ pushplus 一对多推送的群组编码.在'一对多推送'-&gt;'您的群组'(如无则新建)-&gt;'群组编码'里查看,如果是创建群组人,也需点击'查看二维码'扫描绑定,否则不能接收群组消息.SCKEY❌ SCKEY for ServerChan. https://sc.ftqq.com/3.version/SCTKEY❌ SENDKEY for ServerChanTurbo. https://sct.ftqq.com/TG_BOT_API❌api.telegram.orgTelegram robot api address. Default: api.telegram.orgTG_BOT_TOKEN❌ Telegram robot token. Generated when requesting a bot from @botfatherTG_USER_ID❌ User ID of the Telegram push target.WW_ID❌ 企业微信的企业ID(corpid).在'管理后台'-&gt;'我的企业'-&gt;'企业信息'里查看. https://work.weixin.qq.com/api/doc/90000/90135/90236WW_APP_SECRET❌ 企业微信应用的secret.在'管理后台'-&gt;'应用与小程序'-&gt;'应用'-&gt;'自建',点进某应用里查看.WW_APP_USERID❌@all企业微信应用推送对象的用户ID.在'管理后台'-&gt;' 通讯录',点进某用户的详情页里查看.默认: @allWW_APP_AGENTID❌ 企业微信应用的agentid.在'管理后台'-&gt;'应用与小程序'-&gt;'应用',点进某应用里查看.WW_BOT_KEY❌ 企业微信机器人WebHook地址中key后的字段. https://work.weixin.qq.com/api/doc/90000/90136/91770"
  },
  
  {
    "title": "VS Code实时预览Markdown",
    "url": "/archives/46",
    "categories": "软件配置",
    "tags": "Markdown, VS Code",
    "date": "2022-06-09 00:03:34 +0800",
    





    
    "snippet": "引言在学习Markdown用法后，感觉非常好用(最近的文章都是使用Markdown写的)，又因为编程或Github建站会和Markdown打交道，而我编程使用VS Code(看嘉然)，遂寻找是否可以实时预览快捷键在Markdown文件界面(.md文件)，点击下文件界面(鼠标文本光标在文件内)，然后按下CTRL+K后按下V即可，注意使用英文输入法以上是实时预览，可以按CTRL+Shift+V打...",
    "content": "引言在学习Markdown用法后，感觉非常好用(最近的文章都是使用Markdown写的)，又因为编程或Github建站会和Markdown打交道，而我编程使用VS Code(看嘉然)，遂寻找是否可以实时预览快捷键在Markdown文件界面(.md文件)，点击下文件界面(鼠标文本光标在文件内)，然后按下CTRL+K后按下V即可，注意使用英文输入法以上是实时预览，可以按CTRL+Shift+V打开新窗口预览按钮在Markdown文件右上角有个打开侧边预览预览，点击即可控制台按CTRL+Shift+P打开控制台，然后输入markdown就能看到一些命令参考文章Visual Studio Code编写并实时预览Markdown"
  },
  
  {
    "title": "VS Code右下角嘉然",
    "url": "/archives/45",
    "categories": "日常",
    "tags": "VS Code",
    "date": "2022-06-01 06:01:00 +0800",
    





    
    "snippet": "引言首先我不是嘉心糖，我只是觉得很可爱(我刚开始甚至都不知道是嘉然)，然后这个Bug挺多，自启动不是每次都能触发，但她太可爱啦然后这个拓展还可以改背景，但我个人不是太喜欢就没改效果预览如下安装打开VS Code然后在拓展搜索A-SOUL-live2d安装拓展地址：A-SOUL-live2d - Visual Studio Marketplace其实可以直接去拓展那看，有安装过程，不用看我写的...",
    "content": "引言首先我不是嘉心糖，我只是觉得很可爱(我刚开始甚至都不知道是嘉然)，然后这个Bug挺多，自启动不是每次都能触发，但她太可爱啦然后这个拓展还可以改背景，但我个人不是太喜欢就没改效果预览如下安装打开VS Code然后在拓展搜索A-SOUL-live2d安装拓展地址：A-SOUL-live2d - Visual Studio Marketplace其实可以直接去拓展那看，有安装过程，不用看我写的垃圾文章简单使用安装完毕重启VS Code，然后在资源视图最下方会有LIVE2D-A-SOUL，展开(不能展开就重启VS Code)然后在补充配置处生成插件依赖文件，重启VS Code，点击启动live2d右下角就会出现嘉然啦，可以把鼠标移上去，拖动右上角第三个图标以移动位置，第一个点击改变大小调整完位置，大小后可以在配置信息处开启自启动，然后点击保存当前配置就可以打开VS Code就能看见嘉然啦~其他以下复制自插件介绍- 基本操作  - 启动、关闭live2d： 字面意思，会启动看板人物，初始默认位置右下角  - 保存当前配置： 在调整live2d大小缩放和拖拽位置后，可保存信息，下次启动时自动携带  - 重置默认位置： 当前位置异常，无法拖拽移动时可重置使用【缩放大小也会重置】  - 背景图    - 点击切换： 点击按钮为人物右侧图标第二个    - 保存背景图： 需要当前背景图存在才会生效。只能保存一份，再次点击会覆盖旧的    - 加载背景图： 加载保存的背景图    - 定时切换： 字面意思，可查看 切换按钮 是否旋转判断是否开启定时功能    - 背景图样式配置    - 下载背景图- 配置信息  - 自启动： 字面意思，开启后。vscode启动，live2d自动启动  - 定位依赖： 人物定位的依赖角- 补充配置  - 插件依赖文件：    - 插件依赖文件会在初次安装插件并启动时自动生成    - 生成： live2d无法正常启动时，可尝试点击该按钮，强制重新生成覆盖配置信息    - 移除： 卸载该插件前，请尽可能先执行该操作。 可移除插件对vscode文件的所有修改- 人物功能  - 目光跟随鼠标 【缺点，暂时无法实现整个页面的跟随】  - 点击互动  - asoul粉丝导航网站入口  - 切换背景图  - 切换模型  - 溜冰场  - 音频测试  - 一个魂二创网站入口  - 模型来源关于警告使用会弹出Code损坏警告，原作者指出  本插件是通过修改 vscode 的 js 文件的方式运行 所以会在初次安装，或者 vscode 升级的时候，出现以下提示，请选择 【不再提示】音频支持当前插件仅一个简单的语音测试，暂且可以不用考虑该功能VS Code 使用的 Electron 版本不包含 ffmpeg，需替换自带的 ffmpeg 动态链接库才能正常播放 (每次更新 VS Code 都需重新替换)VS Code for Windows 1.31.0 - 1.35.1 不需替换，1.36.0 后无此待遇VS Code for macOS 1.43+ 替换后闪退解决方案卸载首先将补充配置移除，然后在拓展界面卸载插件即可"
  },
  
  {
    "title": "Github Pages建站及自定义域名",
    "url": "/archives/44",
    "categories": "网站建设",
    "tags": "Github",
    "date": "2022-05-28 15:30:43 +0800",
    





    
    "snippet": "引言最近基于Github Pages整了一个个人页面，记录一下如何使用Github Pages建站以及自定义域名本文没有建站系统等，因为我也就写了一个Markdown文件创建Github仓库首先需要注册一个Github账号，登录后创建一个新仓库其中Repository name为username.github.io，例如我的Github用户名为yexca，则输入yexca.github.io...",
    "content": "引言最近基于Github Pages整了一个个人页面，记录一下如何使用Github Pages建站以及自定义域名本文没有建站系统等，因为我也就写了一个Markdown文件创建Github仓库首先需要注册一个Github账号，登录后创建一个新仓库其中Repository name为username.github.io，例如我的Github用户名为yexca，则输入yexca.github.ioGit环境安装Windows环境直接从Git官网直接下载安装程序即可安装完成后，打开Git Bash，在命令行输入以下代码$ git config --global user.name \"Your Name\"$ git config --global user.email \"email@example.com\"其中“Your Name”替换为您的姓名，“email@example”替换为您的邮箱例如我的$ git config --global user.name \"yexca\"$ git config --global user.email \"yexcano@gmail.com\"Github Desktop安装如果您熟悉Git的操作熟悉Git操作怎么会来看我的文章，这一步可以跳过直接进入Github Desktop官网下载安装即可克隆仓库打开Github Desktop后登录Github账号选择一个空文件夹将上一步创建的仓库克隆到本地然后软件会出现一个仓库变动界面，右方会有一些快捷操作这里我使用VS Code，点击“Open in Visual Studio Code”在VS Code打开建立网站这里直接创建一个README.md文件使用Markdown编辑(这里顺便放一个我写的Markdown笔记)编辑完成并保持后在Github Desktop点击Commit to main，然后点击右方Push origin即可至此访问username.github.io即可看到网站内容如果没看到请等一段时间自定义域名Github Pages进入刚刚建立的仓库页面，点击Settings，左侧找到Pages，在Custom domain处输入自定义域名然后点击Save注：在这里可以进行Jekyll建站主题的选择DNS在域名的DNS解析处添加一个CNAME类型解析，将域名指向username.github.io，其中username为您的Github用户名HTTPS这里我用Github的不知为何没成功，于是使用Cloudflare在DNS解析处启用代理，然后在SSL/TLS的边缘证书处将始终使用HTTPS打开即可其他建站因无博客需求，我只是写一个简单的文件，如果是建立博客之类的可以使用一些建站工具  Jekyll Github官方支持的建站      VuePress中文网  Markdown推荐    Gitbook 适合建立文档类网站  LOFFER  Gridea 一个静态博客写作客户端  Hexo 快速、简洁且高效的博客框架  Hugo参考文章GitHub Pages 快速入门 - GitHub DocsGitHub Pages博客：自定义域名，HTTPS，CAA — 浮云的博客GitHub Pages 搭建教程安装Git - 廖雪峰的官方网站"
  },
  
  {
    "title": "Markdown简述(学习笔记)",
    "url": "/archives/43",
    "categories": "技术工具",
    "tags": "Markdown",
    "date": "2022-05-28 00:59:23 +0800",
    





    
    "snippet": "引言最近因建网盘网站了解了一下 Markdown，发现这玩意非常好用，于是写一份学习笔记可以通过在线编辑器边看边学，也可下载一些编辑器个人编写Markdown的工具为 Typora复习可以去看官方的速查表 Markdown 语法速查表标题创建一个标题，仅需#+空格+标题文字，一共有六级，对应 HTML 的 h1~h6例如以下代码# 这是一级标题## 这是二级标题### 这是三级标题·····...",
    "content": "引言最近因建网盘网站了解了一下 Markdown，发现这玩意非常好用，于是写一份学习笔记可以通过在线编辑器边看边学，也可下载一些编辑器个人编写Markdown的工具为 Typora复习可以去看官方的速查表 Markdown 语法速查表标题创建一个标题，仅需#+空格+标题文字，一共有六级，对应 HTML 的 h1~h6例如以下代码# 这是一级标题## 这是二级标题### 这是三级标题······###### 这是六级标题效果如下这是一级标题这是二级标题这是三级标题······这是六级标题换行仅需在上一行末尾加上俩个以上空格后回车即可，有些编辑器可直接换行例如以下代码这是第一行  //这里有俩空格  这是第二行效果如下这是第一行  //这里有俩空格这是第二行斜体 &amp; 粗体斜体为文本前后加一个*，粗体为文本前后加俩**例如以下代码*这是斜体*  **这是粗体**  ***这是斜体加粗体***效果如下这是斜体这是粗体这是斜体加粗体引用创建引用区块仅需在段首添加&gt;+空格+内容例如以下代码&gt; 这是一级引用&gt;&gt; 这是二级引用&gt;&gt;&gt; 这是三级引用 效果如下  这是一级引用      这是二级引用          这是三级引用      列表可以创建有序列表和无序列表有序列表在列表项前添加数字+.+空格+内容即可例如以下代码1. 第一项2. 第二项3. 第三项效果如下  第一项  第二项  第三项无序列表使用+，-或*+空格+ 内容即可，但请不要混用 (为了兼容性)子项可以使用四个空格或一个TAB然后用父项格式即可例如以下代码* 第一项    * 第一项子一项    * 第一项子二项        * 第一项子二项子一项* 第二项* 第三项效果如下  第一项          第一项子一项      第一项子二项                  第一项子二项子一项                      第二项  第三项代码单行将要变为代码的内容放在”`“中即可，如果代码中有”`“，请使用”``”例如以下代码`将此内容变为代码块```此内容中含有'`'哦~``效果如下将此内容变为代码块此内容中含有'`'哦~代码块可以通过将每一行缩进四个空格或一个TAB或者上下行”```“包围，要使用高亮，请在上方”```“后写上语言类型例如以下代码// 这是使用缩进的C代码    include&lt;stdio.h&gt;    int main(void)    {        printf(\"Hello World\");    }// 这是使用```的C代码``` Cinclude&lt;stdio.h&gt;int main(void){    printf(\"Hello World\");}```效果如下// 这是使用缩进的 C 代码include&lt;stdio.h&gt;int main(void){    printf(\"Hello World\");}// 这是使用”```“的 C 代码include&lt;stdio.h&gt;int main(void){    printf(\"Hello World\");}注：第一种(缩进)部分Markdown编辑器不支持分割线在单独一行使用三个及以上的*，-或_即可例如以下代码***--------_____效果如下链接简易链接直接将链接或邮箱地址使用 &lt;&gt; 括起来即可例如以下代码&lt;https://yexca.net&gt;  &lt;yexca@duck.com&gt;效果如下https://yexca.netyexca@duck.com自定义文字的链接[超链接显示名](超链接地址 \"超链接title\")，其中 \"超链接title\" 可以不填例如以下代码[yexca的博客](https://blog.yexca.net)  [yexca的博客](https://blog.yexca.net \"其实是yexca和Hiyoung的博客\")效果如下yexca的博客yexca的博客引用类型链接例如以下代码[blog]: https://blog.yexca.net[contact]: &lt;yexca@duck.com&gt;这是我的[个人博客][blog]，有问题可以[联系我][contact]效果如下这是我的个人博客，有问题可以联系我图片插入图片![图片alt](图片链接 \"图片title\")，其中‘图片 alt’为当图片加载失败时显示的内容，‘图片 title’为鼠标放图片上显示的内容注意：部分Markdwon编辑器不支持图片title例如以下代码![图片](https://cdn.statically.io/gh/yexca/image_hosting@master/2023/04-网站背景/blog-background.2p10z489pjc0.webp \"这是本站的背景\")效果如下图片包含链接使用链接的语法，将图片放在‘[]’里即可例如以下代码[![图片](https://cdn.statically.io/gh/yexca/image_hosting@master/2023/04-网站背景/blog-background.2p10z489pjc0.webp)](https://www.pixiv.net/artworks/82542737)效果如下转义字符如果有不想被 Markdown 格式化的字符，只需要在前方加上‘\\’即可例如以下代码我想打出*但这会被斜体*  加上转移符\\*后面就不会斜体\\*而且可以显示效果如下我想打出但这会被斜体加上转移符 * 后面就不会斜体 * 而且可以显示内嵌 HTML直接使用即可，以缩略标签为例例如以下代码&lt;details&gt;    &lt;summary&gt;        点我试试    &lt;/summary&gt;被发现啦&lt;/details&gt;我可以用Markdown**变粗**，也可以同时用HTML&lt;i&gt;变斜&lt;/i&gt;效果如下            点我试试    被发现啦我可以用Markdown变粗，也可以同时用HTML变斜表格使用三个或多个-创建每列标题，使用|分割每列，使用:以左，右或居中对齐 (非必须)例如以下代码|标题|内容|备注||:---|:---:|---:||左对齐|居中|右对齐|效果如下            标题      内容      备注                  左对齐      居中      右对齐      注意：不可以在表格中添加标题，引用，列表，图像或 HTML 标签等删除线在要删除的内容前后添加~~例如以下代码我永远喜欢~~战争文学博士~~Warma效果如下我永远喜欢战争文学博士 Warma任务列表使用-+空格+[ ]或[x]+空格+内容例如以下代码- [ ] 这个没完成呢- [x] 这个完成啦 效果如下  这个没完成呢  这个完成啦使用 Emoji 表情复制粘贴多数情况可直接复制 Emojipedia 上的表情直接粘贴，请确保网页编码为’UTF-8‘使用表情符号简码这个需要 Markdown 应用程序支持，以冒号:开头和结尾可以通过表情符号简码列表查询例如以下代码:blush:,:smiley:效果如下😊,😃脚注例如以下代码这里引用了维基百科[^1]，这里引用了Github[^2]。也可以使用英文，但不能用空格或TAB[^yexca][^1]: 这里可以使用文字，然后会在上方相应位置出现[^2]: 或者使用链接[Github](https://github.com)[^yexca]: [个人主页](https://blog.yexca.net)这里引用了维基百科1，这里引用了Github2。也可以使用英文，但不能用空格或TAB3注意：部分编辑器不支持参考文章Markdown 官方教程Markdown 学习            这里可以使用文字，然后会在上方相应位置出现 &#8617;              或者使用链接Github &#8617;              个人主页 &#8617;      "
  },
  
  {
    "title": "プロセカ的IP规则",
    "url": "/archives/42",
    "categories": "日常",
    "tags": "Game",
    "date": "2022-05-19 15:01:25 +0800",
    





    
    "snippet": "引言本人可直连进入游戏，但加速器等不可进入游戏，又因每次进入游戏关闭虚拟私人网路较为麻烦，寻找相应资料却无果，故写此文。(游戏为IOS日服)正文通过查看日志文件确定了进入游戏时连接的域名将以下域名加入DIRECT即可sekai.colorfulpalette.org后记本想详细写写的，却发现游戏出了国际服和台服，如果详细写估计要花费很长时间并去校验，懒~",
    "content": "引言本人可直连进入游戏，但加速器等不可进入游戏，又因每次进入游戏关闭虚拟私人网路较为麻烦，寻找相应资料却无果，故写此文。(游戏为IOS日服)正文通过查看日志文件确定了进入游戏时连接的域名将以下域名加入DIRECT即可sekai.colorfulpalette.org后记本想详细写写的，却发现游戏出了国际服和台服，如果详细写估计要花费很长时间并去校验，懒~"
  },
  
  {
    "title": "Linux添加用户和管理员用户",
    "url": "/archives/41",
    "categories": "Linux",
    "tags": "",
    "date": "2022-05-16 15:29:21 +0800",
    





    
    "snippet": "添加管理员用户：1、新建用户，这里新建一个temp_test的用户adduser temp\\_test2、设置新用户密码passwd temp_test3、将sudoers文件的权限修改成可编辑chmod -v u+w /etc/sudoers4、使用vim编辑sudoers文件vim /etc/sudoers5、在sudoes文件中添加如下的内容找到root ALL=(ALL) ALL然后...",
    "content": "添加管理员用户：1、新建用户，这里新建一个temp_test的用户adduser temp\\_test2、设置新用户密码passwd temp_test3、将sudoers文件的权限修改成可编辑chmod -v u+w /etc/sudoers4、使用vim编辑sudoers文件vim /etc/sudoers5、在sudoes文件中添加如下的内容找到root ALL=(ALL) ALL然后添加temp_user ALL=(ALL) ALL如需新用户使用sudo时不用输密码，把最后一个ALL改为NOPASSWD:ALL即可。6、将sudoers文件的权限修改成不可编辑chmod -v u-w /etc/sudoers7、删除用户userdel temp_test"
  },
  
  {
    "title": "Liunx随手笔记",
    "url": "/archives/40",
    "categories": "Linux",
    "tags": "",
    "date": "2022-04-30 04:24:07 +0800",
    





    
    "snippet": "  Linux不会自动创建不存在的文件夹,使用”mv”命令时需要注意文件夹是否存在,否则会将文件重命名。  为文件创建硬链接实际上是为文件创建了额外的名字部分(数据部分未改动),类似于C语言中创建了一个指针指向该文件。  为文件创建符号链接类似于WIN中的快捷方式,在使用”ls -li”命令中可以比较直观的看出区别。硬链接字节数和源文件一样，而符号链接字节数不同。  使用别名“alias”创...",
    "content": "  Linux不会自动创建不存在的文件夹,使用”mv”命令时需要注意文件夹是否存在,否则会将文件重命名。  为文件创建硬链接实际上是为文件创建了额外的名字部分(数据部分未改动),类似于C语言中创建了一个指针指向该文件。  为文件创建符号链接类似于WIN中的快捷方式,在使用”ls -li”命令中可以比较直观的看出区别。硬链接字节数和源文件一样，而符号链接字节数不同。  使用别名“alias”创建命令：在同一行同时运行多个命令用“;”分开；可以使用“type”查询命令是否已经在系统中；值得注意的是使用“alias”创建命令在结束shell会话时会消失（因为没有添加到文件中去）；使用”unalias”删除别名  使用“&gt;”重定向会重写源文件，”&gt;&gt;”重定向会在源文件后续写  将错误信息写入文件（而不是显示在屏幕上）可以用“2&gt;”  重定向标准输出和错误到同一个文件有两种方法：一是，在重定向的文件名后加上 ”2&gt;&amp;1“；二是，在重定向符前加 ”&amp;“。方法一（在老版本的shell也可使用）方法二"
  },
  
  {
    "title": "在虚拟机中设置静态IP（centos为例）",
    "url": "/archives/39",
    "categories": "Linux",
    "tags": "",
    "date": "2022-04-22 18:13:42 +0800",
    





    
    "snippet": "一、虚拟机设置在菜单栏选择编辑→ 虚拟网络编辑器，打开虚拟网络编辑器对话框，选择Net网络连接方式，随意设置子网IP，点击NAT设置页面，查看子网掩码和网关，后面修改静态IP会用到。在VMnet8模式下选择nat连接，并且取消DHCP服务。点击NAT设置，记录下此时的网关在系统的网络设置处，检查VMnet8的网络配置二、Liunx主机设置在root权限下输入命令 cd /etc/syscon...",
    "content": "一、虚拟机设置在菜单栏选择编辑→ 虚拟网络编辑器，打开虚拟网络编辑器对话框，选择Net网络连接方式，随意设置子网IP，点击NAT设置页面，查看子网掩码和网关，后面修改静态IP会用到。在VMnet8模式下选择nat连接，并且取消DHCP服务。点击NAT设置，记录下此时的网关在系统的网络设置处，检查VMnet8的网络配置二、Liunx主机设置在root权限下输入命令 cd /etc/sysconfig/network-scripts 进入该文件夹，输入命令 ls 浏览该文件夹下的文件，找到ifcfg-en***文件，如下图所示：vim ifcfg-en***打开文件将BOOTPROTO=”dhcp”改为BOOTPROTO=”static”、ONBOOT=”no”改为ONBOOT=”yes”并在下方添加IPADDR=your ip（静态IP地址）NETMASK=your netmask（子网掩码，一般为255.255.255.0）GATEWAY=your gateway（网关地址）DNS1=8.8.8.8（国内外公共DNS即可）DNS2=8.8.4.4最后输入:wq退出即可"
  },
  
  {
    "title": "系统学习Linux笔记",
    "url": "/archives/38",
    "categories": "Linux",
    "tags": "",
    "date": "2022-04-19 02:53:27 +0800",
    





    
    "snippet": "（参考视频：https://www.bilibili.com/video/BV1WY4y1H7d3?p=1）一、基础篇1.1 Linux文件系统目录结构来源：菜鸟教程图中小箭头表示该文件实际位置在别处  /bin：   bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。  /boot：  这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文...",
    "content": "（参考视频：https://www.bilibili.com/video/BV1WY4y1H7d3?p=1）一、基础篇1.1 Linux文件系统目录结构来源：菜鸟教程图中小箭头表示该文件实际位置在别处  /bin：   bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。  /boot：  这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。  /dev ：  dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。  /etc：  etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。  /home：  用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。  /lib：  lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。  /lost+found：  这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。  /media：  linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。  /mnt：  系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。  /opt：  opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。  /proc：  proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。  这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all  /root：  该目录为系统管理员，也称作超级权限者的用户主目录。  /sbin：  s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。  /selinux：   这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。  /srv：   该目录存放一些服务启动之后需要提取的数据。  /sys：这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。  /tmp：  tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。  /usr：   usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。  /usr/bin：  系统用户使用的应用程序。  /usr/sbin：  超级用户使用的比较高级的管理程序和系统守护程序。  /usr/src：  内核源代码默认的放置目录。  /var：  var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。  /run：  是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。1.2 文件基本属性1.2.1 基本属性在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。  当为 d 则是目录  当为 – 则是文件；  若是 l 则表示为链接文档(link file)；  若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；  若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 – 。每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。从左至右用 0-9 这些数字来表示。第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。其中，第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 – 字符表示，则没有读权限；第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，如果用 – 字符表示没有写权限；第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限，如果用 – 字符表示，则没有执行权限。1.2.2 Linux文件属主和属组1、chgrp：更改文件属组语法：chgrp [-R] 属组名 文件名参数选项  -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。2、chown：更改文件属主，也可以同时更改文件属组语法：chown [–R] 属主名 文件名chown [-R] 属主名：属组名 文件名进入 /root 目录（~）将install.log的拥有者改为bin这个账号：[root@www ~] cd ~[root@www ~]# chown bin install.log[root@www ~]# ls -l-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log将install.log的拥有者与群组改回为root：[root@www ~]# chown root:root install.log[root@www ~]# ls -l-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log3、chmod：更改文件9个属性Linux文件属性有两种设置方法，一种是数字，一种是符号。Linux 文件的基本权限就有九个，分别是 owner/group/others(拥有者/组/其他) 三种身份各有自己的 read/write/execute 权限。先复习一下刚刚上面提到的数据：文件的权限字符为： -rwxrwxrwx ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：  r:4  w:2  x:1每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： -rwxrwx— 分数则是：  owner = rwx = 4+2+1 = 7  group = rwx = 4+2+1 = 7  others= — = 0+0+0 = 0所以等一下我们设定权限的变更时，该文件的权限数字就是 770。变更权限的指令 chmod 的语法是这样的：chmod [-R] xyz 文件或目录选项与参数：  xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。  -R : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更举例来说，如果要将 .bashrc 这个文件所有的权限都设定启用，那么命令如下：[root@www ~]# ls -al .bashrc-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc[root@www ~]# chmod 777 .bashrc[root@www ~]# ls -al .bashrc-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc那如果要将权限变成 -rwxr-xr– 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]=754。4、符号类型改变文件权限还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：  user：用户  group：组  others：其他那么我们就可以使用 u, g, o 来代表三种身份的权限。此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看：| chmod | u   g   o   a | +(加入)   -(除去)   =(设定) | r   w   x | 文件或目录 ||---|---|---|---|---|如果我们需要将文件权限设置为 -rwxr-xr– ，可以使用 chmod u=rwx,g=rx,o=r 文件名 来设定:touch test1    // 创建 test1 文件ls -al test1    // 查看 test1 默认权限#-rw-r--r-- 1 root root 0 Nov 15 10:32 test1chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限ls -al test1-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：chmod  a-x test1ls -al test1#-rw-r--r-- 1 root root 0 Nov 15 10:32 test11.3 vim文本编辑1.3.1 vim的三种模式基本上 vi/vim 共分为三种模式，分别是命令模式、编辑模式和一般模式1.3.2 vim快捷命令参考外部网站：https://www.runoob.com/linux/linux-vim.html1.4 网络配置1.4.1 VMware的三种网络连接模式桥接模式：虚拟机直接连接外部网络（对外部网络可见），主机起到网桥的作用，虚拟机的地位和主机相同，从路由器分配独立的IP地址。NAT模式：主机和虚拟机构建一个专用网络，使用NAT对虚拟机进行IP转换（虚拟机对外部网络不可见）。此时虚拟机单独组成一个局域网，此时主机和虚拟机并不在一个网段，无法进行通信，所以又虚拟一个网卡（VMnet8）来连接至虚拟机所在的局域网。仅主机模式：这种模式仅仅只让虚拟机与主机通信，不连接至Internet1.4.2 配置静态IP参考站内文章：在虚拟机中设置静态IP（centos为例）1.4.3 配置主机名hostname #查看当前主机名vim /etc/hostname  #修改主机名#修改后重启即可显示新主机名#方法二 hostnamectl set-hostname ... #实时生效#修改hosts文件vim /etc/hosts1.5 系统管理1.5.1 service 服务管理一个正在执行的程序或命令，称为“进程”启动后一直存在、常驻内存的进程，一般称为“服务”systemctl start|stop|restart|status servicename #基本语法/usr/lib/systemd/system/    #服务所在目录"
  },
  
  {
    "title": "免启动steam打开OBS",
    "url": "/archives/37",
    "categories": "日常",
    "tags": "",
    "date": "2022-04-11 22:19:48 +0800",
    





    
    "snippet": "引言2022年03月22日，OBS上架Steam，方便了更新，但每次使用都要打开Steam着实有点麻烦。正文Steam库界面右击“OBS Studio” ，依次选择“管理-浏览本地文件”在文件资源管理器内进入路径“bin/64bit”或“bin/32bit”，找到“obs64”或“obs32”直接点击这个文件就可以启动OBS，所以可以将其固定到“开始”屏幕或创建快捷方式右击创建快捷方式，将快...",
    "content": "引言2022年03月22日，OBS上架Steam，方便了更新，但每次使用都要打开Steam着实有点麻烦。正文Steam库界面右击“OBS Studio” ，依次选择“管理-浏览本地文件”在文件资源管理器内进入路径“bin/64bit”或“bin/32bit”，找到“obs64”或“obs32”直接点击这个文件就可以启动OBS，所以可以将其固定到“开始”屏幕或创建快捷方式右击创建快捷方式，将快捷方式放到桌面即可"
  },
  
  {
    "title": "查询B站注册时间(精确到秒)",
    "url": "/archives/36",
    "categories": "技术工具",
    "tags": "",
    "date": "2022-04-09 13:47:52 +0800",
    





    
    "snippet": "一、查询时间戳打开网页https://member.bilibili.com/x2/creative/h5/calendar/event?ts=0按下CTRL+F，输入”jointime”，找到jointime后面的数字即为时间戳将时间戳复制二、转换时间戳打开网站时间戳(Unix timestamp)转换工具 – 在线工具 (tool.lu)在相应位置输入时间戳点击转换即可参考资料up教你如...",
    "content": "一、查询时间戳打开网页https://member.bilibili.com/x2/creative/h5/calendar/event?ts=0按下CTRL+F，输入”jointime”，找到jointime后面的数字即为时间戳将时间戳复制二、转换时间戳打开网站时间戳(Unix timestamp)转换工具 – 在线工具 (tool.lu)在相应位置输入时间戳点击转换即可参考资料up教你如何查看自己的B站注册时间，精确到秒！_哔哩哔哩_bilibili"
  },
  
  {
    "title": "使用PicX图床上传图片提示“Bad credentials”",
    "url": "/archives/35",
    "categories": "日常",
    "tags": "Github, 图床",
    "date": "2022-03-22 16:30:12 +0800",
    





    
    "snippet": "引言今日我写文章时，发现PicX图床无法使用并提示“Bad credentials” ，于是便寻找解决方法结论其实就是Github的Token到期了，然后在邮箱里会收到一封邮件，名为“[GitHub] Your personal access token has expired”邮件有三行，第二行“If this token is still needed” ，后面有个链接，点击打开并重新创...",
    "content": "引言今日我写文章时，发现PicX图床无法使用并提示“Bad credentials” ，于是便寻找解决方法结论其实就是Github的Token到期了，然后在邮箱里会收到一封邮件，名为“[GitHub] Your personal access token has expired”邮件有三行，第二行“If this token is still needed” ，后面有个链接，点击打开并重新创建即可注意设置“Expiration”即Token期限重新创建后需要在PicX将“图床配置下重置下”具体参考：使用PicX自建免费图床 – yexca’Blog"
  },
  
  {
    "title": "VRchat在中文吧自动弹钢琴",
    "url": "/archives/34",
    "categories": "日常",
    "tags": "Game",
    "date": "2022-03-22 16:11:47 +0800",
    





    
    "snippet": "引言近日通过好友告知VRchat中的钢琴可以自行弹奏，于是便学习了以下，写此篇文章以作记录。注：好像只可以PC模式下自动弹奏，当然，您也可以在VR下投出桌面试试（doge如果不使用mid文件一、准备为实现钢琴自动弹奏，需要安装两个软件，一个插件1）loopMIDI此软件可在官网直接获取，官网链接：loopMIDI-Tobias Erichsen (tobias-erichsen.de)文件直...",
    "content": "引言近日通过好友告知VRchat中的钢琴可以自行弹奏，于是便学习了以下，写此篇文章以作记录。注：好像只可以PC模式下自动弹奏，当然，您也可以在VR下投出桌面试试（doge如果不使用mid文件一、准备为实现钢琴自动弹奏，需要安装两个软件，一个插件1）loopMIDI此软件可在官网直接获取，官网链接：loopMIDI-Tobias Erichsen (tobias-erichsen.de)文件直链：loopMIDISetup_1_0_16_27.zip（可能因为版本更新而失效）2）Jazz-Plugin安装时请保持默认安装路径，否则可能无法正常使用Windows: 点此下载（插件官网链接） （如果官网链接无法下载，也可 点此下载 ）Mac OS X: 点击下载Linux version: 点击下载3）浏览器插件Jazz-MIDIChrome，Opera，或者其他双核浏览器（如360安全浏览器等）：点击前往Chrome应用店安装如果无法访问Chrome应用店Chrome 73 版本前的请下载 Jazz-MIDI-crx2.crx 使用，Chrome 73 之后的版本请下载 Jazz-MIDI-crx3.crx 使用。Chrome进入拓展程序&lt;1&gt;通过在地址栏输入(或此处直接点击)chrome://extensions并回车进入拓展程序&lt;2&gt;如图所示Edge进入拓展程序&lt;1&gt;通过在地址栏输入(或此处直接点击)edge://extensions/并回车进入拓展程序&lt;2&gt;如图所示如果出现弹窗，点击”管理拓展”打开拓展程序界面后首先打开“开发人员模式”，Chrome在右上，Edge在左中然后直接把下载好的crx文件拖入拓展程序界面即可二、步骤1）打开loopMIDI，新建项目新建项目先在右下“New port-name”输入名称，后点击左下“+” (加号)即可完成后项目会出现在上方，这里以”Hello World”为项目名2)开始播放&lt;1&gt;找到待播放的歌曲首先，打开网站MidiShow – 领先的MIDI音乐交流与下载网站注册登录后搜索想播放的歌曲&lt;2&gt;进行播放设置如图所示，以“Hand in Hand”为例，点击“播放设置”按钮设置如图， “MIDI输出设备”选择刚刚使用loopMIDI新建的项目，这里为“Hello World”&lt;3&gt;开始播放此时进入中文吧钢琴旁，选中板凳坐上去，然后在网页中点击播放即可如果使用mid文件首先，请确保mid文件为钢琴谱，多轨文件可能会发生混乱，请自行编辑一、准备1）loopMIDI此软件可在官网直接获取，官网链接：此软件可在官网直接获取，官网链接：loopMIDI-Tobias Erichsen (tobias-erichsen.de)文件直链：loopMIDISetup_1_0_16_27.zip（可能因为版本更新而失效）2）MidiPiano此软件我在某下载软件网站获取(Google搜索结果第一个)网站链接：MidiPiano – Download (softonic.com)二、步骤1）在loopMIDI中新建项目新建项目先在右下“New port-name”输入名称，后点击左下“+” (加号)即可完成后项目会出现在上方，这里以”Hello World”为项目名2）打开MidiPiano，进行设置点击播放列表，可直接将文件拖入，点击选项，将输出设备设置为刚刚loopMIDI创建的项目，此处为“Hello World”如果出现弹窗“MIDI输入输出不能为同一个，会死机的！”请点击选项中“Midi输入设备”，将刚刚loopMIDI创建的项目取消，然后再切至“Midi输出设备”将其打开3）开始播放此时进入中文吧钢琴旁，选中板凳坐上去，然后选择“播放列表”中想播放的歌曲，再点击“播放”即可参考资料【VRChat】教你怎样在中文吧自动弹钢琴_哔哩哔哩_bilibili播放器选择及插件安装说明 (midishow.com)"
  },
  
  {
    "title": "图床网站总结",
    "url": "/archives/33",
    "categories": "技术工具",
    "tags": "图床",
    "date": "2022-03-20 16:54:36 +0800",
    





    
    "snippet": "引言本文章为我自行搜集的一些免费图床，部分图床曾经使用过。当然，如果您想要使用图床，我推荐您阅读使用PicX自建免费图床 – yexca’Blog一、路过图床官网链接：路过图床 – 免费图片上传, 专业图片外链, 免费公共图床 (imgtu.com)高速稳定，单图最大 10 MB二、ImgURL官网链接：ImgURL免费图床游客每日限 10 次上传，单图最大 5 MB三、SM.MS官网链接：...",
    "content": "引言本文章为我自行搜集的一些免费图床，部分图床曾经使用过。当然，如果您想要使用图床，我推荐您阅读使用PicX自建免费图床 – yexca’Blog一、路过图床官网链接：路过图床 – 免费图片上传, 专业图片外链, 免费公共图床 (imgtu.com)高速稳定，单图最大 10 MB二、ImgURL官网链接：ImgURL免费图床游客每日限 10 次上传，单图最大 5 MB三、SM.MS官网链接：Image Upload – SM.MS – Simple Free Image Hosting老牌图床，现在游客禁止上传，普通用户单图最大 5 MB， 5 GB 存储空间（该图床的图片直链链接域名是loli.net四、KinhPicture官网链接：KinhPicture – 聚合图床岛主的聚合图床，支持阿里、百度、AWS S3 等 15 个接口，单图限制 2 ~ 32 MB五.极兔图床官网链接：极兔图床 – 免费图床,匿名图床,免费CDN图床,图床API,专业的图片托管商 (jitudisk.com)最大可上传 10 MB 的图片六、Gimhoy图床            官网链接：[Gimhoy图床-无限制永久免费图床 – 微博图床 – 全网CDN – 永久外链图床 – tuchuang – 图片外链 – 外链相册 – 国内图床 – 论坛图片 – 淘宝图片      pic.Gimhoy.com](https://pic.gimhoy.com/)      七、bayimg官网链接：bayimg – free uncensored image hosting"
  },
  
  {
    "title": "Windows 电脑截屏和录屏",
    "url": "/archives/32",
    "categories": "日常",
    "tags": "Windows",
    "date": "2022-03-19 13:57:39 +0800",
    





    
    "snippet": "前言此文章所写方法仅一般用途，如有特殊需求请自行查阅一、使用Win10/Win11自带1）系统自带截屏软件Win10/Win11自带一个截屏软件，名称为“截图工具”，有两种形式使用&lt;1&gt;打开软件使用通过按下“Win”按键，打开所有应用，找到“截图工具”打开如上为打开软件后界面，点击“新建”即可进行截屏&lt;2&gt;使用快捷键其实上图中软件界面已经有了快捷按键，为“Win+Sh...",
    "content": "前言此文章所写方法仅一般用途，如有特殊需求请自行查阅一、使用Win10/Win11自带1）系统自带截屏软件Win10/Win11自带一个截屏软件，名称为“截图工具”，有两种形式使用&lt;1&gt;打开软件使用通过按下“Win”按键，打开所有应用，找到“截图工具”打开如上为打开软件后界面，点击“新建”即可进行截屏&lt;2&gt;使用快捷键其实上图中软件界面已经有了快捷按键，为“Win+Shift+S”，三个一起按键即可开始截屏完成截图后保存当完成截图后，右下通知中心会出现一弹窗。如果是想通过聊天软件发送可直接在聊天界面输入框按下“Ctrl+V”即可出现图片如果想保存到本地可点击通知中心相应通知，弹出截图后按下“Ctrl+S”选择路径保存其他功能请自行探索2）使用系统自带的Xbox Bar通过按下“Win+G”即可打开Xbox Bar，点击空白处或再次按下“Win+G”即可关闭&lt;1&gt;通过Xbox Bar截屏和录屏如图所示，红框中第一个按钮为截图，第三个按钮为录屏，再次按下以结束录屏(或按下屏幕上出现的一个悬浮窗上的结束按钮)如果未出现“捕获”框，请按下上图蓝框中按钮&lt;2&gt;截屏和录屏所在位置如上图所示，红框中有“显示全部捕获”，点击即可出现使用Xbox Bar截屏或录屏的全部文件，每个文件下都会出现“打开文件位置”，点击即可打开文件所在位置当然，Xbox Bar所存储的文件路径在“此电脑/视频/摄像”(即C:\\Users\\你的用户名\\Videos\\Captures)，截屏和录屏都在这二、使用第三方应用如果是第三方的话会有很多选择，这里仅说明俩个，一般情况下系统自带完全够用1）使用QQ/TIM/WeChat(微信)进行截图或录制QQ/TIM的截图快捷键为“Ctrl+Alt+A”，录屏快捷键为“Ctrl+Alt+S”WeChat(微信)的截屏快捷键为“Alt+A”，未发现录屏功能两者均可在聊天界面输入框上方小剪刀图标右小箭头处进行修改“截屏隐藏当前窗口”2）使用OBS进行录屏OBS简介由于不是本文重点，此处复制官方简介，进入官方网站下载安装即可OBS Studio – Free and open source software for live streaming and screen recording官方网站：Open Broadcaster Software-OBS (obsproject.com)Github：obsproject/obs-studio: OBS Studio – Free and open source software for live streaming and screen recording (github.com)录制屏幕教程&lt;1&gt;使用OBS进行录制打开OBS界面如上图所示，在左下第二个有“来源窗口”，点击下方加号如上图所示，选择显示器采集，然后点两次确定即可出现显示器屏幕右方点“开始录制”即可开始录制当前桌面&lt;2&gt;文件保存位置点击左上“文件-显示录像”即可弹出录制文件保存位置问题：如果未出现屏幕此问题解决方法为在“NVIDIA控制面板”，在“管理3D设置”中将OBS的“为此程序选择首选图形处理器“改为“集成式”如下图所示，因我的电脑默认”集成式“，我便未更改如不能解决，请自行搜索其他方法"
  },
  
  {
    "title": "Beat Saber添加自定义歌单",
    "url": "/archives/31",
    "categories": "日常",
    "tags": "Game",
    "date": "2022-03-18 17:46:00 +0800",
    





    
    "snippet": "引言近期入正了Beat Saber(虽然是阿区)，于是便想着去添加自定义歌曲，通过steam的评论区得知WGzeyu大佬做了相关教程，但由于本人目的简单，而教程比较全，特写此文章进行总结一、准备2022.03.25: 今日更改相关东西发现1.20.0已有Mod，请直接看第二步，同时，恢复数据部分已更新1）降级由于当前最新版本1.20.0并无相关Mod，所以需要先进行降级，等Mod更新后可以再...",
    "content": "引言近期入正了Beat Saber(虽然是阿区)，于是便想着去添加自定义歌曲，通过steam的评论区得知WGzeyu大佬做了相关教程，但由于本人目的简单，而教程比较全，特写此文章进行总结一、准备2022.03.25: 今日更改相关东西发现1.20.0已有Mod，请直接看第二步，同时，恢复数据部分已更新1）降级由于当前最新版本1.20.0并无相关Mod，所以需要先进行降级，等Mod更新后可以再升级&lt;1&gt;下载1.19.0版本或更早可在WGzeyu大佬提供的网盘下载，选择想下的版本后进行下载文件直链：1.19.0 steam版&lt;2&gt;替换1.20.0版本解压下载的文件，然后通过steam打开游戏所在目录，返回上一级后将文件夹”Beat Saber“重命名为”Beat Saber 1.20.0“，然后将刚刚下载的文件更名为”Beat Saber“移到此文件夹&lt;3&gt;如何恢复数据&lt;1&gt;使用steam打开游戏目录，删除UserData文件夹内的Beat Saber IPA&lt;2&gt;复制以下文件夹(按需复制) UserData（Mod设置） CustomSabers（光剑模型） CustomPlatforms（场景模型） CustomAvatars（人物模型） CustomNotes（方块模型）&lt;3&gt;然后进入”Beat Saber 1.20.0“文件夹，粘贴复制的那些文件夹，在弹出的提示中，选择【替换】&lt;4&gt;打开”Beat Saber“文件夹，进入Beat Saber_Data文件夹，剪切CustomLevels文件夹&lt;5&gt;进入”Beat Saber 1.20.0“文件夹，进入Beat Saber_Data文件夹，粘贴剪切的那个文件夹，在弹出的提示中，选择【替换】最后将“Beat Saber”文件夹删除，将“Beat Saber 1.20.0”文件夹重命名为“Beat Saber”2）相关软件&lt;1&gt;Mod管理器”ModAssistant“此软件有英文版和中文版，请按需下载，网盘下载：网盘链接文件直链：ModAssistant中文增强版Mod安装器，支持PC不支持Quest&lt;2&gt;BeatSaber歌曲路径管理器可通过上述网盘链接下载，文件直链：BeatSaber歌曲路径管理器 (5.3版本，可能因为更新而失效)&lt;3&gt;ResilioSync可通过上述网盘链接下载，官网链接：ResilioSync文件直链：ResilioSync64位3）文件夹上述软件除ResilioSync均为单文件应用，可放置常用软件文件夹另需在想要存放歌曲的位置建立一个文件夹，比如”E:\\games\\Beat Saber Song\\“，随意位置二、步骤1）打开Beat Saber一次2）打开”ModAssistant“点击同意后可进入左方”Mod“界面，左下可选择游戏版本，选择好后可安装Mod，或直接开始安装如果速度过慢可在”选项“中将软件源改为国内3）打开Beat Saber一次4）打开ResilioSync此部分步骤请参考：Beat Saber曲包资源同步 – ResilioSync (wgzeyu.com)反正最后都是要打开这个网页的，已经有步骤了我就不写了（懒下载文件夹目录即选择上一步创建的文件夹5）打开BeatSaber歌曲路径管理器初次打开根据提示选择，然后点添加目录，选择放歌曲的目录(即上一步下载的文件夹目录)然后点保存列表即可三、后续当然，如果您有其他需求请参考WGzeyu的教程"
  },
  
  {
    "title": "使用Quest2 VR玩恋爱活动(恋活/koikatu)遇到的问题及解决",
    "url": "/archives/30",
    "categories": "日常",
    "tags": "Game",
    "date": "2022-03-18 16:54:23 +0800",
    





    
    "snippet": "引言在玩了 Beat Saber 和 VRchat 等 VR 游戏后突然想到 i 社有部分游戏支持 VR，本人最喜欢玩恋活，于是试着进行游玩，但却遇到相关问题，本文仅作记录。另 VR 版无剧情，且本人使用原版所以遇到问题较少。前提/条件以下图片和部分文字来自 Oculus 官网 Support，部分英文自己进行了翻译，鉴于本人英文不是太好，请以官方原内容为准，以下列出主要内容，详情请参考 O...",
    "content": "引言在玩了 Beat Saber 和 VRchat 等 VR 游戏后突然想到 i 社有部分游戏支持 VR，本人最喜欢玩恋活，于是试着进行游玩，但却遇到相关问题，本文仅作记录。另 VR 版无剧情，且本人使用原版所以遇到问题较少。前提/条件以下图片和部分文字来自 Oculus 官网 Support，部分英文自己进行了翻译，鉴于本人英文不是太好，请以官方原内容为准，以下列出主要内容，详情请参考 Oculus Link 的兼容性要求数据线要求Oculus Link 需使用能够支持数据和电源连接的优质 USB 数据线。为获得最佳舒适体验，您还应确保数据线长度至少为 3 米（10 英尺）。电脑要求            配件      推荐配置                  CPU      Intel i5-4590 / AMD 锐龙 5 1500X 或更高版本              显卡      请参阅下面的 GPU 表              内存      8 GB+ 内存              操作系统      Win10              USB 接口      1 个 USB 接口      Oculus Link 支持的 GPU                                             NVIDIA GPU      支持      暂时不支持              NVIDIA Titan Z             X              NVIDIA Titan X      X                     NVIDIA GeForce GTX 970      X                     NVIDIA GeForce GTX 1060 Desktop, 3GB             X              NVIDIA GeForce GTX 1060 Desktop, 6GB      X                     NVIDIA GeForce GTX 1060M             X              NVIDIA GeForce GTX 1070(all)      X                     NVIDIA GeForce GTX 1080(all)      X                     NVIDIA GeForce GTX 1650             X              NVIDIA GeForce GTX 1650 Super      X                     NVIDIA GeForce GTX 1660      X                     NVIDIA GeForce GTX 1660 TI      X                     NVIDIA GeForce RTX 20-series (all)      X                     NVIDIA GeForce RTX 30-series (all)      X                                                          AMD GPU      支持      暂时不支持              AMD 200 Series             X              AMD 300 Series             X              AMD 400 Series      X                     AMD 500 Series      X                     AMD 5000 Series      X                     AMD 6000 Series      X                     AMD Vega Series      X             一、进入游戏进入游戏 VR 版本直接打开 KoikatuVR.exe 即可，由于使用 steam 串流，故可提前进入 steamVR进入游戏前请确保戴上耳机，房门锁紧等以预防突发情况，如不能做到请注意行为 (doge)问题一：无法进入 steamVR一、确保安装相关软件1）steamVR 安装首先打开 steam，然后按住 “Win+R”，输入 “steam://run/250820”，按下回车便会自动安装 steamVR2）Oculus 安装访问官网下载，注意：安装完成后会下载相关文件，完成后会要求登录账户，请确保网络环境正常如要求提供支付方式，可寻找 “跳过” 按钮如果登录一直在加载，无法成功登录可通过修改 Hosts 解决，推荐使用火绒打开 hosts 文件修改如果不使用火绒，打开 C:\\Windows\\System32\\drivers\\etc，找到 hosts 这个文件，用记事本打开在文件末尾添加如下内容157.240.11.49 graph.oculus.com157.240.11.49 www2.oculus.com157.240.8.49 scontent.oculuscdn.com157.240.8.49 securecdn.oculus.com然后保存即可，如果不是使用火绒，请保存到一个地方然后移动回原目录并将后缀.txt 去除二、确保 Link 线正常事实上，连接 Quest2 的时候 Oculus 软件会有一步选择是否检测 Link 线，可通过此进行检测，如果当时未进行检测，可选择 “设备 - Quest2 和 Touch-USB 检测” 进行检测三、确保设置正常1）Quest2 设备设置使用 USB 连接 PC 和 Quest2 时 Quest 会弹出 “允许访问数据”，请选择拒绝，如果选择了 “允许”，请拔下再重新连接选择 “拒绝”2）Oculus 软件设置其实直接打开 steamVR 会有弹窗 “是否允许未知来源” 此时选择允许即可当然，可以在软件的 “设置 - 通用 - 未知来源” 进行打开四、还是无法打开？换个姿势试试如果以上都没问题但还是无法打开 steamVR，则可使用下述方式1）Quest2 设备当连接 PC 后一般会有弹窗 “启用 Oculus Link”，此时选择 “启用” 即可如果上述未选择 “启用” 或没有弹窗，可在下方任务栏的最左方即 “快速设置” 中找到 “Oculus Link”，点击即可打开2）启动 steamVR不会有人不知道 steamVR 怎么启动吧 (doge)如果先连接 VR 设备再打开 steam，那么 steam 的界面右上方应该有 “VR” 标识，点击即可打开如果无此标识，可在任务栏 (或者说右下托盘) 里找到 steam 图标，鼠标右击，倒数第二个即为 steamVR当然，可以在 steam 库中将 “工具” 也显示，这样可以在 steam 库中看见 steamVR二、开始游戏我不知道这里应该写什么，分这个标题是因为问题二与游戏有关，那就写其他的吧 (doge)点击 KoikatuVR.exe 会自动打开 steamVR，所以可以在 Quest2 设备打开 Oculus Link 后直接打开 KoikatuVR 即可。注意：游戏会在桌面有一个窗口，可通过 “Win+D” 最小化所有窗口，但当摘下头显再次戴上时好像会再次出现，请注意问题二：无法开始游戏/不知如何开始如果您阅读其他文章或观看相关视频可能会得到仅支持部分设备 (支持啥我忘了)，如果和我一样去测试了 VR kanojo 能否正常运行，也可能会以为是靠注视，其实不然 (我就是想多写点)只需要按下 “摇杆” 即可出现选择线，按下前 “扳机键” 即可选择 (更多操作请看“ 三、操作说明” )问题三：开始游戏后一直白屏，电脑上“LOADING”一直在一半可进コイカツ！ DL 版，点击下方 “体験版・無料ダウンロード” 中的 “コイカツ VR パッチ” 进行下载文件直链：コイカツ VR パッチ下载解压后会有一个可执行文件，运行后会出现 “コイカツ！VR_0531 更新版” 文件夹，将里面 “setup” 文件夹内容移动到游戏根目录并覆盖即可注意：此方法来源作者指出姿势会变成只有三个，由于我并未游玩，所以我没有姿势 (本来想着 VR 玩剧情的，但 VR 不能玩剧情)，以下为作者给出解决 (部分内容有修改)，” 姿势是在故事模式里用过什么姿势，在 vr 里才能用，所以在故事模式里战斗的时候把所有姿势都点一遍，点完就换就行，然后到晚上存档，在退出换 vr，然后姿势就齐了 “原文地址：兄弟们有没有玩了 vr 的三、操作说明此部分为自行游玩得出，仅作部分说明，其他操作请自行参考其他文章1）开始游戏进入游戏后会有俩选项，分别为スタート，即 start，即开始エンド，即 End，即结束按下” 摇杆 “，会出现一条线，可进行选择 (前” 扳机键 “)2）进入 H左右手手腕部分会出现文字，可通过左右控制器上方按键即”Y “和” B“进行切换，一共有俩个，进入战斗后有三个 (多了一个” 移動 “)，分别为            日文      英文      中文      作用                  アクション      Action      行动      前” 扳机键 “可进行各种操作 侧” 扳机键 “可打开菜单 按下” 摇杆 “可进行选择              システム      system      系统      前” 扳机键 “可重置位置              移動      Move      移动      前” 扳机键 “按住可改变视角      3）注意仅可在” アクション “时按下” 摇杆 “可以进行选择参考文章Oculus Link兄弟们有没有玩了 vr 的Oculus 客户端在 Win10 上面无法安装或者登陆的解决方法_国韵的博客 - CSDN 博客_oculus 无法连接服务器中国移动的日文 (别问我为什么会参考这个，问就是不会日语)"
  },
  
  {
    "title": "《图解HTTP》读后总结及浅谈",
    "url": "/archives/29",
    "categories": "计算机网络",
    "tags": "HTTP, 读书笔记",
    "date": "2022-03-16 23:56:48 +0800",
    





    
    "snippet": "第一章：了解Web及网络基础1.1简介为理解HTTP应事先了解一下TCP/IP协议族，我们通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作，而HTTP属于它内部的一个子集。在互联网上的设备需要相互通信双方就必须要遵从相同的规则，我们把这些规则称为协议。（TCP/IP是对互联网相关的各类协议族的一个总称包括但不限于：PPPoE、HTTP、TCP、IP、UDP、IEEE 802.3...",
    "content": "第一章：了解Web及网络基础1.1简介为理解HTTP应事先了解一下TCP/IP协议族，我们通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作，而HTTP属于它内部的一个子集。在互联网上的设备需要相互通信双方就必须要遵从相同的规则，我们把这些规则称为协议。（TCP/IP是对互联网相关的各类协议族的一个总称包括但不限于：PPPoE、HTTP、TCP、IP、UDP、IEEE 802.3…）在TCP/IP协议族中按照层次从上到下分为：应用层、传输层、网络层、数据链路层互联网协议套件-维基百科在使用TCP/IP协议族进行通信时，客户端会从应用层往下走，服务端会从链路层往上走。客户端在层与层之间传输数据时，每经过一层时会为其加上该层的段首信息。相反，服务端会一层一层的消去首部。这种把数据信息包装起来的办法叫做封装。1.2 IP、TCP和DNS1.2.1 IP协议IP协议处于网络层，TCP/IP中的IP指的是IP协议，与IP地址并不是一回事。IP协议的作用是把各种数据包发送给对方。各种IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。IP 地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。1.2.2 MAC地址IP之间的通信依赖MAC地址。通常会使用ARP协议来根据通信方的IP地址反查出对应的MAC地址1.2.3 TCP协议按层次分，TCP 位于传输层，提供字节流服务（Byte Stream Service）——为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。一言以蔽之， TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。为了确认数据是否送达到了对方，TCP采用了三次握手策略。握手过程中使用了TCP的标志（flag）——SYN（synchronize）和 ACK（acknowledgement）。1.2.4 负责域名解析的DNS服务计算机既可以被赋予IP地址，也可以被赋予主机名和域名。DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。1.2.5 总结1.3 URL和URI1.3.1 区别与关系与URI（统一资源标识符）相比，我们更熟悉URL（Uniform Resource Locator，统一资源定位符）。URL正是使用Web 浏览器等访问Web 页面时需要输入的网页地址。比如https://www.bilibili.com/就是URL。URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。URI可被视为定位符（URL），名称（URN）或两者兼备。统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法。1.3.2 URI 格式表示指定的URI，要使用涵盖全部必要信息的绝对URI、绝对URL以及相对URL。相对URL，是指从浏览器中基本URI处指定的URL，形如 /image/logo.gif。绝对URI的格式：登录信息（认证）：指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。服务器地址：使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 DNS 可解析的名称，或是192.168.1.1 这类 IPv4 地址 名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。服务器端口号 ：指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。带层次的文件路径 ：指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。查询字符串 ：针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。片段标识符：使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。第二章：简单的HTTP协议2.1 HTTP简介HTTP是一种不保存状态的协议，所谓不保存状态是指HTTP协议自身并不会对每次的请求和响应之间的通信状态进行保存。所以引入了cookie技术来保存通信状态。（注：HTTP这本书出版较早，现在使用保存状态的技术是由cookie、session和token共同实现的）2.2 常用的HTTP方法GET：获取资源GET方法是用来请求URL指定的资源。指定资源经服务器端解析后返回响应内容POST：传输实体主体POST用于向服务器传输数据，和获取的数据过大时也会使用POST方法。GET和POST的区别：先下结论，GET 和 POST 方法没有实质区别，只是报文格式不同。请求参数长度限制：GET请求长度最多1024kb，POST对请求数据没有限制请求参数：GET请求参数是通过URL传递的，多个参数以&amp;连接，POST请求放在request body中。请求缓存：GET请求会被缓存，而POST请求不会，除非手动设置。安全性：POST比GET安全，GET请求在浏览器回退时是无害的，而POST会再次请求。历史记录：GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留。编码方式：GET请求只能进行url编码，而POST支持多种编码方式。对参数的数据类型：GET只接受ASCII字符，而POST没有限制。此外，HTTP还有PUT、HEAD、DELETE等方法在此不细细展开。2.3 HTTP的持久连接（三次握手四次挥手）持久连接的特点是，只要任意一端没 有明确提出断开连接，则保持 TCP 连接状态。三次握手：建立TCP连接 四次挥手：断开TCP连接在持久连接中使用管线化技术可以不用等待响应即可直接发送下一个请求。2.4 使用cookie的状态管理Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。Cookie信息是在服务端产生发送给客户端进行保存的第三章 HTTP报文信息3.1 HTTP的请求和响应报文结构用于HTTP协议交互的信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文。由8位字节流组成，通过HTTP通信传输。请求行：包含用于请求的方法，请求 URI 和 HTTP 版本。状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本。首部字段：包含表示请求和响应的各种条件和属性的各类首部。一般有4种首部，分别是：通用首部、请求首部、响应首部和实体首部。其他：可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。3.2 编码传输及分块传输HTTP在传输数据过程中通过编码提升传输速率。3.2.1 报文主体和实体主体的差异实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。HTTP 报文的主体用于传输请求或响应的实体主体。 通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。3.2.2 分割发送实体主体在HTTP通信过程中传输大容量数据时，通过把数据分割成多块能让浏览器逐步显示页面。把实体主体分块的功能称为分块传输编码。分块传输编码会将实体主体分成多个块。每一块都会用 十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。所谓的块也就是常称的包第四章 返回结果的HTTP状态码4.1 状态码的类别借助状态码用户可以知道服务器是否正常处理了请求，状态码种类繁多但常用的大概只要14种。4.2 2XX 成功4.2.1 200 OK表示从客户端发来的请求在服务器端被正常处理了。在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。4.2.2 204 No Content该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。4.3 3XX 重定向重点介绍一下301重定向和302重定向，还有其他状态码可自行查看4.3.1 301 Moved Permanently301重定向是永久性的重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的 URI。例如像下方给出的请求URI，当指定资源路径的最后忘记添加斜杠 “/”，就会产生 301 状态码。http://excample.com/sample4.3.2 302 Found302重定向是临时性的重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的 URI 访问。和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。4.4 4XX 客户端错误有400 Bad Request、401 Unauthorized、403 Forbidden、404 Not Found。 重点介绍一下404 Not Found4.4.1 404 Not Found该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。4.5 5XX 服务器端错误5XX 的响应结果表明服务器本身发生错误。第五章 Web服务器5.1 通信数据转发程序：代理、网关、隧道5.1.1 代理代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。值得一提的是代理是指对客户端的代理（也称为前向代理），而反向代理是指对服务器的代理。使用代理服务器可以利用缓存技术减少网络宽带的流量，有时也会为了信息安全而使用代理。  缓存代理代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。  反向代理反向代理的优点有很多：  对客户端隐藏服务器（集群）的IP地址  安全：作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等  为后端服务器（集群）统一提供加密和SSL加速（如SSL终端代理）  负载均衡，若服务器集群中有负荷较高者，反向代理通过URL重写，根据连线请求从负荷较低者获取与所需相同的资源或备援  对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务  对一些内容进行压缩，以节约带宽或为网络带宽不佳的网络提供服务5.1.2 网关网关的工作机制和代理十分相似。而网关能使通信线路上的服务器 提供非HTTP协议服务。"
  },
  
  {
    "title": "将MMD模型导入unity",
    "url": "/archives/28",
    "categories": "技术工具",
    "tags": "",
    "date": "2022-03-10 13:15:26 +0800",
    





    
    "snippet": "注意此文章复制自《unity学习笔记》——将MMD模型导入unity，仅用于个人记录使用，部分内容有修改方法1：利用unity插件直接读取fbx模型第一步：安装插件 MMD4Mecanim (Beta)插件地址：Stereoarts Homepage（应插件作者要求请勿上传至GitHub）文件直链：MMD4Mecanim_Beta_20200105.zip第二步：打开unity，双击下载好的...",
    "content": "注意此文章复制自《unity学习笔记》——将MMD模型导入unity，仅用于个人记录使用，部分内容有修改方法1：利用unity插件直接读取fbx模型第一步：安装插件 MMD4Mecanim (Beta)插件地址：Stereoarts Homepage（应插件作者要求请勿上传至GitHub）文件直链：MMD4Mecanim_Beta_20200105.zip第二步：打开unity，双击下载好的插件中 MMD4Mecanim.unitypackage 文件第三步：将MMD模型（全部）文件导入unity选择自动生成的.MMD4Mecanim，点击同意（此时可加动画音乐等）该方法好处是可以最大限度还原MMD本来的渲染效果，而且不用自己重新设置shader，并且不借助unity之外的其他软件方法2：利用Blender插件将MMD模型转为fbx导入第一步：安装blender插件GitHub: cats-blender-plugin该插件可以让blender识别MMD的pmx文件，然后可以根据需要用blender导出成fbx、stl 等格式（fbx为unity可识别的格式）第二步：将导出的fbx模型与原模型的所有材质一起导入unity在导入unity时可能效果或渲染风格会与原来的不一致，需要自己设置shader自己设置shader的好处是可以在unity中统一不同模型的美术风格，或者如果是想图个方便，可以在unity商店下载相应风格的模型，将下载模型的shader应用至导入的MMD模型即可（模型动作也可应用，颜色可以自己改"
  },
  
  {
    "title": "使用PicX自建免费图床",
    "url": "/archives/27",
    "categories": "技术工具",
    "tags": "Github, 图床",
    "date": "2022-02-17 23:02:13 +0800",
    





    
    "snippet": "引言在日常发文章时经常会需要插入图片（虽然我最近文章都没图片），但是如果使用自己服务器比较耗流量并且加载速度不是特别快，这就需要使用图床了，但是多数免费图床会有时不时图没了，速度慢等之类的问题，于是开始探索自建图床。可是如果特意花钱租云服务器托管图片，太贵划不来，使用付费图床多数有流量或空间限制，于是我不经意间发现一项目，一款基于 GitHub API &amp; jsDelivr 开发的具...",
    "content": "引言在日常发文章时经常会需要插入图片（虽然我最近文章都没图片），但是如果使用自己服务器比较耗流量并且加载速度不是特别快，这就需要使用图床了，但是多数免费图床会有时不时图没了，速度慢等之类的问题，于是开始探索自建图床。可是如果特意花钱租云服务器托管图片，太贵划不来，使用付费图床多数有流量或空间限制，于是我不经意间发现一项目，一款基于 GitHub API &amp; jsDelivr 开发的具有 CDN 加速功能的图床管理工具。PicX图床简介官方网站：PicX图床项目地址：XPoet/picx: 基于 GitHub API &amp; jsDelivr 开发的具有 CDN 加速功能的图床管理工具官方文档：快速开始-PicX 图床特点：只需选择一个 GitHub 仓库作为图床，然后在 PicX 官网 完成 Token 绑定和相应配置就能使用了，免下载&amp;安装，如此简单。快速开始首先，新建一个GitHub 仓库点击链接 Create a New RepositoryRepository name填写一个名字(例image-hosting)仓库属性必须选 Public然后，创建一个带有 repo 权限的GitHub Token点击链接 New personal access token填写Note(即名字，例picx-image-hosting)注意： “Expiration”为此Token的有效期，请注意选择如果您过早看到这篇文章没有设置，请参考：使用PicX图床上传图片提示“Bad credentials” – yexca’BlogSelect scopes勾选repo，然后创建Token注意：新生成的 Token 只会显示一次，请妥善保存，如有遗失，重新生成即可。最后，到官网填写Token配置打开PicX官网，进入图床配置，填入Token然后选择仓库和目录方式  新建目录：需手动输入一个新目录。 (使用 / 可创建多级目录，例如：A01/A02 表示创建了二级目录，最大支持创建三级目录。)  根目录：图片将直接存储在仓库根目录下。  自动目录：自动生成日期格式 YYYYMMDD 的目录。例如：20200909。OK，图床已经配置完成，开始使用吧其他设置默认开启图片压缩，可在“我的设置”进行修改"
  },
  
  {
    "title": "将课程表导入日历（树维教务）",
    "url": "/archives/26",
    "categories": "技术工具",
    "tags": "",
    "date": "2022-02-16 17:53:16 +0800",
    





    
    "snippet": "引言由于学校的教务系统查看课程表不是那么便捷，而且第三方课程表有一定的安全隐患并且广告奇多，于是便想着把课程表导入日历，我选择导入Outlook日历，这样可以实现iOS，Windows和Android多端同步。准备工作  一台电脑  一个Android手机  电脑安装chrome浏览器：官网链接  手机安装WakeUp课表：官网链接第一步，导出课程表一、使用chrome打开教务系统网址，进入...",
    "content": "引言由于学校的教务系统查看课程表不是那么便捷，而且第三方课程表有一定的安全隐患并且广告奇多，于是便想着把课程表导入日历，我选择导入Outlook日历，这样可以实现iOS，Windows和Android多端同步。准备工作  一台电脑  一个Android手机  电脑安装chrome浏览器：官网链接  手机安装WakeUp课表：官网链接第一步，导出课程表一、使用chrome打开教务系统网址，进入课表界面二、导出HTML文件首先复制以下代码javascript:void(function(u,s){s=document.body.appendChild(document.createElement('script'));s.src=u+'?ts='+Date.now();s.charset='UTF-8'}('https://the-red-hat-was-uncovered.gitee.io/supwisdom-course-table/dist.js'))然后是添加收藏夹，Windows下快捷键 Ctrl + D按下快捷键后，可以直接点「更多」按钮，来编辑刚添加的收藏，这时候可以改名称和URL（网址），名称起个好记的（比如“WakeUp导出课表”），URL（网址）那里粘贴上刚刚复制的代码！然后再保存。最后点击刚刚收藏的网址（上述），此时浏览器会自动下载“教务.html文件”（即为下一步要用的文件）第二步，导入WakeUp课表一、将上一步导出的文件发送到手机上二、导入课表至WakeUp课表手机打开WakeUp课表，导入新课表（右上第二个），点击“从HTML文件导入”“选择学校/教务类型”选择“树维教务（简易导入）” ，不用选择学校，然后选择文件后点右下角导入完成后注意选择正确开学日期或者当前周数第三步，导入日历在WakeUp课表点右上角第三个导出，选择“导出为ICS（日历用）格式”如果是Android手机可找到文件目录，点击文件，用日历打开即可如果是iOS手机可通过发邮件（带附件）的方式发到手机登录的邮箱，然后点击附件导入参考文章树维教务简易导入"
  },
  
  {
    "title": "查看服务器端口是否开放",
    "url": "/archives/25",
    "categories": "技术工具",
    "tags": "",
    "date": "2022-02-13 19:46:38 +0800",
    





    
    "snippet": "国内工具使用站长工具的端口扫描，输入IP地址或域名和端口后点击开始扫描如果显示关闭，则端口未开放或无法连接工具链接：端口扫描 – 站长工具国外工具使用 you get signal 的 Port Forwarding Tester 进行扫描进入后会自动填写您的IP和80端口，可修改为想要扫描的IP和端口后点击Check如果出现红旗并显示Port ** is closed on ***.***...",
    "content": "国内工具使用站长工具的端口扫描，输入IP地址或域名和端口后点击开始扫描如果显示关闭，则端口未开放或无法连接工具链接：端口扫描 – 站长工具国外工具使用 you get signal 的 Port Forwarding Tester 进行扫描进入后会自动填写您的IP和80端口，可修改为想要扫描的IP和端口后点击Check如果出现红旗并显示Port ** is closed on ***.***.***.***则端口未开放或无法连接工具链接：Open Port Check Tool – Test Port Forwarding on Your Router"
  },
  
  {
    "title": "使用VS Code收发QQ消息",
    "url": "/archives/24",
    "categories": "软件配置",
    "tags": "VS Code",
    "date": "2022-02-11 21:47:56 +0800",
    





    
    "snippet": "引言由于QQ软件过于臃肿并且权限过大，并且经常性卡住无法加载，所以便寻找其他方法，首先是通过Telegram收发QQ消息，但配置较为复杂且并不稳定，于是弃用并改用VS Code。插件简介名称: QQID: takayama.vscode-qq说明: lite qq for chat in working版本: 1.4.2发布者: takayamaVS Marketplace 链接: VS C...",
    "content": "引言由于QQ软件过于臃肿并且权限过大，并且经常性卡住无法加载，所以便寻找其他方法，首先是通过Telegram收发QQ消息，但配置较为复杂且并不稳定，于是弃用并改用VS Code。插件简介名称: QQID: takayama.vscode-qq说明: lite qq for chat in working版本: 1.4.2发布者: takayamaVS Marketplace 链接: VS Code QQ ExtensionGithub项目地址：vscode-qq注：本程序不在本地保存任何消息记录和图片。暂不支持临时会话。安装首先安装 VS Code，访问官网点击 Download 即可下载安装然后访问上述 VS Code QQ Extension 链接点击 Install 即可自动打开VS Code安装或者打开 VS Code 在左侧“拓展”(或按CTRL+SHIFT+X)，然后搜索QQ(注意大写)，点击第一个安装功能按快捷键“CTRL+SHIFT+P”打开命令面板输入“QQ Explorer: Login”（或只输入“login”会显示对应选项）后回车然后根据提示输入账号密码即可登录成功，此时会显示相功能输入“QQ Explorer: 搜索好友”即可搜索好友输入“QQ Explorer: 搜索群”即可搜索群设置在登录成功后控制面板便会有设置，进入设置为json文件编辑，内容如下{  \"account\": ***********, // QQ号码  \"password\": \"********************************\", //QQ密码  \"platform\": 5, //登录平台，可更改“1:手机，3:手表(功能不完整)，4:PC，5:pad(默认)”  \"show_me_add_group_request\": false,  \"theme\": \"default\", // UI主题，可更改“default(默认)和console(控制台风格)”  \"theme_css\": \"\",  \"theme_js\": \"\"}可自定义主题，详情参考：修改/自定义UI主题"
  },
  
  {
    "title": "去除Potplayer右下弹窗",
    "url": "/archives/23",
    "categories": "软件配置",
    "tags": "",
    "date": "2022-02-06 21:37:45 +0800",
    





    
    "snippet": "引言Potplayer是非常优秀的视频播放软件，但最近的版本右下开始有弹窗广告非常的让人困扰，本文讲述两种方法解决右下弹窗使用无弹窗的旧版本（推荐）最后一个无广告弹窗的版本是1.7.18958旧版本的所有PotPlayer都可以在以下地址下载获得：PotPlayer Old Versions Downloads            1.7.18958版本直接下载地址：64位      32...",
    "content": "引言Potplayer是非常优秀的视频播放软件，但最近的版本右下开始有弹窗广告非常的让人困扰，本文讲述两种方法解决右下弹窗使用无弹窗的旧版本（推荐）最后一个无广告弹窗的版本是1.7.18958旧版本的所有PotPlayer都可以在以下地址下载获得：PotPlayer Old Versions Downloads            1.7.18958版本直接下载地址：64位      32位      安装完成后打开设置（F5）可在”基本-自动更新“选择”不使用自动更新“使用绿色版注：此版本使用体验个人感觉不是太好，例如不能靠近吸附，以源文件比例打开等蓝奏云链接 by zdBryan常规运行=安装版（含开始菜单快捷方式和程序卸载项的快捷方式）右键解压=绿色版（本身不提供便携式的软件要手动运行绿化处理）版本特点  1、去效验，去右下角空白广告弹窗！卸载可选备份设置  2、禁止后台联网请求：境外广告、发送日志、检查升级  3、集成额外的音频解码器及视频解码器组件  4、预设配置：常规设置 + 默认启用自定义解码器H.265/HEVC及硬件加速  5、删除TV直播列表, 登陆程序,日志管理, 消息通知, 多语言等不必要的文件参考文章  关于Potplayer右下角弹窗解决方案  PotPlayer v1.7.21589绿色版"
  },
  
  {
    "title": "FIR300M路由器刷固件OpenWRT",
    "url": "/archives/22",
    "categories": "折腾记录",
    "tags": "OpenWRT",
    "date": "2022-02-06 20:44:10 +0800",
    





    
    "snippet": "引言(废话)闲来无事，于是便想要折腾一下路由器当网关（但事后发现这个路由器空间太小，安装不了多少插件，属实是白忙活了一下午）2022.02.17更新：不经意间发现了一个自带网关的FIR300M固件，但由于支持的method过于老旧，如需刷取，请注意辨别。原帖地址：[更新编译方法] FIR300M/FIR302M的Openwrt固件,免拆机刷百度网盘：提取码: vouvOpenWRT简介Ope...",
    "content": "引言(废话)闲来无事，于是便想要折腾一下路由器当网关（但事后发现这个路由器空间太小，安装不了多少插件，属实是白忙活了一下午）2022.02.17更新：不经意间发现了一个自带网关的FIR300M固件，但由于支持的method过于老旧，如需刷取，请注意辨别。原帖地址：[更新编译方法] FIR300M/FIR302M的Openwrt固件,免拆机刷百度网盘：提取码: vouvOpenWRT简介OpenWRT是基于Linux的适用于路由器的系统，有许多强大的插件和较强的可拓展性，并且可以通过SSH进行连接官网：[OpenWrt Wiki] Welcome to the OpenWrt ProjectOpenWRT通用教程：从零开始学习OpenWrt：刷機 + 使用 + 編譯教程准备工作  一、软件HFS  二、适用于FIR300M的OpenWRT固件（百度网盘）  三、电脑开启Telnet服务，参考win10怎么开启telnet服务（win11也可，控制面板可以在设置搜索进入）简要过程  一、登录路由器后台（192.168.1.1）并登录  二、访问 http://192.168.1.1/goform/Diagnosis?pingAddr=192.168.1.100|echo””|telnetd  三、打开cmd，输入：telnet 192.168.1.1  四、把固件传入路由器，等待完成  五、此时进入路由器后台即为OpenWRT（初始无密码，直接登录即可）  六、点击”System-Language and Style”可将语言改为中文详细过程(第四步)打开HFS，将“准备工作”第二步下的固件改名“1.bin”拖入窗口在cmd输入命令“telnet 192.168.1.1”并成功连接后依次输入以下命令cd /tmpwget http://192.168.1.100/1.bin  //“192.168.1.100”替换为您的机器IPmtd_write -r write 1.bin Kernel  （注意，这里的K是大写）执行成功后路由器会自动重启，所以会显示“断开连接”插件安装在OpenWRT管理后台点击“系统-软件包”即可安装相应插件建议上Github寻找相应插件，当然也可以自行编写因安装插件需要网络地址，可以直接复制Github相应项目Release下ipk包链接自己编写如何安装？您都会自己编写了还不会这个？（doge）注意插件安装需要与路由器相兼容，部分插件可能需要环境依赖，即需要先安装其他插件具体可以通过报错信息进行判断参考文章  FIR300M免拆机刷Openwrt教程  路由器刷固件——斐讯路由器FIR300M刷OpenWrt固件教程  HFS – 超好用的本地文件分享利器，快速从电脑传文件到手机等设备  许迎果 第215期 OpenWrt插件的安装与卸载"
  },
  
  {
    "title": "在Microsoft Word中插入代码（高亮）",
    "url": "/archives/21",
    "categories": "软件配置",
    "tags": "",
    "date": "2022-01-20 14:28:52 +0800",
    





    
    "snippet": "引言(废话)有些时候会有在Word文档中插入代码的需求，但是直接把代码拷贝过去会不大美观，而且没有高亮看着也非常难受工具一CodeInWord 在word中优雅展现的代码/代码高亮/word中插入代码/代码格式化工具二Syntax Highlight Code In Microsoft Word使用说明没什么要说明的，把代码复制过去，选择相应语言，点击生成再复制到Word中即可附录如果以上网...",
    "content": "引言(废话)有些时候会有在Word文档中插入代码的需求，但是直接把代码拷贝过去会不大美观，而且没有高亮看着也非常难受工具一CodeInWord 在word中优雅展现的代码/代码高亮/word中插入代码/代码格式化工具二Syntax Highlight Code In Microsoft Word使用说明没什么要说明的，把代码复制过去，选择相应语言，点击生成再复制到Word中即可附录如果以上网站不可以使用，可在搜索引擎搜索”syntax highlight code in word“参考文章如何优雅的在 Microsoft word中插入代码"
  },
  
  {
    "title": "转区软件Locale Emulator",
    "url": "/archives/20",
    "categories": "技术工具",
    "tags": "",
    "date": "2022-01-14 15:53:40 +0800",
    





    
    "snippet": "前言在游玩外区一些小游戏时，常常会由于乱码而不能游玩或者报错无法运行，此时需要转区以匹配正确文字虽然可以通过修改Windows的地区设置以运行，但很多时候此方法略显繁琐，并且需要重启电脑，游玩后如果不改回则可能导致正常软件无法使用，此时便需要相关转区软件软件获取软件官网：Locale EmulatorGitHub项目地址(releases)：Locale Emulator – GitHub配...",
    "content": "前言在游玩外区一些小游戏时，常常会由于乱码而不能游玩或者报错无法运行，此时需要转区以匹配正确文字虽然可以通过修改Windows的地区设置以运行，但很多时候此方法略显繁琐，并且需要重启电脑，游玩后如果不改回则可能导致正常软件无法使用，此时便需要相关转区软件软件获取软件官网：Locale EmulatorGitHub项目地址(releases)：Locale Emulator – GitHub配置说明下载解压后点击“LEInstaller”根据需要为当前用户或所有用户安装安装完成后点击“LEGUI”配置转区环境(如果游玩日本游戏则不需要，默认会自动配置)使用说明找到待打开的游戏，右击运行文件(.exe)然后选择Locale Emulator，然后选择相应环境运行(如果是Win11，请点击“显示更多选项”)废话仅作记录以自用，官网就有使用说明"
  },
  
  {
    "title": "Linux服务器（网络相关）",
    "url": "/archives/19",
    "categories": "Linux",
    "tags": "",
    "date": "2022-01-14 01:30:54 +0800",
    





    
    "snippet": "背景知识：linux时钟概述linux系统有两个时钟：一个是硬件时钟，即BIOS时间；另一个是系统时钟，是linux系统Kernel（内核）时间。在linux系统上程序运行时读取的时间都是系统Kernel（内核）时间。每次Linux启动时，系统Kernel（内核）会先去读取硬件时钟的设置（但是此时的硬件时间不一定是准确的），然后系统时钟就会独立于硬件继续运作。综上所述，所以想要永久修改lin...",
    "content": "背景知识：linux时钟概述linux系统有两个时钟：一个是硬件时钟，即BIOS时间；另一个是系统时钟，是linux系统Kernel（内核）时间。在linux系统上程序运行时读取的时间都是系统Kernel（内核）时间。每次Linux启动时，系统Kernel（内核）会先去读取硬件时钟的设置（但是此时的硬件时间不一定是准确的），然后系统时钟就会独立于硬件继续运作。综上所述，所以想要永久修改linux时间并使得时间准确，就需要永久修改硬件时间，不然每次重新启动linux时，系统时间又变回之前的硬件时间。linux时钟相关命令系统Kernel（内核）时钟的相关命令是timedatectl 或者 date；硬件BIOS时钟相关命令是hwclock 或者 clock。1.在Linux GLI界面输入data查看当前Linux系统时间data输入hwclock –show查看硬件时间hwclock --show2.校准Linux系统时间（使用ntp服务时需要系统联网）  CentOS 下安装配置ntp服务的步骤如下：# 安装ntp服务的软件包sudo yum install ntp# 将ntp服务设置为缺省启动sudo chkconfig ntp on# 修改启动参数，增加-g -x参数，允许ntp服务在系统时间误差较大时也能正常工作sudo vi /etc/sysconfig/ntpd# 启动ntp服务sudo service ntpd restart  Ubuntu/Debian下安装配置ntp服务的步骤如下：# 安装ntp服务的软件包sudo apt-get install ntp# 修改启动参数，增加-g -x参数，允许ntp服务在系统时间误差较大时也能正常工作sudo vi /etc/default/ntp# 启动ntp服务sudo service ntp restart  将硬件时钟调整为与系统时钟一致hwclock --systohc --localtime (好像这个更有效)# 或者timedatectl set-local-rtc 1     最后将日期写入CMOS永久生效clock -w# 或者hwclock -w3.开启谷歌BBR加速本文的系统要求为 Debian 9或更高版本的 Debian Linux，其它操作系统所知不详，不知是否适合本文的方法。注意，本文的配置参数不仅仅是启用Google BBR，还包括一系列网络参数的优化，直接拷贝执行使用即可。Google BBR 一键加速VPS服务器很简单，SSH登录VPS后，分别执行以下2个命令即可（鼠标选中高亮后，点鼠标右键复制粘贴到root用户的#后面，然后回车）。命令1：wget https://raw.githubusercontent.com/bannedbook/fanqiang/master/v2ss/server-cfg/sysctl.conf -O -&gt; /etc/sysctl.con  如果提示 wget: command not found 的错误，这是因为你的系统wget没有安装，所以需要安先装 wget:&lt;strong&gt;apt-get install -y wget&lt;/strong&gt;命令2：sysctl -p执行成功后大致会输出：（视个人情况而言）fs.file-max = 51200net.ipv4.conf.lo.accept_redirects = 0net.ipv4.conf.all.accept_redirects = 0net.ipv4.conf.default.accept_redirects = 0net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_fin_timeout = 15net.ipv4.tcp_fastopen = 3net.ipv4.tcp_keepalive_time = 1200net.ipv4.tcp_rmem = 32768 436600 873200net.ipv4.tcp_syncookies = 1net.ipv4.tcp_synack_retries = 2net.ipv4.tcp_syn_retries = 2net.ipv4.tcp_timestamps = 0net.ipv4.tcp_max_tw_buckets = 9000net.ipv4.tcp_max_syn_backlog = 65536net.ipv4.tcp_mem = 94500000 91500000 92700000net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_mtu_probing = 1net.ipv4.tcp_wmem = 8192 436600 873200net.core.netdev_max_backlog = 250000net.core.somaxconn = 32768net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 67108864net.core.wmem_max = 67108864net.ipv4.tcp_congestion_control = bbr"
  },
  
  {
    "title": "使用xshell连接虚拟机的centos7系统",
    "url": "/archives/18",
    "categories": "Linux",
    "tags": "",
    "date": "2021-12-26 15:34:59 +0800",
    





    
    "snippet": "注意：此方法为临时连接，虚拟机重启或关机需要重新配置虚拟机网络适配器设置虚拟机的网络适配器一共有三个设置  桥接模式：指使用本机网络网段  NAT模式：使用VMware Network Adapter VMnet8的网段  Host-only(仅主机模式)：使用VMware Network Adapter VMnet1的网段查看IP网段打开VMware中左上“编辑-虚拟网络编辑器”即可看到V...",
    "content": "注意：此方法为临时连接，虚拟机重启或关机需要重新配置虚拟机网络适配器设置虚拟机的网络适配器一共有三个设置  桥接模式：指使用本机网络网段  NAT模式：使用VMware Network Adapter VMnet8的网段  Host-only(仅主机模式)：使用VMware Network Adapter VMnet1的网段查看IP网段打开VMware中左上“编辑-虚拟网络编辑器”即可看到VMnet1和VMnet8对应网段地址(子网地址)桥接模式的网段需要打开“设置-网络和Internet-高级网络设置”找到相应的本机连接的网络  如果使用WiFi连接，点击“WLAN-查看其他属性”即可看到IP地址  如果使用有线连接，点击“以太网-查看其他属性”即可看到IP地址注意：如果本机连接了以太网和WIFI，则可能需要对VMware中左上“编辑-虚拟网络编辑器” 进行相关设置需要给VMware管理员权限，如图示选择想要VMware连接的网卡设置虚拟机的IP地址注：我使用的是桥接模式，我的本机IP为192.168.1.116，那么我可以将虚拟机设置为192.168.1.0-192.168.1.255中任意一个(除192.168.1.116)，即前三段一样，最后一段不一样即可首先，打开虚拟机并登录root用户，输入“ifconfig”命令查看网卡配置如果如图出现“ens33”和“lo”或者“其他”和“lo”输入命令# ifconfig 设备名(本例为\"ens33\") 要分配的地址(这里选择的是192.168.1.110)ifconfig ens33 192.168.1.110如果仅出现“lo”输入命令# ifconfig 设备名(一般为\"eth0\") 要分配的地址(这里选择的是192.168.1.110)ifconfig eth0 192.168.1.110配置完成后，可再次输入“ifconfig”命令查看网卡配置如上图IP成功改为192.168.1.110可以打开“Windows终端”，输入“ping 192.168.1.110”查看是否生效如图即可表示IP修改成功并可访问使用Xshell连接打开Xshell，点击“新建”，名称可自行决定，主机填写IP，然后点击“连接”选择“接受并保存”，然后跟随提示输入用户名(root)和密码即可"
  },
  
  {
    "title": "数据结构 栈代码",
    "url": "/archives/17",
    "categories": "数据结构",
    "tags": "c/c++",
    "date": "2021-11-21 22:19:04 +0800",
    





    
    "snippet": "顺序栈（数组实现）#include &lt;stdio.h&gt;//元素elem进栈，a为数组，top值为当前栈的栈顶位置int push(int* a,int top,int elem){    a[++top]=elem;    return top;}//数据元素出栈int pop(int * a,int top){    if (top==-1)     {        prin...",
    "content": "顺序栈（数组实现）#include &lt;stdio.h&gt;//元素elem进栈，a为数组，top值为当前栈的栈顶位置int push(int* a,int top,int elem){    a[++top]=elem;    return top;}//数据元素出栈int pop(int * a,int top){    if (top==-1)     {        printf(\"空栈\");        return -1;    }    printf(\"弹栈元素：%d\\n\",a[top]);    top--;    return top;}int main(void) {    int a[100];    int top=-1;    top = push(a, top, 1);    top = push(a, top, 2);    top = push(a, top, 3);    top = push(a, top, 4);    top = pop(a, top);    top = pop(a, top);    top = pop(a, top);    top = pop(a, top);    top = pop(a, top);        return 0;}输出结果：弹栈元素：4弹栈元素：3弹栈元素：2弹栈元素：1空栈链栈#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct lineStack{    int data;    struct lineStack * next;}lineStack;//stack为当前的链栈，a表示入栈元素lineStack* push(lineStack * stack,int a){    //创建存储新元素的节点    lineStack * line=(lineStack*)malloc(sizeof(lineStack));    line-&gt;data=a;    //新节点与头节点建立逻辑关系    line-&gt;next=stack;    //更新头指针的指向    stack=line;    return stack;}//栈顶元素出链栈的实现函数lineStack * pop(lineStack * stack){    if (stack)     {        //声明一个新指针指向栈顶节点        lineStack * p=stack;        //更新头指针        stack=stack-&gt;next;        printf(\"出栈元素：%d \",p-&gt;data);        if (stack)         {            printf(\"新栈顶元素：%d\\n\",stack-&gt;data);        }        else        {            printf(\"栈已空\\n\");        }        free(p);    }    else    {        printf(\"栈内没有元素\");        return stack;    }    return stack;}int main(void) {    lineStack * stack=NULL;    stack=push(stack, 1);    stack=push(stack, 2);    stack=push(stack, 3);    stack=push(stack, 4);    stack=pop(stack);    stack=pop(stack);    stack=pop(stack);    stack=pop(stack);    stack=pop(stack);        return 0;}输出结果：弹栈元素：4 栈顶元素：3弹栈元素：3 栈顶元素：2弹栈元素：2 栈顶元素：1弹栈元素：1 栈已空栈内没有元素"
  },
  
  {
    "title": "数据结构 顺序表代码",
    "url": "/archives/16",
    "categories": "数据结构",
    "tags": "c/c++",
    "date": "2021-11-20 23:01:47 +0800",
    





    
    "snippet": "#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //malloc()、exit()#define Size 5  //对Size进行宏定义，表示顺序表申请空间的大小typedef struct Table{    int * head; //声明了一个名为head的长度不确定的数组，也叫“动态数组”    int length; //记录当...",
    "content": "#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //malloc()、exit()#define Size 5  //对Size进行宏定义，表示顺序表申请空间的大小typedef struct Table{    int * head; //声明了一个名为head的长度不确定的数组，也叫“动态数组”    int length; //记录当前顺序表的长度    int size;   //记录顺序表分配的存储容量}table;// 初始化函数table initTable(){    table t;    t.head = (int*)malloc(Size * sizeof(int));  //构造一个空的顺序表，动态申请存储空间    if (!t.head)    //如果申请失败，作出提示并直接退出程序    {        printf(\"初始化失败\");        exit(0);    }    t.length = 0;   //空表的长度初始化为0    t.size = Size;  //空表的初始存储空间为Size    return t;}//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置table addTable(table t, int elem, int add){    int i;    //判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出）    if (add &gt; t.length + 1 || add &lt; 1)     {        printf(\"插入位置有问题\");        return t;    }    //做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请    if (t.length == t.size)     {        t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int));        if (!t.head)         {            printf(\"存储分配失败\");            return t;        }        t.size += 1;    }    //插入操作，需要将从插入位置开始的后续元素，逐个后移    for (i = t.length - 1; i &gt;= add - 1; i--)     {        t.head[i + 1] = t.head[i];    }    //后移完成后，直接将所需插入元素，添加到顺序表的相应位置    t.head[add - 1] = elem;    //由于添加了元素，所以长度+1    t.length++;        return t;}// 删除函数table delTable(table t, int add) {    int i;    if (add &gt; t.length || add &lt; 1)     {        printf(\"被删除元素的位置有误\");        exit(0);    }    for (i = add; i &lt; t.length; i++)     {        t.head[i - 1] = t.head[i];    }    t.length--;    return t;}//查找函数，其中，elem表示要查找的数据元素的值int selectTable(table t, int elem) {    int i;        for (i = 0; i &lt; t.length; i++)     {        if (t.head[i] == elem)         {            return i + 1;        }    }    return -1;}//更改函数，其中，elem为要更改的元素，newElem为新的数据元素table amendTable(table t, int elem, int newElem) {    int add = selectTable(t, elem);    t.head[add - 1] = newElem;    return t;}//输出顺序表中元素的函数void displayTable(table t) {    int i;    for (i = 0; i &lt; t.length; i++)     {        printf(\"%d \", t.head[i]);    }    printf(\"\\n\");}int main() {    int i, add;    table t1 = initTable();    //向顺序表中添加元素    for (i = 1; i &lt;= Size; i++)     {        t1.head[i - 1] = i;        t1.length++;    }    printf(\"原顺序表：\\n\");    displayTable(t1);    printf(\"删除元素1:\\n\");    t1 = delTable(t1, 1);    displayTable(t1);    printf(\"在第2的位置插入元素5:\\n\");    t1 = addTable(t1, 5, 2);    displayTable(t1);    printf(\"查找元素3的位置:\\n\");    add = selectTable(t1, 3);    printf(\"%d\\n\", add);        printf(\"将元素3改为6:\\n\");    t1 = amendTable(t1, 3, 6);    displayTable(t1);    return 0;}程序运行结果为：原顺序表：1 2 3 4 5删除元素1:2 3 4 5在第2的位置插入元素5:2 5 3 4 5查找元素3的位置:3将元素3改为6:2 5 6 4 5"
  },
  
  {
    "title": "数据结构 链表代码",
    "url": "/archives/15",
    "categories": "数据结构",
    "tags": "c/c++",
    "date": "2021-11-17 12:00:49 +0800",
    





    
    "snippet": "简单链表#include &lt;stdio.h&gt; struct student{    long num;    float score;    struct student *next;}; void main(){    struct student a, b, c, *head, *p;    a.num = 99101; a.score = 89.5;    b.num = ...",
    "content": "简单链表#include &lt;stdio.h&gt; struct student{    long num;    float score;    struct student *next;}; void main(){    struct student a, b, c, *head, *p;    a.num = 99101; a.score = 89.5;    b.num = 99103; b.score = 90;    c.num = 99107; c.score = 85;//对结点的 num 和 score 成员赋值    head = &amp;a;//将结点 a 的起始地址赋给头指针 head    a.next = &amp;b;//将结点 b 的起始地址赋给 a 结点的 next 成员    b.next = &amp;c;    c.next = NULL;// c 结点的 next 成员不存放其他结点地址    p = head;//使 p 指针指向 a 结点    do    {        printf(\"%ld %5.1f\\n\", p-&gt;num, p-&gt;score);// 输出 p 指向的结点的数据        p = p-&gt;next;//使 p 指向下一结点    }while(p != NULL);//输出完 c 结点后 p 的值为 NULL    system(\"pause\");}内存分配函数（1）malloc 函数void *malloc(unsigned int size);作用是在内存的动态存储区中分配一个长度为 size 的连接空间。些函数的值（即返回值）是一个指向分配空间起始地址的指针（基类型为 void）。如果些函数未能成功地执行（例如内存空间不足）则返回空指针 NULL。（2）calloc 函数void *calloc(unsigned n, unsigned size);其作用是在内存的动态区存储中分配 n 个长度为 size 的连续空间。函数返回一个指向分配空间起始地址的指针，如果分配不成功，返回 NULL。 用 calloc 函数可以为一维数组开辟动态存储空间， n 为数组元素个数，每个元素长度为 size。（3）free 函数void free(void *p);其作用是释放由 p 指向的内存区，使这部分内存区能被其它变量使用， p 是最后一次调用 calloc 或 malloc 函数时返回的值。free 函数无返回值。请注意：以前的C版本提供的 malloc 和 calloc 函数得到的是指向字符型数据的指针。ANSI C 提供的 malloc 和 calloc 函数规定为 void * 类型。动态链表的实现#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #define NULL 0#define LEN sizeof(struct student)struct student{    long num;    float score;    struct student *next;}; struct student *create(){    struct student *p1, *p2, *head;    int num;    float score;    int n = 0;     head = NULL;     p1 = p2 = (struct student *)malloc(LEN);     printf(\"please input num and score.\\n\");    scanf(\"%d,%f\", &amp;p1-&gt;num, &amp;p1-&gt;score);     while(p1-&gt;num != 0)    {        n ++;        if(n == 1)            head = p1;        else            p2-&gt;next = p1;        p2 = p1;        p1 = (struct student *)malloc(sizeof(struct student));         printf(\"please input num and score.\\n\");         scanf(\"%d,%f\", &amp;p1-&gt;num, &amp;p1-&gt;score);    }    p2-&gt;next = NULL;    return head;} void printlist(struct student *head){    struct student *p;    p = head;    if(head != NULL)    {        do        {            printf(\"num=%d score=%f\\n\", p-&gt;num, p-&gt;score);            p = p-&gt;next;        }while(p != NULL);    }} void main(){    struct student *head;    head = create();    printlist(head);    system(\"pause\");}// 打印链表void printlist(struct student *head){    struct student *p;    p = head;    if(head != NULL)    {        do         {            printf(\"num=%d score=%5.2f\\n\", p-&gt;num, p-&gt;score);            p = p-&gt;next;        } while (p != NULL);    }    /* while(p -&gt; next != NULL)    {        printf(\"num=%d score=%f\\n\", p-&gt;num, p-&gt;score);        p = p-&gt;next;    }*/}// 删除节点struct student *delNode(struct student *head, int num){    printf(\"delNode.\\n\");    struct student *p1, *p2;    if(head == NULL)    {        printf(\"The List is NULL.\\n\");    }    else    {        p1 = head;        while(p1-&gt;next != NULL &amp;&amp; p1-&gt;num != num)        {            p2 = p1;            p1 = p1-&gt;next;        }        if(p1-&gt;num == num)        {            if(p1 == head)                head = p1-&gt;next;            else                p2-&gt;next = p1-&gt;next;        }        else            printf(\"Can not find list num.\\n\");    }    return head;}// 更新节点struct student *update(struct student *head, int index, int num, float score){    printf(\"update.\\n\");    struct student *p;    if(head == NULL)    {        printf(\"The List is NULL.\\n\");    }    else    {        p = head;        while(p-&gt;next != NULL &amp;&amp; p-&gt;num != index)        {            p = p-&gt;next;        }        if(p-&gt;num == index)        {            p-&gt;num = num;            p-&gt;score = score;        }        else            printf(\"Can not find list index.\\n\");    }    return head;}// 增加节点struct student *add(struct student *head, int index, int num, float score){    printf(\"add.\\n\");    struct student *p1, *p2, *p3;    if(head == NULL)    {        printf(\"The List is NULL.\\n\");    }    else    {        p1 = p2 = head;        while(p1-&gt;next != NULL &amp;&amp; p1-&gt;num != index)        {            p1 = p1-&gt;next;            p2 = p1;        }        if(p1-&gt;num == index)        {            p3 = (struct student *)malloc(LEN);            p3-&gt;num = num;            p3-&gt;score = score;            if(p2-&gt;next == NULL)            {                p2-&gt;next = p3;                p3-&gt;next = NULL;            }            else            {                p3-&gt;next = p2-&gt;next;                p2-&gt;next = p3;               }        }        else            printf(\"Can not find list index.\\n\");    }    return head;}"
  },
  
  {
    "title": "C 数据结构代码（持续更新中）",
    "url": "/archives/14",
    "categories": "数据结构",
    "tags": "c/c++",
    "date": "2021-11-11 23:03:27 +0800",
    





    
    "snippet": "//数组栈的实现#include&lt;stdio.h&gt; #define MaxSize 50 typedef struct Stack_Array{\tint data[MaxSize];\tint top;}Sqstack,*pSqstack; void Initstack();\t\t\t\t\t//初始化int Isempty();\t\t\t\t\t\t//判断栈空int Push();\t\t\t\t\t\t/...",
    "content": "//数组栈的实现#include&lt;stdio.h&gt; #define MaxSize 50 typedef struct Stack_Array{\tint data[MaxSize];\tint top;}Sqstack,*pSqstack; void Initstack();\t\t\t\t\t//初始化int Isempty();\t\t\t\t\t\t//判断栈空int Push();\t\t\t\t\t\t//入栈int Pop();\t\t\t\t\t\t//出栈int Gettop();\t\t\t\t\t\t//get栈顶元素 int main(void)\t\t\t\t\t\t//测试{\tint val;\tSqstack s1;\tpSqstack ps1=&amp;s1;\tInitstack(&amp;s1);\t\t\t\t\t//初始化 \tif(Isempty(&amp;s1))\t\t\t\t//判断栈空\t\tprintf(\"栈为空！\\n\");\telse printf(\"栈不为空！\\n\"); \tprintf(\"输入压栈元素的值\");\t\t//压栈1\tscanf(\"%d\",&amp;val);\tPush (ps1,&amp;val); \tprintf(\"输入压栈元素的值\");\t\t//压栈2\tscanf(\"%d\",&amp;val);\tPush (ps1,&amp;val); \tif(Isempty(ps1))\t\t\t\t//判断栈空\t\tprintf(\"栈为空！\\n\");\telse printf(\"栈不为空！\\n\"); \tif(Gettop(ps1,&amp;val))\t\t\t//GET栈顶元素\t\tprintf(\"栈顶值为%d\\n\",val);\telse printf(\"栈顶元素查找失败！\\n\"); \tif(Pop(ps1,&amp;val))\t\t\t\t//出栈\t\tprintf(\"出栈成功，出栈元素为%d\\n\",val);\telse printf(\"出栈失败！\\n\"); \treturn 0;}//初始化void Initstack (pSqstack ps1){\tps1-&gt;top=-1;\treturn;}//判断栈空int Isempty(pSqstack ps1){\tif(ps1-&gt;top==-1)\t\treturn 1;\telse return 0;}//若栈不满，则进行压栈int Push(pSqstack ps1,int *val)//*val:接受一个地址(int *(&amp;val)){\tif(ps1-&gt;top==MaxSize)\t\treturn 0;\telse\t{\t\tps1-&gt;top++;\t\tps1-&gt;data[ps1-&gt;top]=*val;//这里传递的是值，这里的*val是*(&amp;val),&amp;val是由主调函数输入                //也可写作ps1-&gt;data[++ps1-&gt;top]=*val; 一定是++ps1-&gt;top\t\treturn 1;\t}}//若栈不空，则进行出栈，用val返回栈顶元素int\tPop(pSqstack ps1,int *val){\tif(Isempty(ps1))\t\treturn 0;\telse\t{\t\t*val=ps1-&gt;data[ps1-&gt;top--];\t\treturn 1;\t}}//get栈顶元素，用val返回栈顶元素int Gettop(pSqstack ps1,int *val){\tif(Isempty(ps1))\t\treturn 0;\telse \t{\t\t*val=ps1-&gt;data[ps1-&gt;top];\t\treturn 1;\t}}图解简化//栈的链式存储实现#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define Stack_Init_Size 10 // 初始化栈的最大长度#define StackIncrement 10 // 若栈最大空间不够时，需要增加的长度typedef int ElemType;typedef int Status;typedef struct {    ElemType *base; // 栈底指针    ElemType *top; // 栈顶指针    int stack_size; // 栈的最大长度} SqStack;// 初始化栈Status InitStack(SqStack *S) {    // 分配初始空间    S-&gt;base = (ElemType *) malloc(Stack_Init_Size * sizeof(ElemType));    if (!S-&gt;base) {        exit(0);    }    S-&gt;top = S-&gt;base; /// 栈顶与栈底相同    S-&gt;stack_size = Stack_Init_Size; // 栈的最大长度等于初始长度    return 1;}// 判断栈是否为空，只需要判断栈顶指针与栈底指针是否相同即可Status EmptyStack(SqStack *S) {    return S-&gt;base == S-&gt;top;}// 获取栈的实际长度，栈顶减去栈底指针即为栈的长度Status LengthStack(SqStack *S) {    if (S-&gt;top == S-&gt;base) {        return 0;    }    return (Status) (S-&gt;top - S-&gt;base);}// 获取栈顶的元素，参数e用来存放栈顶的元素Status GetTopStack(SqStack *S, ElemType *e) {    if (S-&gt;top == S-&gt;base) {        return 0;    }     *e = *(S-&gt;top - 1);    return 1;}// 进栈，参数e是要进栈的元素Status PushStack(SqStack *S, ElemType e) {    // 若栈的最大长度不会够用时，重新开辟，增大长度    if (S-&gt;top - S-&gt;base &gt;= S-&gt;stack_size) {        S-&gt;base = (ElemType *)realloc(S-&gt;base, (S-&gt;stack_size + StackIncrement) * sizeof(ElemType));        if (!S-&gt;base) {            return 0;        }        // 栈顶指针为栈底指针加上栈之前的最大长度        S-&gt;top = S-&gt;base + S-&gt;stack_size;        // 栈当前的最大长度等于栈之前的最大长度与增加的长度之和        S-&gt;stack_size += StackIncrement;    }    *S-&gt;top++ = e; // 先赋值，后栈顶指针上移    return 1;}// 出栈，参数e用来存放出栈的元素Status PopStack(SqStack *S, ElemType *e) {    if (S-&gt;base == S-&gt;top) {        return 0;    }    *e = *--S-&gt;top; // 栈顶指针先下移，后赋值    return 1;}// 销毁栈，释放栈空间，栈顶栈底指针置为NULL，长度置为0Status DestroyStack(SqStack *S) {    free(S-&gt;base);    S-&gt;base = S-&gt;top = NULL;    S-&gt;stack_size = 0;    return 1;}// 遍历栈，依次打印每个元素Status StackTraverse(SqStack *S) {    ElemType *p;    if (S-&gt;top == S-&gt;base) {        printf(\"Stack is NULL.\\n\");        return 0;    }    p = S-&gt;top;    // 由栈顶依次向下遍历    while (p &gt; S-&gt;base) {        p--;        printf(\"%d \", *p);    }    printf(\"\\n\");    return 1;}int main() {    SqStack q, *S;    S = &amp;q;    int i, n, e;    printf(\"Creat a NULL Stack :\\n\");    InitStack(S);    printf(\"input the length of the Stack :\\n\");    scanf(\"%d\", &amp;n);    for (i = 1; i &lt;= n; i++) {        scanf(\"%d\", &amp;e);        PushStack(S, e);    }    printf(\"Is the stack NULL?\\n\");    if (EmptyStack(S)) {        printf(\"Yes!\\n\");    } else {        printf(\"No!\\n\");    }    printf(\"The length of stack is %d.\\n\", LengthStack(S));    printf(\"The stack is :\\n\");    StackTraverse(S);    e = GetTopStack(S, &amp;e);    printf(\"The top data is %d.\\n\", e);    printf(\"input the data to the stack :\\n\");    scanf(\"%d\", &amp;e);    PushStack(S, e);    printf(\"The new stack is :\\n\");    StackTraverse(S);    printf(\"Delete the top data : \");    e = PopStack(S, &amp;e);    printf(\"%d\\n\", e);    printf(\"The new stack is :\\n\");    StackTraverse(S);    printf(\"Destroy the stack :\\n\");    DestroyStack(S);    StackTraverse(S);    return 0;}"
  },
  
  {
    "title": "扬州杏雨后",
    "url": "/archives/13",
    "categories": "小说",
    "tags": "",
    "date": "2021-11-11 18:01:33 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "原神树脂查看/推送",
    "url": "/archives/12",
    "categories": "技术工具",
    "tags": "miHoYo",
    "date": "2021-11-10 15:21:30 +0800",
    





    
    "snippet": "虽然米忽悠的米游社提供了原神树脂的查看，但是使用电脑时每次查看还要打开手机然后打开米游社着实有亿点不方便原作者文章：自己做了一个树脂记录软件原文软件链接：提取码：1w5b下载完成后打开，会提示输入uid和cookie，下面是如何抓取米游社的cookie首先打开米游社并登录然后按F12打开开发者工具，这时刷新网页然后点击“网络-ys/”，找到请求标头，然后在cookie右击复制注意：需要的co...",
    "content": "虽然米忽悠的米游社提供了原神树脂的查看，但是使用电脑时每次查看还要打开手机然后打开米游社着实有亿点不方便原作者文章：自己做了一个树脂记录软件原文软件链接：提取码：1w5b下载完成后打开，会提示输入uid和cookie，下面是如何抓取米游社的cookie首先打开米游社并登录然后按F12打开开发者工具，这时刷新网页然后点击“网络-ys/”，找到请求标头，然后在cookie右击复制注意：需要的cookie字段为account_id=xxx; cookie_token=xxx ，请自行修改**2022/6/6修改(hiyoung)**由于米哈游修改了bbs可以获取的Cookie，导致一次获取的Cookie缺失，所以需要增加步骤按下键盘上的F12或右键检查,打开开发者工具,点击Console输入var cookie=document.cookie;var ask=confirm('Cookie:'+cookie+'\\n\\nDo you want to copy the cookie to the clipboard?');if(ask==true){copy(cookie);msg=cookie}else{msg='Cancel'}回车执行，并在确认无误后点击确定。此时Cookie已经复制到你的粘贴板上了注意：请使用Chrome，Edge获取也是不完整的(yexca)"
  },
  
  {
    "title": "微博视频下载",
    "url": "/archives/11",
    "categories": "技术工具",
    "tags": "微博",
    "date": "2021-11-10 11:29:51 +0800",
    





    
    "snippet": "首先我们找到要下载的视频（废话），复制图中框选部分的链接然后打开视频下载解析网站，输入复制的链接然后点击解析视频图片（如需验证根据网站提示进行即可）然后点击下载视频即可// 这篇好水",
    "content": "首先我们找到要下载的视频（废话），复制图中框选部分的链接然后打开视频下载解析网站，输入复制的链接然后点击解析视频图片（如需验证根据网站提示进行即可）然后点击下载视频即可// 这篇好水"
  },
  
  {
    "title": "WordPress添加返回上一页按钮",
    "url": "/archives/10",
    "categories": "网站建设",
    "tags": "WordPress",
    "date": "2021-11-10 11:06:27 +0800",
    





    
    "snippet": "多数情况下，我们浏览网页一般使用浏览器或系统自带的返回，但有些系统的交互逻辑及其不好用，这时在网页添加一个返回上一页按钮可以极大改善浏览体验首先，在WordPress的后台点击“外观-自定义”来到可视化编辑页面在左方找到“额外CSS”选项（一般在最后）然后在里面输入下方代码.float-button {position: fixed;height: 90px;width: 40px;bott...",
    "content": "多数情况下，我们浏览网页一般使用浏览器或系统自带的返回，但有些系统的交互逻辑及其不好用，这时在网页添加一个返回上一页按钮可以极大改善浏览体验首先，在WordPress的后台点击“外观-自定义”来到可视化编辑页面在左方找到“额外CSS”选项（一般在最后）然后在里面输入下方代码.float-button {position: fixed;height: 90px;width: 40px;bottom: 90px;right: 50px;&lt;!-- 可以自己修改相关描述 --&gt;}输入完成后保存，然后编辑主题相关界面如果您不能访问服务器文件，可以在WordPress后台的“外观-主题编辑器”中找到要添加的界面修改如果您可以访问服务器文件，可以打开路径“&lt;&gt;网站根目录/wp-content/themes/&lt;您的主题名&gt;/”然后打开相应页面修改只需在相关页面文件插入下面代码并保存即可&lt;div class=\"float-button\"&gt;&lt;input type=\"button\" name=\"Submit\" value=\"返回\" onclick=\"javascript:history.back(-1);\"&gt;&lt;/div&gt;&lt;!-- 可以自己修改相关描述 --&gt;参考文章：网页上的“返回上一页”的几种实现代码div套路之悬浮的button"
  },
  
  {
    "title": "Win11官方安卓子系统安装",
    "url": "/archives/9",
    "categories": "技术工具",
    "tags": "Windows",
    "date": "2021-11-09 23:45:42 +0800",
    





    
    "snippet": "准备条件：win11专业版及以上，将系统地区调至美国在设置-&gt;应用 -&gt; 可选功能 -&gt; 更多Windows功能中勾选虚拟机平台，然后重启系统即可然后下载安装包，链接: https://pan.baidu.com/s/1215GlKeDCHcbE0I2SgtWLg 提取码: frkx下载完成后我们可以看到下面两个文件：倒数第二个是安卓子系统安装包，倒数第一个是WSA工具箱用...",
    "content": "准备条件：win11专业版及以上，将系统地区调至美国在设置-&gt;应用 -&gt; 可选功能 -&gt; 更多Windows功能中勾选虚拟机平台，然后重启系统即可然后下载安装包，链接: https://pan.baidu.com/s/1215GlKeDCHcbE0I2SgtWLg 提取码: frkx下载完成后我们可以看到下面两个文件：倒数第二个是安卓子系统安装包，倒数第一个是WSA工具箱用于安装apk文件最下面两个文件现在我们以管理员身份打开Windows power shell执行指令：add-appxpackage空格+安卓子系统的文件路径（切记指令与路径之间加一个空格）出现上面这个即说明安装成功然后在开始菜单即可看到安装完成的安卓子系统，点击运行，勾选上开发者模式解压另一个zip文件运行，即可安装apk文件至此即安装完成**********以下内容由yexca添加**********1.如果工具箱无法安装或出现下图情况，请打开子系统设置，打开第一个选项“文件”，再打开工具箱即可2.获取文件路径在文件上鼠标右击选择“属性-安全”，第一行对象名称即为文件路径3. WSA工具箱原发布地址"
  },
  
  {
    "title": "SQL语句的一些语法细节（SQL SERVER语句）",
    "url": "/archives/8",
    "categories": "数据库",
    "tags": "",
    "date": "2021-11-08 11:51:18 +0800",
    





    
    "snippet": "1.SQL ORDER BY 关键字ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字SQL ORDER BY 语法SELECT column_name,column_nameFROM table_nameORDER BY column_name1,column_n...",
    "content": "1.SQL ORDER BY 关键字ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字SQL ORDER BY 语法SELECT column_name,column_nameFROM table_nameORDER BY column_name1,column_name2 ASC|DESC;–ASC表示升序，DESC表示降序–使用order by语句时应放在所有语句的最后使用，并且排序多个列时先排column_name1再column_name2…2.删除所有数据（delete和drop table）您可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：DELETE FROM table_name;或DELETE * FROM table_name;注释：在删除记录时要格外小心！因为您不能重来！DROP TABLE 语句DROP TABLE 语句用于删除表。DROP TABLE table_name注释：与delete不同的是drop table 会删除表数据和结果，也是不可逆的！DROP DATABASE 语句DROP DATABASE 语句用于删除数据库。DROP DATABASE database_nameTRUNCATE TABLE 语句如果我们仅仅需要删除表内的数据，但并不删除表本身，那么我们该如何做呢？请使用 TRUNCATE TABLE 语句：TRUNCATE TABLE table_name3.SQL JOINSQL join 用于把来自两个或多个表的行结合起来。下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。  INNER JOIN：如果表中有至少一个匹配，则返回行(INNER JOIN 与 JOIN 是相同的)  LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行  RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行  FULL JOIN：只要其中一个表中存在匹配，则返回行注释：SQL中的join语句其实对应数据库理论中的连接概念，left join、right join和inner join对应自然连接，full join对应笛卡尔积4.SQL 约束（Constraints）CREATE TABLE table_name(column_name1 data_type(size) constraint_name,column_name2 data_type(size) constraint_name,column_name3 data_type(size) constraint_name,....);  NOT NULL – 指示某列不能存储 NULL 值。  UNIQUE – 保证某列的每行必须有唯一的值。（一个表可以有多个UNIQUE约束但只能有一个primary key，primary key自动包含unique约束）  PRIMARY KEY – NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。（主键）  FOREIGN KEY – 保证一个表中的数据匹配另一个表中的值的参照完整性。（外键）  CHECK – 保证列中的值符合指定的条件。  DEFAULT – 规定没有给列赋值时的默认值。5.AUTO INCREMENT 字段我们通常希望在每次插入新记录时，自动地创建主键字段的值。我们可以在表中创建一个 auto-increment 字段。下面的 SQL 语句把 “Persons” 表中的 “ID” 列定义为 auto-increment 主键字段：CREATE TABLE Persons(ID int IDENTITY(1,1) PRIMARY KEY,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255))在上面的实例中，IDENTITY 的开始值是 1，每条新记录递增 1。提示：要规定 “ID” 列以 10 起始且递增 5，请把 identity 改为 IDENTITY(10,5)。要在 “Persons” 表中插入新记录，我们不必为 “ID” 列规定值（会自动添加一个唯一的值）：INSERT INTO Persons (FirstName,LastName)VALUES ('Lars','Monsen')上面的 SQL 语句会在 “Persons” 表中插入一条新记录。”ID” 列会被赋予一个唯一的值。”FirstName” 列会被设置为 “Lars”，”LastName” 列会被设置为 “Monsen”。6.触发器参见：SqlServer基础之(触发器) – wangchuang2017 – 博客园 (cnblogs.com)"
  },
  
  {
    "title": "关于在使用navicat连接SQL server的一些问题",
    "url": "/archives/7",
    "categories": "数据库",
    "tags": "",
    "date": "2021-11-07 23:41:46 +0800",
    





    
    "snippet": "在安装完SQL server和navicat后在navicat中添加数据库：1.连接名无要求，按照自己需要命名2.打开安装好的SQL server 配置管理器注意SQL Server（SQLEXPRESS）要保证在运行中，否则navicat无法连接双击打开后点击服务，可以看到自己的主机名3.此时打开navicat在主机的地方填上：主机名\\SQLEXPRESS(格式）4.用户名填sa(为安装S...",
    "content": "在安装完SQL server和navicat后在navicat中添加数据库：1.连接名无要求，按照自己需要命名2.打开安装好的SQL server 配置管理器注意SQL Server（SQLEXPRESS）要保证在运行中，否则navicat无法连接双击打开后点击服务，可以看到自己的主机名3.此时打开navicat在主机的地方填上：主机名\\SQLEXPRESS(格式）4.用户名填sa(为安装SQL server时的默认用户名，具体SQL server网上教程很多可以自己参考），密码是自己设置的（同样在SQL server安装时设置的密码）5.测试连接成功即可使用注：仅个人在安装过程中遇到的问题，具体安装教程请参考网络附上navicat 15及注册机：https://pan.baidu.com/s/1cJ1EZ9Gyz6Jp6J03VqcDHA提取码：3n7g"
  },
  
  {
    "title": "VsCode配置C语言环境",
    "url": "/archives/6",
    "categories": "软件配置",
    "tags": "c/c++, VS Code",
    "date": "2021-11-07 23:32:26 +0800",
    





    
    "snippet": "VSC只是一个纯文本编辑器，不是IDE(集成开发环境)，不含编译器和许多其它功能，所以编译器要自己装好第一步：在vscode官网下载软件，链接：Visual Studio Code – Code Editing. Redefined            第二步：我们需要下载一个编译器，C语言使用gcc，链接：[MinGW-w64 – for 32 and 64 bit Windows do...",
    "content": "VSC只是一个纯文本编辑器，不是IDE(集成开发环境)，不含编译器和许多其它功能，所以编译器要自己装好第一步：在vscode官网下载软件，链接：Visual Studio Code – Code Editing. Redefined            第二步：我们需要下载一个编译器，C语言使用gcc，链接：[MinGW-w64 – for 32 and 64 bit Windows download      SourceForge.net](https://sourceforge.net/projects/mingw-w64/)，选最新版本中的 x86_64-posix-seh 即可，网站下载可能较慢，下面给出百度网盘链接      （以下附上百度网盘秒传链接：b48357234368d9ba439fc0db6e86531d#84cbf1dc60abe4fff77d035540ea3132#140697937#mingw64.zip）（正常百度网盘链接：链接: https://pan.baidu.com/s/17FYT_Y-s-I2yajFc2MICqw 提取码: ewis ）第三步：将E:\\mingw64\\bin 添加到系统变量中（盘符根据自己编译器安装的位置）以Win11为例：打开设置-&gt;系统-&gt;关于-&gt;高级系统设置-&gt;环境变量-&gt;系统变量-&gt;点击Path-&gt;编辑 -&gt; 浏览 -&gt; 把对应文件加入即可第四步：按Win+R，运行cmd（不要跳这一步），输入gcc，应该会提示 no input files 而不是“不是内部命令或外部命令”或者“无法将 “gcc” 项识别为 cmdlet、函数、脚本文件或可运行程序的名称”。如果是“不是内部命令或外部命令”，说明gcc在的文件夹没有在环境变量的Path中，要加进去才行。如果加了还是这样，重启（不要忘记重启）。如果重启了还不行，那就是你自己进行的操作有问题。输gcc -v可以显示出gcc的版本。如果显示出来的版本与你刚下的不同/更老，说明Path里原本有老版本的编译器，可能是安装其它IDE时装上的。则需要去掉Path里原来的那一个gcc的路径。这两项验证一定要符合，否则必须修改环境变量。小心别错删了。第五步：现在打开vscode，下载相关插件第六步：我们需要写两个json文件，下面依次是launch.json和tasks.json（两个文件名也必须是 launch.json 和 tasks.json ） 注意看代码注释，两个文件都有几处地方需要将路径改为自己编译器的路径{    // 使用 IntelliSense 了解相关属性。     // 悬停以查看现有属性的描述。    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387    \"version\": \"0.2.0\",    \"configurations\": [        {            \"name\": \"gcc.exe - 生成和调试活动文件\",            \"type\": \"cppdbg\",            \"request\": \"launch\",            \"program\": \"${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\",//这里意思生成的二进制代码会放入当前文件的bin文件夹中，我们需要自己新建一个bin文件夹            \"args\": [],            \"stopAtEntry\": false,            \"cwd\": \"${fileDirname}\",            \"environment\": [],            \"externalConsole\": false,            \"MIMode\": \"gdb\",            \"miDebuggerPath\": \"E:\\\\mingw64\\\\bin\\\\gdb.exe\",            \"setupCommands\": [                {                    \"description\": \"为 gdb 启用整齐打印\",                    \"text\": \"-enable-pretty-printing\",                    \"ignoreFailures\": true                }            ],            \"preLaunchTask\": \"C/C++: gcc.exe 生成活动文件\"        }    ]}{    \"tasks\": [        {            \"type\": \"cppbuild\",            \"label\": \"C/C++: gcc.exe 生成活动文件\",            \"command\": \"E:\\\\mingw64\\\\bin\\\\gcc.exe\",//改成自己的文件路径            \"args\": [                /*\"${fileDirname}\\\\*.c\",                \"-o\",                \"${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\",                \"-g\"//多文件编译*/                \"-g\",                \"${file}\",                \"-o\",                \"${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\"//这里意思生成的二进制代码会放入当前文件的bin文件夹中，我们需要自己新建一个bin文件夹            ],            \"options\": {                \"cwd\": \"${fileDirname}\"            },            \"problemMatcher\": [                \"$gcc\"            ],            \"group\": {                \"kind\": \"build\",                \"isDefault\": true            },            \"presentation\": {                \"echo\": true,                \"reveal\": \"always\", // 执行任务时是否跳转到终端面板，可以为always，silent，never。具体参见VSC的文档                \"focus\": true,     // 设为true后可以使执行task时焦点聚集在终端，但对编译C/C++来说，设为true没有意义                \"panel\": \"shared\"   // 不同的文件的编译信息共享一个终端面板            },            \"detail\": \"调试器生成的任务。\"        },        {            \"type\": \"cppbuild\",            \"label\": \"(多文件)gcc.exe - 生成和调试活动文件\",            \"command\": \"E:\\\\mingw64\\\\bin\\\\gcc.exe\",//改成自己的文件路径            \"args\": [                \"${fileDirname}\\\\*.c\",                \"-o\",                \"${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\",//这里意思生成的二进制代码会放入当前文件的bin文件夹中，我们需要自己新建一个bin文件夹                \"-g\"            ],            \"options\": {                \"cwd\": \"${fileDirname}\"            },            \"problemMatcher\": [                \"$gcc\"            ],            \"group\": {                \"kind\": \"build\",                \"isDefault\": true            },            \"presentation\": {                \"echo\": true,                \"reveal\": \"always\", // 执行任务时是否跳转到终端面板，可以为always，silent，never。具体参见VSC的文档                \"focus\": true,     // 设为true后可以使执行task时焦点聚集在终端，但对编译C/C++来说，设为true没有意义                \"panel\": \"shared\"   // 不同的文件的编译信息共享一个终端面板            },            \"detail\": \"调试器生成的任务。\"        }    ],    \"version\": \"2.0.0\"}至此设置工作基本结束，vscode有许多好用的插件可以自己探索，未来也会在写一篇文章推荐一些好用的插件"
  },
  
  {
    "title": "VsCode配置Python环境",
    "url": "/archives/5",
    "categories": "软件配置",
    "tags": "Python, VS Code",
    "date": "2021-11-07 11:28:58 +0800",
    





    
    "snippet": "安装完成VS Code和Python并配置环境变量后打开VS Code，进入拓展搜索并下载Python在资源管理器新建一个Python源文件(.py)后，资源管理器会在.vscode文件夹下生成setting.json文件（若没有自动生成可自己创建）打开setting.json文件，并替换为以下代码{    \"python.linting.flake8Enabled\": true,    \"...",
    "content": "安装完成VS Code和Python并配置环境变量后打开VS Code，进入拓展搜索并下载Python在资源管理器新建一个Python源文件(.py)后，资源管理器会在.vscode文件夹下生成setting.json文件（若没有自动生成可自己创建）打开setting.json文件，并替换为以下代码{    \"python.linting.flake8Enabled\": true,    \"python.linting.flake8Args\": [\"--max-line-length=248\"],    \"python.linting.pylintEnabled\": false}此时回到python文件，VS Code右下会弹出警告，点击下载按CTRL+SHIFT+P键，输入Python: Select Interpreter (即Python：选择编译器)然后选择您下载的编译器即可如果.vscode文件夹下有launch.json文件，需要在该文件的”configurations”中加入以下代码{            \"name\": \"Python: 当前文件\",            \"type\": \"python\",            \"request\": \"launch\",            \"program\": \"${file}\",            \"console\": \"integratedTerminal\"        }参考文章：VsCode配置Python环境小白教程VSCode配置Python教程"
  },
  
  {
    "title": "如何自动调用当前系统默认的邮件客户端",
    "url": "/archives/4",
    "categories": "网站建设",
    "tags": "",
    "date": "2021-11-06 17:05:36 +0800",
    





    
    "snippet": "mailto：可以自动调用当前系统默认的邮件客户端，并自动填充收件人、抄送人、密送人、主题、内容。参数说明:mailto： 收件人，多个以;分隔cc： 抄送人，多个以;分隔bcc： 密送人，多个以;分隔subject： 主题body： 内容各参数间用&amp;连接即可例如：&lt;a mailto:***@***.com?subject=this is subject&amp;body=th...",
    "content": "mailto：可以自动调用当前系统默认的邮件客户端，并自动填充收件人、抄送人、密送人、主题、内容。参数说明:mailto： 收件人，多个以;分隔cc： 抄送人，多个以;分隔bcc： 密送人，多个以;分隔subject： 主题body： 内容各参数间用&amp;连接即可例如：&lt;a mailto:***@***.com?subject=this is subject&amp;body=this is body&gt;…&lt;a&gt;注：在elementor中应在文本编辑器的超链接选项中直接填写 mailto:***@***.com?subject=this is subject&amp;body=this is body 即可tips:内容来源于互联网，侵权删"
  },
  
  {
    "title": "WordPress嵌入BiLiBiLi视频说明",
    "url": "/archives/3",
    "categories": "网站建设",
    "tags": "WordPress",
    "date": "2021-11-06 16:43:20 +0800",
    





    
    "snippet": "首先到待嵌入的视频将鼠标移到分享按钮上（不用点击）然后移到嵌入代码并复制（本例代码如下）&lt;iframe src=\"//player.bilibili.com/player.html?aid=583631611&amp;bvid=BV1Tz4y1X7Bg&amp;cid=206708397&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder...",
    "content": "首先到待嵌入的视频将鼠标移到分享按钮上（不用点击）然后移到嵌入代码并复制（本例代码如下）&lt;iframe src=\"//player.bilibili.com/player.html?aid=583631611&amp;bvid=BV1Tz4y1X7Bg&amp;cid=206708397&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"&gt; &lt;/iframe&gt;我们需要这串代码中的”aid“和”cid“部分（即 aid=583631611 和 cid=206708397 ）然后将aid和cid填入下方代码的相应位置&lt;div style=\"position: relative; padding: 30% 45%;\"&gt;&lt;iframe style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\" src=\"https://player.bilibili.com/player.html?cid=206708397&amp;aid=583631611&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=0\" frameborder=\"no\" scrolling=\"no\"&gt;&lt;/iframe&gt;&lt;/div&gt;（以上代码中aid和cid已替换）在编写文章的过程若插入视频只需将区块设成“自定义HTML”然后把替换好aid和cid的代码拷贝过去即可如下为示例视频参考王陸大佬的文章关于博客园内嵌入bilibili视频"
  },
  
  {
    "title": "WordPress限制用户访问媒体库",
    "url": "/archives/2",
    "categories": "网站建设",
    "tags": "WordPress",
    "date": "2021-11-06 14:31:04 +0800",
    





    
    "snippet": "默认情况下，WordPress允许作者​​查看您网站媒体库中的所有图像。允许作者查看媒体库中的所有文件。 他们还可以查看由管理员 ， 编辑或其他作者上传的图像。对于许多网站而言，这可能并不重要。 但是，如果您运行一个多作者网站 ，则可能需要更改它。首先，进入 “网站根目录/wp-content/themes/您当前使用的主题名称/”找到functions.php文件并编辑，在末尾插入如下代码...",
    "content": "默认情况下，WordPress允许作者​​查看您网站媒体库中的所有图像。允许作者查看媒体库中的所有文件。 他们还可以查看由管理员 ， 编辑或其他作者上传的图像。对于许多网站而言，这可能并不重要。 但是，如果您运行一个多作者网站 ，则可能需要更改它。首先，进入 “网站根目录/wp-content/themes/您当前使用的主题名称/”找到functions.php文件并编辑，在末尾插入如下代码即可// Limit media library access add_filter( 'ajax_query_attachments_args', 'wpb_show_current_user_attachments' ); function wpb_show_current_user_attachments( $query ) {    $user_id = get_current_user_id();    if ( $user_id &amp;&amp; !current_user_can('activate_plugins') &amp;&amp; !current_user_can('edit_others_posts') ) {        $query['author'] = $user_id;    }    return $query;}参考文章：如何限制媒体库对WordPress中用户自己上传的内容的访问"
  },
  
  {
    "title": "Hello World！",
    "url": "/archives/1",
    "categories": "日常",
    "tags": "",
    "date": "2021-11-06 14:15:19 +0800",
    





    
    "snippet": "欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！",
    "content": "欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！"
  }
  
]

