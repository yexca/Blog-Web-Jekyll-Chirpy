

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.yexca.net/</id>
  <title>yexca'Blog</title>
  <subtitle>yexca,blog,技术,博客,技术博客</subtitle>
  <updated>2024-01-10T17:59:22+08:00</updated>
  <author>
    <name>yexca</name>
    <uri>https://blog.yexca.net/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.yexca.net/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="zh"
    href="https://blog.yexca.net/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2024 yexca </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>JavaWeb 入门</title>
    <link href="https://blog.yexca.net/archives/142" rel="alternate" type="text/html" title="JavaWeb 入门" />
    <published>2024-01-10T17:53:00+08:00</published>
  
    <updated>2024-01-10T17:53:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/142</id>
    <content src="https://blog.yexca.net/archives/142" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="后端" />
    
    <category term="Spring" />
    
  

  
    <summary>
      





      SpringBoot 入门例子

需求：使用 SpringBoot 开发一个 web 应用，浏览器发起 /hello 后，返回字符串 “Hello Spring”

首先需要创建 SpringBoot 工程，并勾选 web 开发相关依赖

然后创建控制类，路径在 *Application.java 同级创建文件 Controller/HelloController.java

@RestController
public class HelloController{
    @RequestMapping("/hello")
    public String hello(){
        String s = "Hello Spring";
        System.out.println(s);
        return s;
    }
}


运行  *Appli...
    </summary>
  

  </entry>

  
  <entry>
    <title>Docker 创建与推送 H5 镜像</title>
    <link href="https://blog.yexca.net/archives/141" rel="alternate" type="text/html" title="Docker 创建与推送 H5 镜像" />
    <published>2024-01-09T21:50:00+08:00</published>
  
    <updated>2024-01-09T21:50:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/141</id>
    <content src="https://blog.yexca.net/archives/141" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="后端" />
    
    <category term="Docker" />
    
  

  
    <summary>
      





      新建目录，将网页文件放入 ./dict

根目录装进文件 dockerfile 内容如下：

# 基于nginx:1.20镜像
FROM nginx:1.20
# 将dist文件中的内容复制到 /usr/share/nginx/html/ 这个目录下面
COPY dist/ /usr/share/nginx/html/dist/
# 用本地的 nginx.conf 配置来替换nginx镜像里的默认配置
COPY nginx.conf /etc/nginx/nginx.conf


新建文件 nginx.conf 内容如下：

#user  nobody;
worker_processes  1;
events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type ...
    </summary>
  

  </entry>

  
  <entry>
    <title>设计模式 Index</title>
    <link href="https://blog.yexca.net/archives/140" rel="alternate" type="text/html" title="设计模式 Index" />
    <published>2023-12-27T16:14:00+08:00</published>
  
    <updated>2024-01-09T21:57:02+08:00</updated>
  
    <id>https://blog.yexca.net/archives/140</id>
    <content src="https://blog.yexca.net/archives/140" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
    <category term="设计模式" />
    
  

  
    <summary>
      





      简单介绍设计模式


  设计模式 引


具体的设计模式


  
    
       
      创建型
      结构型
      行为型
    
  
  
    
      类
      工厂方法模式
      适配器模式 (类)
      解释器模式模板方法模式
    
    
      对象
      抽象工厂模式生成器模式原型模式单例模式
      适配器模式 (对象)桥接模式组合模式装饰器模式外观模式享元模式代理模式
      责任链模式命令模式迭代器模式中介者模式备忘录模式观察者模式状态模式策略模式访问者模式
    
  


其中


  
    工厂方法模式 与 抽象工厂模式 在 工厂模式
  
  
    适配器模式 描述了类与对象
  


推荐阅读

https://refactoringguru.cn/desig...
    </summary>
  

  </entry>

  
  <entry>
    <title>访问者模式</title>
    <link href="https://blog.yexca.net/archives/139" rel="alternate" type="text/html" title="访问者模式" />
    <published>2023-12-26T16:09:00+08:00</published>
  
    <updated>2023-12-26T16:09:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/139</id>
    <content src="https://blog.yexca.net/archives/139" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
    <category term="设计模式" />
    
  

  
    <summary>
      





      Visitor Pattern 对象行为型模式

意图

表示一个作用于某对象结构中的各元素的操作。它不允许在不改变各元素的类的前提下定义作用于这些元素的新操作

结构



其中：


  Visitor (访问者) 为该对象结构中 ConcreteElement 的每一个类声明一个 Visit 操作。该操作的名字和特殊标识了发送 Visit 请求给该访问者的那个类，这使得访问者可以确定正被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它
  ConcreteVisitor (具体访问者) 实现每个有 Visitor 声明的操作，每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。ConcreteVisitor 为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结构
  Element (元素) 定义以一个访问者为参数的 A...
    </summary>
  

  </entry>

  
  <entry>
    <title>模板方法模式</title>
    <link href="https://blog.yexca.net/archives/138" rel="alternate" type="text/html" title="模板方法模式" />
    <published>2023-12-25T21:06:00+08:00</published>
  
    <updated>2023-12-25T21:06:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/138</id>
    <content src="https://blog.yexca.net/archives/138" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
    <category term="设计模式" />
    
  

  
    <summary>
      





      Template Method Pattern 类行为型模式

意图

定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤

结构



其中：


  AbstractClass (抽象类) 定义抽象的原语操作，具体的子类将重定义它们以实现一个算法的各步骤；实现模板方法，定一个算法的骨架，该模板方法不仅调用原语操作，也调用定义在 AbstractClass 或其他对象中的操作
  ConcreteClass (具体类) 实现原语操作以完成算法中与特定子类相关的步骤


适用性

Template Method 模式适用于：


  一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现
  各子类中公共的行为应被提取出来并集中到一个公共父类中，以避免代码重复
  控制子类扩展。模板...
    </summary>
  

  </entry>

</feed>


