

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.yexca.net/</id>
  <title>yexca'Blog</title>
  <subtitle>yexca,blog,技术,博客,技术博客</subtitle>
  <updated>2023-08-28T15:56:50+08:00</updated>
  <author>
    <name>yexca</name>
    <uri>https://blog.yexca.net/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.yexca.net/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://blog.yexca.net/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 yexca </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>使用 CNAME 将域名重定向到带路径的 URL</title>
    <link href="https://blog.yexca.net/archives/115" rel="alternate" type="text/html" title="使用 CNAME 将域名重定向到带路径的 URL" />
    <published>2023-08-28T15:31:00+08:00</published>
  
    <updated>2023-08-28T15:31:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/115</id>
    <content src="https://blog.yexca.net/archives/115" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="技术工具" />
    
  

  
    <summary>
      





      之前拥有服务器的时候虽然有过此想法，但毕竟只要服务器再开个站点就解决了并没有深入研究，如今服务器到期将 Blog 搬到 Github 上想要继续这样无疑是不可能的，于是便寻求解决方法

失败的历程

虽然失败了，但还是要记录下来，肯定是我不会用

之前只是试着玩玩，仅从 DNS 的 CNAME 试了发现不行便放弃了，这次使用互联网搜索”域名定向到路径 url”，从第一条搜索结果 https://cloud.tencent.com/developer/ask/sof/89340 得知工具网站：http://redirect.center/

例子

从 https://acg.yexca.net 重定向到 https://blog.yexca.net/acg

按网站描述，CNAME 内容应该为 blog.yexca.net.opts-slash.acg.opts-https.redi...
    </summary>
  

  </entry>

  
  <entry>
    <title>单例模式</title>
    <link href="https://blog.yexca.net/archives/115" rel="alternate" type="text/html" title="单例模式" />
    <published>2023-07-05T13:58:00+08:00</published>
  
    <updated>2023-07-05T13:58:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/115</id>
    <content src="https://blog.yexca.net/archives/115" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Singleton Pattern 对象创建型模式

意图

保证一个类仅有一个实例，并提供一个访问它的全局访问点

结构



其中：


  Singleton 指定一个 Instance 操作，允许客户访问它的唯一实例
  Instance 是一个类操作；可能负责创建它自己的唯一实例


适用性

Singleton 模式适用于：


  当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时
  当这个唯一实例应该是通过子类化可扩展的，并且客户无须更改代码就能使用一个扩展的实例时


例子

public class main{
    // s1 和 s2 是同一个实例 (地址相同)
    Singleton s1 = Singleton.getInstance();
    Singleton s2 = Singleton.getInstance();
}

cl...
    </summary>
  

  </entry>

  
  <entry>
    <title>アイドルマスター ミリオンライブ！的 IP 规则</title>
    <link href="https://blog.yexca.net/archives/114" rel="alternate" type="text/html" title="アイドルマスター ミリオンライブ！的 IP 规则" />
    <published>2023-06-09T23:32:09+08:00</published>
  
    <updated>2023-06-09T23:32:09+08:00</updated>
  
    <id>https://blog.yexca.net/archives/114</id>
    <content src="https://blog.yexca.net/archives/114" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="日常" />
    
  

  
    <summary>
      





      最近游玩 ミリシタ 时连接不上，遂寻找解决方法 （顺便试试 Spotify 的嵌入效果

域名

theaterdays.appspot.com





最近雨宿りの曲が大好きので、よく聞いていた。Last.fm で過去30日間雨宿りの「猫かぶり」は人気トラック一番になった。で、トップアーティストじゃない？トップアーティスト、もちろん湊あくあ！　　

草、ミリシタの文章で何を書いたか、どっちもミリシタと関係ないもん！


clash

通过设置组更好选择

首先设置 JP 组

proxy-groups:
- name: JP
  type: select
  proxies:
  - your jp proxy name
  - your jp proxy name


然后添加规则

rules:
- DOMAIN-SUFFIX,theaterdays.appspot.com,...
    </summary>
  

  </entry>

  
  <entry>
    <title>原型模式</title>
    <link href="https://blog.yexca.net/archives/113" rel="alternate" type="text/html" title="原型模式" />
    <published>2023-06-02T19:31:44+08:00</published>
  
    <updated>2023-06-02T19:31:44+08:00</updated>
  
    <id>https://blog.yexca.net/archives/113</id>
    <content src="https://blog.yexca.net/archives/113" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Prototype Pattern 对象创建型模式

意图

用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象

结构



其中：


  Prototype 声明一个复制自身的接口
  ConcretePrototype 实现一个复制自身的操作
  Client 让一个原型复制自身从而创建一个新的对象


适用性

Prototype 模式适用于：


  当一个系统应该独立于它的产品创建、构成和表示时
  当要实例化的类是在运行时刻指定时，例如，通过动态装载
  为了避免创建一个与产品类层次平行的工厂类层次时
  当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些


例子 1

public class main{
    Product p1 = new Product(2023, 3....
    </summary>
  

  </entry>

  
  <entry>
    <title>生成器模式</title>
    <link href="https://blog.yexca.net/archives/112" rel="alternate" type="text/html" title="生成器模式" />
    <published>2023-06-01T23:33:17+08:00</published>
  
    <updated>2023-06-01T23:33:17+08:00</updated>
  
    <id>https://blog.yexca.net/archives/112</id>
    <content src="https://blog.yexca.net/archives/112" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Builder Pattern 对象创建型模式

意图

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

结构



其中：


  Builder 为创建一个 Product 对象的各个部件指定抽象接口
  ConcreteBuilder 实现 Builder 的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，提供一个检索产品的接口
  Director 构造一个使用 Builder 接口的对象
  Product 表示被构建的复杂对象。ConcreteBuilder 创建该产品的内部表示并定义它的装配过程。包含定义组成组件的类，包括将这些组件装配成最终产品的接口


适用性

Builder 模式适用于：


  当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式
  当构建过程必须允许被构造的对象有不同的表示时


例子 1...
    </summary>
  

  </entry>

</feed>


