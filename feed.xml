

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.yexca.net/</id>
  <title>yexca'Blog</title>
  <subtitle>yexca,blog,技术,博客,技术博客</subtitle>
  <updated>2023-12-22T16:06:17+08:00</updated>
  <author>
    <name>yexca</name>
    <uri>https://blog.yexca.net/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.yexca.net/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="zh"
    href="https://blog.yexca.net/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 yexca </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>状态模式</title>
    <link href="https://blog.yexca.net/archives/136" rel="alternate" type="text/html" title="状态模式" />
    <published>2023-12-22T15:11:00+08:00</published>
  
    <updated>2023-12-22T16:06:06+08:00</updated>
  
    <id>https://blog.yexca.net/archives/136</id>
    <content src="https://blog.yexca.net/archives/136" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
    <category term="设计模式" />
    
  

  
    <summary>
      





      State Pattern 对象行为型模式

意图

允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类

结构



其中：


  
    Context (上下文) 定义客户感兴趣的接口：维护一个 ConcerteState 子类的实例，这个实例定义当前状态
  
  
    State (状态) 定义一个接口以封装与 Context 的一个特定状态相关的行为
  
  
    ConcreteState (具体状态子类) 毎个子类实现与 Context 的一个状态相关的行为
  


适用性


  
    一个对象的行为决定于它的状态，并且它必领在运行吋刻根据状态改变它的行为
  
  
    一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构，Stat...
    </summary>
  

  </entry>

  
  <entry>
    <title>Ajax 与 Axios</title>
    <link href="https://blog.yexca.net/archives/135" rel="alternate" type="text/html" title="Ajax 与 Axios" />
    <published>2023-12-21T13:32:00+08:00</published>
  
    <updated>2023-12-21T13:32:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/135</id>
    <content src="https://blog.yexca.net/archives/135" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="前端" />
    
    <category term="JavaScript" />
    
  

  
    <summary>
      





      Ajax 与 Axios

Asynchronous JavaScript And XML，异步的 JS 和 XML。作用：


  数据交换：通过 Ajax 可以给服务器发送请求，并获取服务器响应的数据
  异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术


使用场景：搜索联想、用户名是否可用等

同步与异步

同步指在访问网页时进行某操作需要请求服务器，在服务器处理时网页不可操作，直到服务器响应客户端时才可继续操作

而异步在请求服务器的同时，客户端可以执行其他操作

原生 Ajax

首先创建 XMLHttpRequest 对象 (用于和服务器交换数据)，然后向服务器发送请求，最后获取服务器响应数据

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang="en"&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta c...
    </summary>
  

  </entry>

  
  <entry>
    <title>观察者模式</title>
    <link href="https://blog.yexca.net/archives/134" rel="alternate" type="text/html" title="观察者模式" />
    <published>2023-12-21T01:18:00+08:00</published>
  
    <updated>2023-12-22T16:06:06+08:00</updated>
  
    <id>https://blog.yexca.net/archives/134</id>
    <content src="https://blog.yexca.net/archives/134" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
    <category term="设计模式" />
    
  

  
    <summary>
      





      观察者模式

Observer Pattern 对象行为型模式

意图
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变吋，所有依赖于它的对象都得到通知并被自动更新
结构



其中：


  Subject (目标) 知道它的观察者，可以有任意多个观察者观察同一个目标；提供注册和删除观察者对象的接口
  Observer (观察者) 为那些在”目标发生改变时需获得通知的对象定义一个更新接口
  ConcreteSubject (具体目标) 将有关状态存入各 ConcreteObserver 对象：当它的状态发生改变时，向它的各个观察者发出通知
  ConcreteObserver (具体观察者) 维护一个指向 ConcreteSubject 对象的引用：存储有关状态，这些状态应与目标的状态保持一致：实现 Observer 的更新接口，以使自身状态与目标的状态保持一致


...
    </summary>
  

  </entry>

  
  <entry>
    <title>hvdb 注册检测</title>
    <link href="https://blog.yexca.net/archives/133" rel="alternate" type="text/html" title="hvdb 注册检测" />
    <published>2023-12-02T21:23:00+08:00</published>
  
    <updated>2023-12-02T21:23:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/133</id>
    <content src="https://blog.yexca.net/archives/133" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="日常" />
    
  

  
    <summary>
      





      从 ???? 我记不清了 开始喜欢上 ASMR 后就接触到了音声，不过高昂的价格显然会驱使我去广袤的互联网上搜索，于是便知道了这个网站，可此网站只有登录后才可以看到更多内容，而每年也几乎是不定时开放注册，这使我很好奇这个网站

于是我便想着让服务器运行程序检测是否可以注册，然后通知

Github: yexca/hvdb

目标

检测是否可以注册，如果可以便通过 Telegram 通知

检测是否可以注册

在灵梦广场的一个帖子回复中可以获知当开放注册时 login 的底下会出现 register

那便可以用一种最简朴的方法，爬取这个网页，检查是否有此单词

Bot 配置

使用 Telegram 的 bot 通知需要先注册一个 bot

对话 https://t.me/BotFather 输入 /newbot 指令按照步骤创建一个 bot

和刚创建的 bot 对话，发送 he...
    </summary>
  

  </entry>

  
  <entry>
    <title>备忘录模式</title>
    <link href="https://blog.yexca.net/archives/132" rel="alternate" type="text/html" title="备忘录模式" />
    <published>2023-11-27T14:08:00+08:00</published>
  
    <updated>2023-12-22T16:06:06+08:00</updated>
  
    <id>https://blog.yexca.net/archives/132</id>
    <content src="https://blog.yexca.net/archives/132" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
    <category term="设计模式" />
    
  

  
    <summary>
      





      Memento Pattern 对象行为型模式

意图

在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态

结构



其中：


  Memento (备忘录) 存储原发器对象的内部状态，原发器根据需要决定备忘录存储原发器的哪些内部状态；防止原发器以外的其他对象访问备忘录
  Originator (原发器) 创建一个备忘录，用于记录当前时刻它的内部状态；使用备忘录恢复内部状态
  Caretaker (管理者) 负责保存好备忘录；不能对备忘录的内容进行操作或检查


适用性

Memento 模式适用于：


  必须保存一个对象在某一个时刻的 (部分) 状态，这样以后需要时它才能恢复到先前的状态
  如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性


例子

import j...
    </summary>
  

  </entry>

</feed>


