

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.yexca.net/</id>
  <title>yexca'Blog</title>
  <subtitle>yexca,blog,技术,博客,技术博客</subtitle>
  <updated>2023-09-05T21:48:13+08:00</updated>
  <author>
    <name>yexca</name>
    <uri>https://blog.yexca.net/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.yexca.net/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://blog.yexca.net/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 yexca </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>装饰器模式</title>
    <link href="https://blog.yexca.net/archives/120" rel="alternate" type="text/html" title="装饰器模式" />
    <published>2023-09-05T21:45:00+08:00</published>
  
    <updated>2023-09-05T21:45:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/120</id>
    <content src="https://blog.yexca.net/archives/120" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Decorator Pattern 对象结构型模式

意图

动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator 模式比生成子类更加灵活

结构



其中：


  Component 定义一个对象接口，可以给这些对象动态地添加职责
  ConcreteComponent 定义一个对象，可以给这个对象添加一些职责
  Decorator 维持一个指向 Component 对象的指针，并定义一个与 Component 接口一致的接口
  ConcreteDecorator 向组件添加职责


适用性

Decorator 模式适用于：


  在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
  处理那些可以撤销的职责
  当不能采用生成子类的方式进行扩充时，一种情况是，可能有大量独立的拓展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长...
    </summary>
  

  </entry>

  
  <entry>
    <title>组合模式</title>
    <link href="https://blog.yexca.net/archives/119" rel="alternate" type="text/html" title="组合模式" />
    <published>2023-09-03T15:44:00+08:00</published>
  
    <updated>2023-09-03T15:44:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/119</id>
    <content src="https://blog.yexca.net/archives/119" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Composite Pattern 对象结构型模式

意图

将对象组合成树型结构以表示 “部分 - 整体” 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性

结构



其中：


  Component 为组合中的对象声明接口；在适当情况下实现所有类共有接口的默认行为；声明一个接口用于访问和管理 Component 的子组件；(可选) 在递归结构中定义一个接口，用于访问一个父组件，并在合适的情况下实现它
  Leaf 在组合中表示叶结点对象，叶结点没有子结点；在组合中定义图元对象的行为
  Composite 定义所有子组件的那些组件的行为；存储子组件；在 Component 接口中实现与子组件有关的操作
  Client 通过 Component 接口操纵组合组件的对象


适用性

Composite 模式适用于：


  想表示对象的部分 - ...
    </summary>
  

  </entry>

  
  <entry>
    <title>桥接模式</title>
    <link href="https://blog.yexca.net/archives/118" rel="alternate" type="text/html" title="桥接模式" />
    <published>2023-09-02T17:34:00+08:00</published>
  
    <updated>2023-09-02T17:34:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/118</id>
    <content src="https://blog.yexca.net/archives/118" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Bridge Pattern 对象结构型模式

意图

将抽象部分与其实现部分分离，使它们都可以独立地变化

结构



其中：


  Abstraction 定义抽象类的接口，维护一个指向 Implementor 类型对象的指针
  RefinedAbstraction 扩充由 Abstraction 定义的接口
  Implementor 定义实现类的接口，该接口不一定要与 Abstraction 的接口完全一致；事实上这两个接口可以完全不同
一般来说，Implementor 接口仅提供基本操作，而 Abstraction 定义了基于这些基本操作的较高层次的操作
  ConcreteImplementor 实现 Implementor 接口并定义它的具体实现


适用性

Bridge 模式适用于：


  不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能...
    </summary>
  

  </entry>

  
  <entry>
    <title>适配器模式</title>
    <link href="https://blog.yexca.net/archives/117" rel="alternate" type="text/html" title="适配器模式" />
    <published>2023-09-01T15:03:00+08:00</published>
  
    <updated>2023-09-02T17:37:54+08:00</updated>
  
    <id>https://blog.yexca.net/archives/117</id>
    <content src="https://blog.yexca.net/archives/117" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Adapter Pattern 类结构型模式/对象结构型模式

意图

将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

结构


  类适配器使用多重继承对一个接口与另一个接口进行匹配





  对象适配器依赖于对象组合




其中：


  Target 定义 Client 使用的与特定领域相关的接口
  Client 与符合 Target 接口的对象协同
  Adaptee 定义一个已经存在的接口，这个接口需要适配
  Adapter 对 Adaptee 的接口与 Target 接口进行适配


适用性

Adapter 模式适用于：


  想使用一个已经存在的类，而它的接口不符合要求
  想创建一个可以服用的类，该类可以与其他不相关的类或不可预见的类 (即那些接口可能不一定兼容的类) 协同工作
...
    </summary>
  

  </entry>

  
  <entry>
    <title>使用 CNAME 将域名重定向到带路径的 URL</title>
    <link href="https://blog.yexca.net/archives/116" rel="alternate" type="text/html" title="使用 CNAME 将域名重定向到带路径的 URL" />
    <published>2023-08-28T15:31:00+08:00</published>
  
    <updated>2023-08-28T16:02:27+08:00</updated>
  
    <id>https://blog.yexca.net/archives/116</id>
    <content src="https://blog.yexca.net/archives/116" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="技术工具" />
    
  

  
    <summary>
      





      之前拥有服务器的时候虽然有过此想法，但毕竟只要服务器再开个站点就解决了并没有深入研究，如今服务器到期将 Blog 搬到 Github 上想要继续这样无疑是不可能的，于是便寻求解决方法

失败的历程

虽然失败了，但还是要记录下来，肯定是我不会用

之前只是试着玩玩，仅从 DNS 的 CNAME 试了发现不行便放弃了，这次使用互联网搜索”域名定向到路径 url”，从第一条搜索结果 https://cloud.tencent.com/developer/ask/sof/89340 得知工具网站：http://redirect.center/

例子

从 https://acg.yexca.net 重定向到 https://blog.yexca.net/acg

按网站描述，CNAME 内容应该为 blog.yexca.net.opts-slash.acg.opts-https.redi...
    </summary>
  

  </entry>

</feed>


