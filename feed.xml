

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.yexca.net/</id>
  <title>yexca'Blog</title>
  <subtitle>yexca,blog,技术,博客,技术博客</subtitle>
  <updated>2024-03-02T17:21:29+08:00</updated>
  <author>
    <name>yexca</name>
    <uri>https://blog.yexca.net/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.yexca.net/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="zh"
    href="https://blog.yexca.net/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2024 yexca </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>CSS 选择器</title>
    <link href="https://blog.yexca.net/archives/163" rel="alternate" type="text/html" title="CSS 选择器" />
    <published>2024-03-02T17:15:00+08:00</published>
  
    <updated>2024-03-02T17:15:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/163</id>
    <content src="https://blog.yexca.net/archives/163" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="前端" />
    
    <category term="CSS" />
    
  

  
    <summary>
      





      CSS 引入方式

CSS 有三种引入方式，第一种为内部样式表，此方式仅学习使用

&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
        &amp;lt;style&amp;gt;
        	/* 此处写 CSS */
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;


第二种为行内样式，一般配合 JavaScript 使用

&amp;lt;div style="此处写 CSS"&amp;gt;&amp;lt;/div&amp;gt;


最后一种为外部样式表，将 CSS 代码写在单独文件，通过 link 标签引入，开发时常用

&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/...
    </summary>
  

  </entry>

  
  <entry>
    <title>GoLand 面向对象</title>
    <link href="https://blog.yexca.net/archives/162" rel="alternate" type="text/html" title="GoLand 面向对象" />
    <published>2024-03-01T15:35:00+08:00</published>
  
    <updated>2024-03-01T15:35:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/162</id>
    <content src="https://blog.yexca.net/archives/162" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="编程基础" />
    
    <category term="编程语言" />
    
  

  
    <summary>
      





      通过使用结构体构建类与对象的概念


  了解面向对象：面向对象基础


struct

首先是自定义类型，使用 type 关键字，类似于 C

package main

import "fmt"

type myType int

func main() {
	var a myType
	fmt.Println("a =", a)
	fmt.Printf("type of a is %T", a)
}

/*
 * 输出
 * a = 0
 * type of a is main.myTye
 */


定义类型使用 stuct

package main

import "fmt"

type Person struct {
	name string
	age  int
}

func main() {
	var zhang Person
	zhang.name = "zhan...
    </summary>
  

  </entry>

  
  <entry>
    <title>注册中心 - Eureka</title>
    <link href="https://blog.yexca.net/archives/161" rel="alternate" type="text/html" title="注册中心 - Eureka" />
    <published>2024-02-29T16:53:00+08:00</published>
  
    <updated>2024-02-29T16:53:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/161</id>
    <content src="https://blog.yexca.net/archives/161" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="后端" />
    
    <category term="Spring" />
    
  

  
    <summary>
      





      引入注册中心之前先引入提供者与消费者概念

提供者与消费者

服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）

服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）

提供者与消费者是相对的，一个服务既可以是提供者也可以是消费者

Eureka

若提供者有多个，消费者如何获取提供者信息，如何得知提供者的健康状态

在启动时，微服务向 Eureka 注册服务信息，消费者可通过 Eureka 拉取提供者信息，然后远程调用。微服务会每 30s 向 Eureka 说明自己还活着，Eureka 会更新记录服务列表信息，剔除不健康服务器

如果有多个服务提供者，消费者利用负载均衡算法，从服务列表中挑选一个

搭建

新建一个 Maven Module，引入依赖

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org....
    </summary>
  

  </entry>

  
  <entry>
    <title>GoLand 切片</title>
    <link href="https://blog.yexca.net/archives/160" rel="alternate" type="text/html" title="GoLand 切片" />
    <published>2024-02-27T20:00:00+08:00</published>
  
    <updated>2024-02-27T20:00:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/160</id>
    <content src="https://blog.yexca.net/archives/160" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="编程基础" />
    
    <category term="编程语言" />
    
  

  
    <summary>
      





      Go 的切片是对数组的抽象

数组

数组的长度不可改变

package main

import "fmt"

func main() {
    // 定义方式一
	var arr1 [10]int
    // 遍历
	for i := 0; i &amp;lt; len(arr1); i++ {
		fmt.Println("arr1[", i, "]:", arr1[i])
	}

    // 定义方式二，赋值
	arr2 := [10]int{0, 1, 2, 3}
    // range遍历
	for index, value := range arr2 {
		fmt.Println("index =", index, "value =", value)
	}

    // 定义不同长度
	var arr3 [4]int

	fmt.Printf("type of a...
    </summary>
  

  </entry>

  
  <entry>
    <title>Linux 定时任务 crontab</title>
    <link href="https://blog.yexca.net/archives/159" rel="alternate" type="text/html" title="Linux 定时任务 crontab" />
    <published>2024-02-26T21:34:00+08:00</published>
  
    <updated>2024-02-26T21:34:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/159</id>
    <content src="https://blog.yexca.net/archives/159" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="Linux" />
    
    <category term="LinuxTools" />
    
  

  
    <summary>
      





      这篇文章还是有点久远的，书写习惯和现在不同，甚至看着有点不习惯

通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script 脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合

命令格式

crontab [-u user] file crontab [-u user] [ -e | -l | -r ]


命令参数


  -u user：用来设定某个用户的 crontab 服务
  file：file 是命令文件的名字,表示将 file 做为 crontab 的任务列表文件并载入 crontab。如果在命令行中没有指定这个文件，crontab 命令将接受标准输入（键盘）上键入的命令，并将它们载入 crontab
  -e：编辑某个用户的 crontab 文件内容。如果不指定用户，则表示编辑当前用户的 crontab 文件
 ...
    </summary>
  

  </entry>

</feed>


