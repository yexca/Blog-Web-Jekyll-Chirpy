

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.yexca.net/</id>
  <title>yexca'Blog</title>
  <subtitle>yexca,blog,技术,博客,技术博客</subtitle>
  <updated>2023-09-06T03:05:46+08:00</updated>
  <author>
    <name>yexca</name>
    <uri>https://blog.yexca.net/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.yexca.net/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://blog.yexca.net/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 yexca </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>外观模式</title>
    <link href="https://blog.yexca.net/archives/121" rel="alternate" type="text/html" title="外观模式" />
    <published>2023-09-06T03:02:00+08:00</published>
  
    <updated>2023-09-06T03:02:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/121</id>
    <content src="https://blog.yexca.net/archives/121" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Facade Pattern 对象结构型模式

意图

为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

结构



其中：


  Facade 知道哪些子系统类负责处理请求；将客户的请求代理给适当的子系统对象
  Subsystem classes 实现子系统的功能；处理有 Facade 对象指派的任务；没有 Facade 的任何相关信息，即没有指向 Facade 的指针


适用性

Facade 模式适用于：


  要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制，但也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的默认视图，这一视图对大多数用户来说已经足够...
    </summary>
  

  </entry>

  
  <entry>
    <title>装饰器模式</title>
    <link href="https://blog.yexca.net/archives/120" rel="alternate" type="text/html" title="装饰器模式" />
    <published>2023-09-05T21:45:00+08:00</published>
  
    <updated>2023-09-05T21:45:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/120</id>
    <content src="https://blog.yexca.net/archives/120" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Decorator Pattern 对象结构型模式

意图

动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator 模式比生成子类更加灵活

结构



其中：


  Component 定义一个对象接口，可以给这些对象动态地添加职责
  ConcreteComponent 定义一个对象，可以给这个对象添加一些职责
  Decorator 维持一个指向 Component 对象的指针，并定义一个与 Component 接口一致的接口
  ConcreteDecorator 向组件添加职责


适用性

Decorator 模式适用于：


  在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
  处理那些可以撤销的职责
  当不能采用生成子类的方式进行扩充时，一种情况是，可能有大量独立的拓展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长...
    </summary>
  

  </entry>

  
  <entry>
    <title>组合模式</title>
    <link href="https://blog.yexca.net/archives/119" rel="alternate" type="text/html" title="组合模式" />
    <published>2023-09-03T15:44:00+08:00</published>
  
    <updated>2023-09-03T15:44:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/119</id>
    <content src="https://blog.yexca.net/archives/119" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Composite Pattern 对象结构型模式

意图

将对象组合成树型结构以表示 “部分 - 整体” 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性

结构



其中：


  Component 为组合中的对象声明接口；在适当情况下实现所有类共有接口的默认行为；声明一个接口用于访问和管理 Component 的子组件；(可选) 在递归结构中定义一个接口，用于访问一个父组件，并在合适的情况下实现它
  Leaf 在组合中表示叶结点对象，叶结点没有子结点；在组合中定义图元对象的行为
  Composite 定义所有子组件的那些组件的行为；存储子组件；在 Component 接口中实现与子组件有关的操作
  Client 通过 Component 接口操纵组合组件的对象


适用性

Composite 模式适用于：


  想表示对象的部分 - ...
    </summary>
  

  </entry>

  
  <entry>
    <title>桥接模式</title>
    <link href="https://blog.yexca.net/archives/118" rel="alternate" type="text/html" title="桥接模式" />
    <published>2023-09-02T17:34:00+08:00</published>
  
    <updated>2023-09-02T17:34:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/118</id>
    <content src="https://blog.yexca.net/archives/118" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Bridge Pattern 对象结构型模式

意图

将抽象部分与其实现部分分离，使它们都可以独立地变化

结构



其中：


  Abstraction 定义抽象类的接口，维护一个指向 Implementor 类型对象的指针
  RefinedAbstraction 扩充由 Abstraction 定义的接口
  Implementor 定义实现类的接口，该接口不一定要与 Abstraction 的接口完全一致；事实上这两个接口可以完全不同
一般来说，Implementor 接口仅提供基本操作，而 Abstraction 定义了基于这些基本操作的较高层次的操作
  ConcreteImplementor 实现 Implementor 接口并定义它的具体实现


适用性

Bridge 模式适用于：


  不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能...
    </summary>
  

  </entry>

  
  <entry>
    <title>适配器模式</title>
    <link href="https://blog.yexca.net/archives/117" rel="alternate" type="text/html" title="适配器模式" />
    <published>2023-09-01T15:03:00+08:00</published>
  
    <updated>2023-09-02T17:37:54+08:00</updated>
  
    <id>https://blog.yexca.net/archives/117</id>
    <content src="https://blog.yexca.net/archives/117" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Adapter Pattern 类结构型模式/对象结构型模式

意图

将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

结构


  类适配器使用多重继承对一个接口与另一个接口进行匹配





  对象适配器依赖于对象组合




其中：


  Target 定义 Client 使用的与特定领域相关的接口
  Client 与符合 Target 接口的对象协同
  Adaptee 定义一个已经存在的接口，这个接口需要适配
  Adapter 对 Adaptee 的接口与 Target 接口进行适配


适用性

Adapter 模式适用于：


  想使用一个已经存在的类，而它的接口不符合要求
  想创建一个可以服用的类，该类可以与其他不相关的类或不可预见的类 (即那些接口可能不一定兼容的类) 协同工作
...
    </summary>
  

  </entry>

</feed>


