

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.yexca.net/</id>
  <title>yexca'Blog</title>
  <subtitle>yexca,blog,技术,博客,技术博客</subtitle>
  <updated>2024-03-11T16:42:32+08:00</updated>
  <author>
    <name>yexca</name>
    <uri>https://blog.yexca.net/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.yexca.net/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="zh"
    href="https://blog.yexca.net/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2024 yexca </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>CSS 三大特性</title>
    <link href="https://blog.yexca.net/archives/164" rel="alternate" type="text/html" title="CSS 三大特性" />
    <published>2024-03-11T16:38:00+08:00</published>
  
    <updated>2024-03-11T16:38:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/164</id>
    <content src="https://blog.yexca.net/archives/164" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="前端" />
    
    <category term="CSS" />
    
  

  
    <summary>
      





      CSS 三大特性：继承性、层叠性、优先级

继承性

子级默认继承父级的文字控制属性，若子级有自己的样式则不继承

&amp;lt;style&amp;gt;
	body {
		font: 30px/0.5 楷体;
		color: aqua;
	}
&amp;lt;/style&amp;gt;

&amp;lt;body&amp;gt;
	&amp;lt;div&amp;gt;div&amp;lt;/div&amp;gt;
	&amp;lt;p&amp;gt;p&amp;lt;/p&amp;gt;
	&amp;lt;span&amp;gt;span&amp;lt;/span&amp;gt;
		
	&amp;lt;a href="#"&amp;gt;不继承颜色&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;


层叠性

选择器类型相同时：


  相同的属性会覆盖：后面的 CSS 属性覆盖前面的 CSS 属性
  不同的属性会叠加：不同的 CSS 属性都生效


&amp;lt;style&amp;gt;
	div {
		color: red;
	...
    </summary>
  

  </entry>

  
  <entry>
    <title>CSS 选择器</title>
    <link href="https://blog.yexca.net/archives/163" rel="alternate" type="text/html" title="CSS 选择器" />
    <published>2024-03-02T17:15:00+08:00</published>
  
    <updated>2024-03-02T17:15:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/163</id>
    <content src="https://blog.yexca.net/archives/163" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="前端" />
    
    <category term="CSS" />
    
  

  
    <summary>
      





      CSS 引入方式

CSS 有三种引入方式，第一种为内部样式表，此方式仅学习使用

&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
        &amp;lt;style&amp;gt;
        	/* 此处写 CSS */
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;


第二种为行内样式，一般配合 JavaScript 使用

&amp;lt;div style="此处写 CSS"&amp;gt;&amp;lt;/div&amp;gt;


最后一种为外部样式表，将 CSS 代码写在单独文件，通过 link 标签引入，开发时常用

&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/...
    </summary>
  

  </entry>

  
  <entry>
    <title>GoLand 面向对象</title>
    <link href="https://blog.yexca.net/archives/162" rel="alternate" type="text/html" title="GoLand 面向对象" />
    <published>2024-03-01T15:35:00+08:00</published>
  
    <updated>2024-03-01T15:35:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/162</id>
    <content src="https://blog.yexca.net/archives/162" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="编程基础" />
    
    <category term="编程语言" />
    
  

  
    <summary>
      





      通过使用结构体构建类与对象的概念


  了解面向对象：面向对象基础


struct

首先是自定义类型，使用 type 关键字，类似于 C

package main

import "fmt"

type myType int

func main() {
	var a myType
	fmt.Println("a =", a)
	fmt.Printf("type of a is %T", a)
}

/*
 * 输出
 * a = 0
 * type of a is main.myTye
 */


定义类型使用 stuct

package main

import "fmt"

type Person struct {
	name string
	age  int
}

func main() {
	var zhang Person
	zhang.name = "zhan...
    </summary>
  

  </entry>

  
  <entry>
    <title>注册中心 - Eureka</title>
    <link href="https://blog.yexca.net/archives/161" rel="alternate" type="text/html" title="注册中心 - Eureka" />
    <published>2024-02-29T16:53:00+08:00</published>
  
    <updated>2024-02-29T16:53:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/161</id>
    <content src="https://blog.yexca.net/archives/161" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="后端" />
    
    <category term="Spring" />
    
  

  
    <summary>
      





      引入注册中心之前先引入提供者与消费者概念

提供者与消费者

服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）

服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）

提供者与消费者是相对的，一个服务既可以是提供者也可以是消费者

Eureka

若提供者有多个，消费者如何获取提供者信息，如何得知提供者的健康状态

在启动时，微服务向 Eureka 注册服务信息，消费者可通过 Eureka 拉取提供者信息，然后远程调用。微服务会每 30s 向 Eureka 说明自己还活着，Eureka 会更新记录服务列表信息，剔除不健康服务器

如果有多个服务提供者，消费者利用负载均衡算法，从服务列表中挑选一个

搭建

新建一个 Maven Module，引入依赖

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org....
    </summary>
  

  </entry>

  
  <entry>
    <title>GoLand 切片</title>
    <link href="https://blog.yexca.net/archives/160" rel="alternate" type="text/html" title="GoLand 切片" />
    <published>2024-02-27T20:00:00+08:00</published>
  
    <updated>2024-02-27T20:00:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/160</id>
    <content src="https://blog.yexca.net/archives/160" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="编程基础" />
    
    <category term="编程语言" />
    
  

  
    <summary>
      





      Go 的切片是对数组的抽象

数组

数组的长度不可改变

package main

import "fmt"

func main() {
    // 定义方式一
	var arr1 [10]int
    // 遍历
	for i := 0; i &amp;lt; len(arr1); i++ {
		fmt.Println("arr1[", i, "]:", arr1[i])
	}

    // 定义方式二，赋值
	arr2 := [10]int{0, 1, 2, 3}
    // range遍历
	for index, value := range arr2 {
		fmt.Println("index =", index, "value =", value)
	}

    // 定义不同长度
	var arr3 [4]int

	fmt.Printf("type of a...
    </summary>
  

  </entry>

</feed>


