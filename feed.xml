

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.yexca.net/</id>
  <title>yexca'Blog</title>
  <subtitle>yexca,blog,技术,博客,技术博客</subtitle>
  <updated>2023-09-03T16:00:15+08:00</updated>
  <author>
    <name>yexca</name>
    <uri>https://blog.yexca.net/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.yexca.net/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://blog.yexca.net/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 yexca </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>组合模式</title>
    <link href="https://blog.yexca.net/archives/119" rel="alternate" type="text/html" title="组合模式" />
    <published>2023-09-03T15:44:00+08:00</published>
  
    <updated>2023-09-03T15:44:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/119</id>
    <content src="https://blog.yexca.net/archives/119" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Composite Pattern 对象结构型模式

意图

将对象组合成树型结构以表示 “部分 - 整体” 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性

结构



其中：


  Component 为组合中的对象声明接口；在适当情况下实现所有类共有接口的默认行为；声明一个接口用于访问和管理 Component 的子组件；(可选) 在递归结构中定义一个接口，用于访问一个父组件，并在合适的情况下实现它
  Leaf 在组合中表示叶结点对象，叶结点没有子结点；在组合中定义图元对象的行为
  Composite 定义所有子组件的那些组件的行为；存储子组件；在 Component 接口中实现与子组件有关的操作
  Client 通过 Component 接口操纵组合组件的对象


适用性

Composite 模式适用于：


  想表示对象的部分 - ...
    </summary>
  

  </entry>

  
  <entry>
    <title>桥接模式</title>
    <link href="https://blog.yexca.net/archives/118" rel="alternate" type="text/html" title="桥接模式" />
    <published>2023-09-02T17:34:00+08:00</published>
  
    <updated>2023-09-02T17:34:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/118</id>
    <content src="https://blog.yexca.net/archives/118" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Bridge Pattern 对象结构型模式

意图

将抽象部分与其实现部分分离，使它们都可以独立地变化

结构



其中：


  Abstraction 定义抽象类的接口，维护一个指向 Implementor 类型对象的指针
  RefinedAbstraction 扩充由 Abstraction 定义的接口
  Implementor 定义实现类的接口，该接口不一定要与 Abstraction 的接口完全一致；事实上这两个接口可以完全不同
一般来说，Implementor 接口仅提供基本操作，而 Abstraction 定义了基于这些基本操作的较高层次的操作
  ConcreteImplementor 实现 Implementor 接口并定义它的具体实现


适用性

Bridge 模式适用于：


  不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能...
    </summary>
  

  </entry>

  
  <entry>
    <title>适配器模式</title>
    <link href="https://blog.yexca.net/archives/117" rel="alternate" type="text/html" title="适配器模式" />
    <published>2023-09-01T15:03:00+08:00</published>
  
    <updated>2023-09-02T17:37:54+08:00</updated>
  
    <id>https://blog.yexca.net/archives/117</id>
    <content src="https://blog.yexca.net/archives/117" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Adapter Pattern 类结构型模式/对象结构型模式

意图

将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

结构


  类适配器使用多重继承对一个接口与另一个接口进行匹配





  对象适配器依赖于对象组合




其中：


  Target 定义 Client 使用的与特定领域相关的接口
  Client 与符合 Target 接口的对象协同
  Adaptee 定义一个已经存在的接口，这个接口需要适配
  Adapter 对 Adaptee 的接口与 Target 接口进行适配


适用性

Adapter 模式适用于：


  想使用一个已经存在的类，而它的接口不符合要求
  想创建一个可以服用的类，该类可以与其他不相关的类或不可预见的类 (即那些接口可能不一定兼容的类) 协同工作
...
    </summary>
  

  </entry>

  
  <entry>
    <title>使用 CNAME 将域名重定向到带路径的 URL</title>
    <link href="https://blog.yexca.net/archives/116" rel="alternate" type="text/html" title="使用 CNAME 将域名重定向到带路径的 URL" />
    <published>2023-08-28T15:31:00+08:00</published>
  
    <updated>2023-08-28T16:02:27+08:00</updated>
  
    <id>https://blog.yexca.net/archives/116</id>
    <content src="https://blog.yexca.net/archives/116" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="技术工具" />
    
  

  
    <summary>
      





      之前拥有服务器的时候虽然有过此想法，但毕竟只要服务器再开个站点就解决了并没有深入研究，如今服务器到期将 Blog 搬到 Github 上想要继续这样无疑是不可能的，于是便寻求解决方法

失败的历程

虽然失败了，但还是要记录下来，肯定是我不会用

之前只是试着玩玩，仅从 DNS 的 CNAME 试了发现不行便放弃了，这次使用互联网搜索”域名定向到路径 url”，从第一条搜索结果 https://cloud.tencent.com/developer/ask/sof/89340 得知工具网站：http://redirect.center/

例子

从 https://acg.yexca.net 重定向到 https://blog.yexca.net/acg

按网站描述，CNAME 内容应该为 blog.yexca.net.opts-slash.acg.opts-https.redi...
    </summary>
  

  </entry>

  
  <entry>
    <title>单例模式</title>
    <link href="https://blog.yexca.net/archives/115" rel="alternate" type="text/html" title="单例模式" />
    <published>2023-07-05T13:58:00+08:00</published>
  
    <updated>2023-07-05T13:58:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/115</id>
    <content src="https://blog.yexca.net/archives/115" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Singleton Pattern 对象创建型模式

意图

保证一个类仅有一个实例，并提供一个访问它的全局访问点

结构



其中：


  Singleton 指定一个 Instance 操作，允许客户访问它的唯一实例
  Instance 是一个类操作；可能负责创建它自己的唯一实例


适用性

Singleton 模式适用于：


  当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时
  当这个唯一实例应该是通过子类化可扩展的，并且客户无须更改代码就能使用一个扩展的实例时


例子

public class main{
    // s1 和 s2 是同一个实例 (地址相同)
    Singleton s1 = Singleton.getInstance();
    Singleton s2 = Singleton.getInstance();
}

cl...
    </summary>
  

  </entry>

</feed>


