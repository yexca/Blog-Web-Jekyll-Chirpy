

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.yexca.net/</id>
  <title>yexca'Blog</title>
  <subtitle>yexca,blog,技术,博客,技术博客</subtitle>
  <updated>2023-09-08T12:18:34+08:00</updated>
  <author>
    <name>yexca</name>
    <uri>https://blog.yexca.net/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.yexca.net/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://blog.yexca.net/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 yexca </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>代理模式</title>
    <link href="https://blog.yexca.net/archives/123" rel="alternate" type="text/html" title="代理模式" />
    <published>2023-09-08T12:15:00+08:00</published>
  
    <updated>2023-09-08T12:15:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/123</id>
    <content src="https://blog.yexca.net/archives/123" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Proxy Pattern 对象结构型模式

意图

为其他对象提供一种代理以控制对这个对象的访问

结构



其中：


  Proxy 保存一个引用使得代理可以访问实体；提供一个与 Subject 的接口相同的接口，使代理可以用来代替实体；控制对实体的存取，并可能负责创建和删除它
  Subject 定义 RealSubject 和 Proxy 的共用接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy
  RealSubject 定义 Proxy 所代表的实体


适用性

Proxy 模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候，常见的情况有：


  远程代理 (Remote Proxy) 为一个对象在不同地址空间提供局部代表
  虚代理 (Virtual Proxy) 根据需要对原始对象的访问，用于对象应该有不同的访问权限的时候
...
    </summary>
  

  </entry>

  
  <entry>
    <title>享元模式</title>
    <link href="https://blog.yexca.net/archives/122" rel="alternate" type="text/html" title="享元模式" />
    <published>2023-09-07T13:54:00+08:00</published>
  
    <updated>2023-09-07T13:54:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/122</id>
    <content src="https://blog.yexca.net/archives/122" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Flyweight Pattern 对象结构型模式

意图

运用共享技术有效地支持大量细粒度的对象

结构



其中：


  
    Flyweight 描述一个接口，通过这个接口 Flyweight 可以接受并作用于外部状态
  
  
    ConcreteFlyweight 实现 Flyweight 接口，并为内部状态 (如果有) 增加存储空间。ConcreteFlyweight 对象必项是可共享的。它所存储的状态必须是内部的，即它必须独立于 ConcreteFlyweight 对象的场景
  
  
    并非所有的 Flyweight 子类都需要被共享。Flyweight 接口使共享成为可能，但它并不强制共亨。在 Flyweight 对象结构的某些层次，UnsharedConcreteFlyweight 对象通常将 ConcreteFlyweight 对象作为子...
    </summary>
  

  </entry>

  
  <entry>
    <title>外观模式</title>
    <link href="https://blog.yexca.net/archives/121" rel="alternate" type="text/html" title="外观模式" />
    <published>2023-09-06T03:02:00+08:00</published>
  
    <updated>2023-09-06T03:02:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/121</id>
    <content src="https://blog.yexca.net/archives/121" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Facade Pattern 对象结构型模式

意图

为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

结构



其中：


  Facade 知道哪些子系统类负责处理请求；将客户的请求代理给适当的子系统对象
  Subsystem classes 实现子系统的功能；处理有 Facade 对象指派的任务；没有 Facade 的任何相关信息，即没有指向 Facade 的指针


适用性

Facade 模式适用于：


  要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具有可重用性，也更容易对子系统进行定制，但也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的默认视图，这一视图对大多数用户来说已经足够...
    </summary>
  

  </entry>

  
  <entry>
    <title>装饰器模式</title>
    <link href="https://blog.yexca.net/archives/120" rel="alternate" type="text/html" title="装饰器模式" />
    <published>2023-09-05T21:45:00+08:00</published>
  
    <updated>2023-09-05T21:45:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/120</id>
    <content src="https://blog.yexca.net/archives/120" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Decorator Pattern 对象结构型模式

意图

动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator 模式比生成子类更加灵活

结构



其中：


  Component 定义一个对象接口，可以给这些对象动态地添加职责
  ConcreteComponent 定义一个对象，可以给这个对象添加一些职责
  Decorator 维持一个指向 Component 对象的指针，并定义一个与 Component 接口一致的接口
  ConcreteDecorator 向组件添加职责


适用性

Decorator 模式适用于：


  在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
  处理那些可以撤销的职责
  当不能采用生成子类的方式进行扩充时，一种情况是，可能有大量独立的拓展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长...
    </summary>
  

  </entry>

  
  <entry>
    <title>组合模式</title>
    <link href="https://blog.yexca.net/archives/119" rel="alternate" type="text/html" title="组合模式" />
    <published>2023-09-03T15:44:00+08:00</published>
  
    <updated>2023-09-03T15:44:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/119</id>
    <content src="https://blog.yexca.net/archives/119" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Composite Pattern 对象结构型模式

意图

将对象组合成树型结构以表示 “部分 - 整体” 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性

结构



其中：


  Component 为组合中的对象声明接口；在适当情况下实现所有类共有接口的默认行为；声明一个接口用于访问和管理 Component 的子组件；(可选) 在递归结构中定义一个接口，用于访问一个父组件，并在合适的情况下实现它
  Leaf 在组合中表示叶结点对象，叶结点没有子结点；在组合中定义图元对象的行为
  Composite 定义所有子组件的那些组件的行为；存储子组件；在 Component 接口中实现与子组件有关的操作
  Client 通过 Component 接口操纵组合组件的对象


适用性

Composite 模式适用于：


  想表示对象的部分 - ...
    </summary>
  

  </entry>

</feed>


