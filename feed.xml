

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.yexca.net/</id>
  <title>yexca'Blog</title>
  <subtitle>yexca,blog,技术,博客,技术博客</subtitle>
  <updated>2023-12-25T21:09:59+08:00</updated>
  <author>
    <name>yexca</name>
    <uri>https://blog.yexca.net/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.yexca.net/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="zh"
    href="https://blog.yexca.net/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 yexca </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>模板方法模式</title>
    <link href="https://blog.yexca.net/archives/138" rel="alternate" type="text/html" title="模板方法模式" />
    <published>2023-12-25T21:06:00+08:00</published>
  
    <updated>2023-12-25T21:06:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/138</id>
    <content src="https://blog.yexca.net/archives/138" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
    <category term="设计模式" />
    
  

  
    <summary>
      





      Template Method Pattern 类行为型模式

意图

定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤

结构



其中：


  AbstractClass (抽象类) 定义抽象的原语操作，具体的子类将重定义它们以实现一个算法的各步骤；实现模板方法，定一个算法的骨架，该模板方法不仅调用原语操作，也调用定义在 AbstractClass 或其他对象中的操作
  ConcreteClass (具体类) 实现原语操作以完成算法中与特定子类相关的步骤


适用性

Template Method 模式适用于：


  一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现
  各子类中公共的行为应被提取出来并集中到一个公共父类中，以避免代码重复
  控制子类扩展。模板...
    </summary>
  

  </entry>

  
  <entry>
    <title>策略模式</title>
    <link href="https://blog.yexca.net/archives/137" rel="alternate" type="text/html" title="策略模式" />
    <published>2023-12-24T18:30:00+08:00</published>
  
    <updated>2023-12-24T18:30:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/137</id>
    <content src="https://blog.yexca.net/archives/137" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
    <category term="设计模式" />
    
  

  
    <summary>
      





      Strategy Pattern 对象行为型模式

意图

定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化

结构



其中：


  
    Strategy (策略) 定义所有支持的算法的公共接口。Context 使用这个接口来调用某 ConcreteStrategy 定义的算法
  
  
    ConcreteStrategy (具体策略) 以 Strategy 接口实现某具体算法
  
  
    Context (上下文) 用一个 ConcreteStrategy 对象来配置；维护一个对 Strategy 对象的引用；可定义一个接口来让 Strategy 访问它的数据
  


适用性

Strategy 模式适用于：


  
    许多相关的类仅仅是行为有异。”策略” 提供了一种用多个行为中的一个...
    </summary>
  

  </entry>

  
  <entry>
    <title>状态模式</title>
    <link href="https://blog.yexca.net/archives/136" rel="alternate" type="text/html" title="状态模式" />
    <published>2023-12-22T15:11:00+08:00</published>
  
    <updated>2023-12-22T16:06:06+08:00</updated>
  
    <id>https://blog.yexca.net/archives/136</id>
    <content src="https://blog.yexca.net/archives/136" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
    <category term="设计模式" />
    
  

  
    <summary>
      





      State Pattern 对象行为型模式

意图

允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类

结构



其中：


  
    Context (上下文) 定义客户感兴趣的接口：维护一个 ConcerteState 子类的实例，这个实例定义当前状态
  
  
    State (状态) 定义一个接口以封装与 Context 的一个特定状态相关的行为
  
  
    ConcreteState (具体状态子类) 毎个子类实现与 Context 的一个状态相关的行为
  


适用性


  
    一个对象的行为决定于它的状态，并且它必领在运行吋刻根据状态改变它的行为
  
  
    一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构，Stat...
    </summary>
  

  </entry>

  
  <entry>
    <title>Ajax 与 Axios</title>
    <link href="https://blog.yexca.net/archives/135" rel="alternate" type="text/html" title="Ajax 与 Axios" />
    <published>2023-12-21T13:32:00+08:00</published>
  
    <updated>2023-12-21T13:32:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/135</id>
    <content src="https://blog.yexca.net/archives/135" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="前端" />
    
    <category term="JavaScript" />
    
  

  
    <summary>
      





      Ajax 与 Axios

Asynchronous JavaScript And XML，异步的 JS 和 XML。作用：


  数据交换：通过 Ajax 可以给服务器发送请求，并获取服务器响应的数据
  异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术


使用场景：搜索联想、用户名是否可用等

同步与异步

同步指在访问网页时进行某操作需要请求服务器，在服务器处理时网页不可操作，直到服务器响应客户端时才可继续操作

而异步在请求服务器的同时，客户端可以执行其他操作

原生 Ajax

首先创建 XMLHttpRequest 对象 (用于和服务器交换数据)，然后向服务器发送请求，最后获取服务器响应数据

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang="en"&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta c...
    </summary>
  

  </entry>

  
  <entry>
    <title>观察者模式</title>
    <link href="https://blog.yexca.net/archives/134" rel="alternate" type="text/html" title="观察者模式" />
    <published>2023-12-21T01:18:00+08:00</published>
  
    <updated>2023-12-22T16:06:06+08:00</updated>
  
    <id>https://blog.yexca.net/archives/134</id>
    <content src="https://blog.yexca.net/archives/134" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
    <category term="设计模式" />
    
  

  
    <summary>
      





      观察者模式

Observer Pattern 对象行为型模式

意图
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变吋，所有依赖于它的对象都得到通知并被自动更新
结构



其中：


  Subject (目标) 知道它的观察者，可以有任意多个观察者观察同一个目标；提供注册和删除观察者对象的接口
  Observer (观察者) 为那些在”目标发生改变时需获得通知的对象定义一个更新接口
  ConcreteSubject (具体目标) 将有关状态存入各 ConcreteObserver 对象：当它的状态发生改变时，向它的各个观察者发出通知
  ConcreteObserver (具体观察者) 维护一个指向 ConcreteSubject 对象的引用：存储有关状态，这些状态应与目标的状态保持一致：实现 Observer 的更新接口，以使自身状态与目标的状态保持一致


...
    </summary>
  

  </entry>

</feed>


