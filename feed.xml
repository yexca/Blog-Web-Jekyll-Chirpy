

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.yexca.net/</id>
  <title>yexca'Blog</title>
  <subtitle>yexca,blog,技术,博客,技术博客</subtitle>
  <updated>2023-09-01T15:07:39+08:00</updated>
  <author>
    <name>yexca</name>
    <uri>https://blog.yexca.net/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.yexca.net/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://blog.yexca.net/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 yexca </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>适配器模式</title>
    <link href="https://blog.yexca.net/archives/117" rel="alternate" type="text/html" title="适配器模式" />
    <published>2023-09-01T15:03:00+08:00</published>
  
    <updated>2023-09-01T15:03:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/117</id>
    <content src="https://blog.yexca.net/archives/117" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Adapter Pattern 类结构型模式/对象结构型模式

意图

将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

结构


  类适配器使用多重继承对一个接口与另一个接口进行匹配





  对象适配器依赖于对象组合




其中：


  Target 定义 Client 使用的与特定领域相关的接口
  Client 与符合 Target 接口的对象协同
  Adaptee 定义一个已经存在的接口，这个接口需要适配
  Adapter 对 Adaptee 的接口与 Target 接口进行适配


适用性

Adapter 模式适用于：


  想使用一个已经存在的类，而它的接口不符合要求
  想创建一个可以服用的类，该类可以与其他不相关的类或不可预见的类 (即那些接口可能不一定兼容的类) 协同工作
...
    </summary>
  

  </entry>

  
  <entry>
    <title>使用 CNAME 将域名重定向到带路径的 URL</title>
    <link href="https://blog.yexca.net/archives/116" rel="alternate" type="text/html" title="使用 CNAME 将域名重定向到带路径的 URL" />
    <published>2023-08-28T15:31:00+08:00</published>
  
    <updated>2023-08-28T16:02:27+08:00</updated>
  
    <id>https://blog.yexca.net/archives/116</id>
    <content src="https://blog.yexca.net/archives/116" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="技术工具" />
    
  

  
    <summary>
      





      之前拥有服务器的时候虽然有过此想法，但毕竟只要服务器再开个站点就解决了并没有深入研究，如今服务器到期将 Blog 搬到 Github 上想要继续这样无疑是不可能的，于是便寻求解决方法

失败的历程

虽然失败了，但还是要记录下来，肯定是我不会用

之前只是试着玩玩，仅从 DNS 的 CNAME 试了发现不行便放弃了，这次使用互联网搜索”域名定向到路径 url”，从第一条搜索结果 https://cloud.tencent.com/developer/ask/sof/89340 得知工具网站：http://redirect.center/

例子

从 https://acg.yexca.net 重定向到 https://blog.yexca.net/acg

按网站描述，CNAME 内容应该为 blog.yexca.net.opts-slash.acg.opts-https.redi...
    </summary>
  

  </entry>

  
  <entry>
    <title>单例模式</title>
    <link href="https://blog.yexca.net/archives/115" rel="alternate" type="text/html" title="单例模式" />
    <published>2023-07-05T13:58:00+08:00</published>
  
    <updated>2023-07-05T13:58:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/115</id>
    <content src="https://blog.yexca.net/archives/115" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Singleton Pattern 对象创建型模式

意图

保证一个类仅有一个实例，并提供一个访问它的全局访问点

结构



其中：


  Singleton 指定一个 Instance 操作，允许客户访问它的唯一实例
  Instance 是一个类操作；可能负责创建它自己的唯一实例


适用性

Singleton 模式适用于：


  当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时
  当这个唯一实例应该是通过子类化可扩展的，并且客户无须更改代码就能使用一个扩展的实例时


例子

public class main{
    // s1 和 s2 是同一个实例 (地址相同)
    Singleton s1 = Singleton.getInstance();
    Singleton s2 = Singleton.getInstance();
}

cl...
    </summary>
  

  </entry>

  
  <entry>
    <title>アイドルマスター ミリオンライブ！的 IP 规则</title>
    <link href="https://blog.yexca.net/archives/114" rel="alternate" type="text/html" title="アイドルマスター ミリオンライブ！的 IP 规则" />
    <published>2023-06-09T23:32:09+08:00</published>
  
    <updated>2023-06-09T23:32:09+08:00</updated>
  
    <id>https://blog.yexca.net/archives/114</id>
    <content src="https://blog.yexca.net/archives/114" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="日常" />
    
  

  
    <summary>
      





      最近游玩 ミリシタ 时连接不上，遂寻找解决方法 （顺便试试 Spotify 的嵌入效果

域名

theaterdays.appspot.com





最近雨宿りの曲が大好きので、よく聞いていた。Last.fm で過去30日間雨宿りの「猫かぶり」は人気トラック一番になった。で、トップアーティストじゃない？トップアーティスト、もちろん湊あくあ！　　

草、ミリシタの文章で何を書いたか、どっちもミリシタと関係ないもん！


clash

通过设置组更好选择

首先设置 JP 组

proxy-groups:
- name: JP
  type: select
  proxies:
  - your jp proxy name
  - your jp proxy name


然后添加规则

rules:
- DOMAIN-SUFFIX,theaterdays.appspot.com,...
    </summary>
  

  </entry>

  
  <entry>
    <title>原型模式</title>
    <link href="https://blog.yexca.net/archives/113" rel="alternate" type="text/html" title="原型模式" />
    <published>2023-06-02T19:31:44+08:00</published>
  
    <updated>2023-06-02T19:31:44+08:00</updated>
  
    <id>https://blog.yexca.net/archives/113</id>
    <content src="https://blog.yexca.net/archives/113" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Prototype Pattern 对象创建型模式

意图

用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象

结构



其中：


  Prototype 声明一个复制自身的接口
  ConcretePrototype 实现一个复制自身的操作
  Client 让一个原型复制自身从而创建一个新的对象


适用性

Prototype 模式适用于：


  当一个系统应该独立于它的产品创建、构成和表示时
  当要实例化的类是在运行时刻指定时，例如，通过动态装载
  为了避免创建一个与产品类层次平行的工厂类层次时
  当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些


例子 1

public class main{
    Product p1 = new Product(2023, 3....
    </summary>
  

  </entry>

</feed>


