

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.yexca.net/</id>
  <title>yexca'Blog</title>
  <subtitle>yexca,blog,技术,博客,技术博客</subtitle>
  <updated>2023-10-15T19:18:06+08:00</updated>
  <author>
    <name>yexca</name>
    <uri>https://blog.yexca.net/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.yexca.net/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://blog.yexca.net/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 yexca </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>中介者模式</title>
    <link href="https://blog.yexca.net/archives/128" rel="alternate" type="text/html" title="中介者模式" />
    <published>2023-10-15T17:14:00+08:00</published>
  
    <updated>2023-10-15T19:17:43+08:00</updated>
  
    <id>https://blog.yexca.net/archives/128</id>
    <content src="https://blog.yexca.net/archives/128" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Mediator Pattern 对象行为型模式

意图

用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间地交互

结构



其中：


  Mediator (中介者) 定义一个接口用于各同事 (Colleague) 对象通信
  ConcreteMediator (具体中介中介) 通过协调各同事对象实现协作行为；了解并维护它的各个同事
  Colleague class (同事类) 知道它的中介者对象；每一个同事类对象在需要与其他同事通信的时候与它的中介者通信


适用性

Mediator 模式适用于：


  一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解
  一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象
  想定制一个分布在多个类中的行为，而又不想...
    </summary>
  

  </entry>

  
  <entry>
    <title>迭代器模式</title>
    <link href="https://blog.yexca.net/archives/127" rel="alternate" type="text/html" title="迭代器模式" />
    <published>2023-10-12T09:09:00+08:00</published>
  
    <updated>2023-10-15T19:17:43+08:00</updated>
  
    <id>https://blog.yexca.net/archives/127</id>
    <content src="https://blog.yexca.net/archives/127" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Iterator Pattern 对象行为型模式

意图

提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示

结构



其中：


  Iterator (迭代器) 定义访问和遍历元素的接口
  ConcreteIterator (具体迭代器) 实现迭代器接口；对该聚合遍历时跟踪当前位置
  Aggregate (聚合) 定义创建相应迭代器对象的接口
  ConcreteAggregate (具体聚合) 实现创建相应迭代器的接口，该操作返回 ConcreteIterator 的一个适当的实例


适用性

Iterator 模式适用于：


  访问一个聚合对象的内容而无需暴露它的内部表示
  支持对聚合对象的多种遍历
  为遍历不同的聚合结构提供一个统一的接口


利用 Java 已实现迭代器

import java.util.ArrayList;
...
    </summary>
  

  </entry>

  
  <entry>
    <title>解释器模式</title>
    <link href="https://blog.yexca.net/archives/126" rel="alternate" type="text/html" title="解释器模式" />
    <published>2023-10-09T17:31:00+08:00</published>
  
    <updated>2023-10-09T17:31:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/126</id>
    <content src="https://blog.yexca.net/archives/126" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Interpreter Pattern 类行为型模式

意图

给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子

结构



其中：


  AbstractExpression 声明一个程序的解释操作，这个接口为抽象语法树中所有的结点所共享
  TerminalExpression 实现与文法中的终结符相关联的解释操作；一个句子中的每个终结符需要该类的一个实例
  NonterminalExpression 对文法中的每一条规则都需要一个 NonterminalExpression 类；为每个符号都维护一个 AbstractExpression 类型的实例变量；为文法中的非终结符实现解释 (Interpret) 操作
  Context 包含解释器之外的一些全局信息
  Client 构建 (或被给定) 表示该文法定义的语言中一个特定...
    </summary>
  

  </entry>

  
  <entry>
    <title>命令模式</title>
    <link href="https://blog.yexca.net/archives/125" rel="alternate" type="text/html" title="命令模式" />
    <published>2023-09-10T15:26:00+08:00</published>
  
    <updated>2023-10-09T17:49:52+08:00</updated>
  
    <id>https://blog.yexca.net/archives/125</id>
    <content src="https://blog.yexca.net/archives/125" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Command Pattern 对象行为型模式

意图

将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作

结构



其中：


  Command 声明执行操作的接口
  ConcreteCommand 将一个接收者对象绑定于一个动作；调用接收者相应的操作，以实现 Execute
  Client 创建一个具体命令对象并设定它的接收者
  Invoker 要求该命令执行这个请求
  Receiver 知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者


适用性

Command 模式适用于：


  抽象出待执行的动作以参数化某对象
  在不同的时刻指定、排列和执行请求
  支持取消操作
  支持修改日志
  用构建在原语操作上的高层操作构造一个系统


例子

public class Comm...
    </summary>
  

  </entry>

  
  <entry>
    <title>责任链模式</title>
    <link href="https://blog.yexca.net/archives/124" rel="alternate" type="text/html" title="责任链模式" />
    <published>2023-09-09T07:02:00+08:00</published>
  
    <updated>2023-10-09T17:49:52+08:00</updated>
  
    <id>https://blog.yexca.net/archives/124</id>
    <content src="https://blog.yexca.net/archives/124" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Chain of Responsibility Pattern 对象行为型模式

意图
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止

结构



其中：


  Handler 定义一个处理请求的接口；(可选) 实现后继链
  ConcreteHandler 处理它所负责的请求；可访问它的后继者；如果可处理该请求，就处理它，否则将请求转发给后继者
  Client 向链上的具体处理者 (ConcreteHandler) 对象提交请求


适用性

Chain of Responsibility 模式适用于：


  有多个对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定
  想在不明确指定接收者的情况下向多个对象中的一个提交一个请求
  可处理一个请求的对象集合应被动态指定

...
    </summary>
  

  </entry>

</feed>


