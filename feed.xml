

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://blog.yexca.net/</id>
  <title>yexca'Blog</title>
  <subtitle>yexca,blog,技术,博客,技术博客</subtitle>
  <updated>2023-10-09T17:50:00+08:00</updated>
  <author>
    <name>yexca</name>
    <uri>https://blog.yexca.net/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://blog.yexca.net/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://blog.yexca.net/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator>
  <rights> © 2023 yexca </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>解释器模式</title>
    <link href="https://blog.yexca.net/archives/126" rel="alternate" type="text/html" title="解释器模式" />
    <published>2023-10-09T17:31:00+08:00</published>
  
    <updated>2023-10-09T17:31:00+08:00</updated>
  
    <id>https://blog.yexca.net/archives/126</id>
    <content src="https://blog.yexca.net/archives/126" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Interpreter Pattern 类行为型模式

意图

给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子

结构



其中：


  AbstractExpression 声明一个程序的解释操作，这个接口为抽象语法树中所有的结点所共享
  TerminalExpression 实现与文法中的终结符相关联的解释操作；一个句子中的每个终结符需要该类的一个实例
  NonterminalExpression 对文法中的每一条规则都需要一个 NonterminalExpression 类；为每个符号都维护一个 AbstractExpression 类型的实例变量；为文法中的非终结符实现解释 (Interpret) 操作
  Context 包含解释器之外的一些全局信息
  Client 构建 (或被给定) 表示该文法定义的语言中一个特定...
    </summary>
  

  </entry>

  
  <entry>
    <title>命令模式</title>
    <link href="https://blog.yexca.net/archives/125" rel="alternate" type="text/html" title="命令模式" />
    <published>2023-09-10T15:26:00+08:00</published>
  
    <updated>2023-10-09T17:49:52+08:00</updated>
  
    <id>https://blog.yexca.net/archives/125</id>
    <content src="https://blog.yexca.net/archives/125" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Command Pattern 对象行为型模式

意图

将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作

结构



其中：


  Command 声明执行操作的接口
  ConcreteCommand 将一个接收者对象绑定于一个动作；调用接收者相应的操作，以实现 Execute
  Client 创建一个具体命令对象并设定它的接收者
  Invoker 要求该命令执行这个请求
  Receiver 知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者


适用性

Command 模式适用于：


  抽象出待执行的动作以参数化某对象
  在不同的时刻指定、排列和执行请求
  支持取消操作
  支持修改日志
  用构建在原语操作上的高层操作构造一个系统


例子

public class Comm...
    </summary>
  

  </entry>

  
  <entry>
    <title>责任链模式</title>
    <link href="https://blog.yexca.net/archives/124" rel="alternate" type="text/html" title="责任链模式" />
    <published>2023-09-09T07:02:00+08:00</published>
  
    <updated>2023-10-09T17:49:52+08:00</updated>
  
    <id>https://blog.yexca.net/archives/124</id>
    <content src="https://blog.yexca.net/archives/124" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Chain of Responsibility Pattern 对象行为型模式

意图
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止

结构



其中：


  Handler 定义一个处理请求的接口；(可选) 实现后继链
  ConcreteHandler 处理它所负责的请求；可访问它的后继者；如果可处理该请求，就处理它，否则将请求转发给后继者
  Client 向链上的具体处理者 (ConcreteHandler) 对象提交请求


适用性

Chain of Responsibility 模式适用于：


  有多个对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定
  想在不明确指定接收者的情况下向多个对象中的一个提交一个请求
  可处理一个请求的对象集合应被动态指定

...
    </summary>
  

  </entry>

  
  <entry>
    <title>代理模式</title>
    <link href="https://blog.yexca.net/archives/123" rel="alternate" type="text/html" title="代理模式" />
    <published>2023-09-08T12:15:00+08:00</published>
  
    <updated>2023-10-09T17:49:52+08:00</updated>
  
    <id>https://blog.yexca.net/archives/123</id>
    <content src="https://blog.yexca.net/archives/123" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Proxy Pattern 对象结构型模式

意图

为其他对象提供一种代理以控制对这个对象的访问

结构



其中：


  Proxy 保存一个引用使得代理可以访问实体；提供一个与 Subject 的接口相同的接口，使代理可以用来代替实体；控制对实体的存取，并可能负责创建和删除它
  Subject 定义 RealSubject 和 Proxy 的共用接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy
  RealSubject 定义 Proxy 所代表的实体


适用性

Proxy 模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候，常见的情况有：


  远程代理 (Remote Proxy) 为一个对象在不同地址空间提供局部代表
  虚代理 (Virtual Proxy) 根据需要对原始对象的访问，用于对象应该有不同的访问权限的时候
...
    </summary>
  

  </entry>

  
  <entry>
    <title>享元模式</title>
    <link href="https://blog.yexca.net/archives/122" rel="alternate" type="text/html" title="享元模式" />
    <published>2023-09-07T13:54:00+08:00</published>
  
    <updated>2023-10-09T17:49:52+08:00</updated>
  
    <id>https://blog.yexca.net/archives/122</id>
    <content src="https://blog.yexca.net/archives/122" />
    <author>
      <name>yexca</name>
    </author>

  
    
    <category term="软件工程" />
    
  

  
    <summary>
      





      Flyweight Pattern 对象结构型模式

意图

运用共享技术有效地支持大量细粒度的对象

结构



其中：


  
    Flyweight 描述一个接口，通过这个接口 Flyweight 可以接受并作用于外部状态
  
  
    ConcreteFlyweight 实现 Flyweight 接口，并为内部状态 (如果有) 增加存储空间。ConcreteFlyweight 对象必项是可共享的。它所存储的状态必须是内部的，即它必须独立于 ConcreteFlyweight 对象的场景
  
  
    并非所有的 Flyweight 子类都需要被共享。Flyweight 接口使共享成为可能，但它并不强制共亨。在 Flyweight 对象结构的某些层次，UnsharedConcreteFlyweight 对象通常将 ConcreteFlyweight 对象作为子...
    </summary>
  

  </entry>

</feed>


